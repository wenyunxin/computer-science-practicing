[toc]





---

# Bayes' theorem

In [probability theory](https://en.wikipedia.org/wiki/Probability_theory) and [statistics](https://en.wikipedia.org/wiki/Statistics), **Bayes' theorem** (alternatively **Bayes' law** or **Bayes' rule**; recently **Bayes–Price theorem**[[1\]](https://en.wikipedia.org/wiki/Bayes'_theorem#cite_note-Liberty's_Apostle-1): 44–46, 67 ), named after [Thomas Bayes](https://en.wikipedia.org/wiki/Thomas_Bayes), describes the [probability](https://en.wikipedia.org/wiki/Probability) of an [event](https://en.wikipedia.org/wiki/Event_(probability_theory)), based on prior knowledge of conditions that might be related to the event.[[2\]](https://en.wikipedia.org/wiki/Bayes'_theorem#cite_note-2) For example, if the risk of developing health problems is known to increase with age, Bayes' theorem allows the risk to an individual of a known age to be assessed more accurately (by conditioning it on their age) than simply assuming that the individual is typical of the population as a whole.

> 在[概率论](https://en.wikipedia.org/wiki/Probability_theory)和[统计学](https://en.wikipedia.org/wiki/Statistics)中，**贝叶斯定理**(又称**贝叶斯定律**或**贝叶斯规则**；最近的**贝叶斯-价格定理**[[1]](https://en.wikipedia.org/wiki/Bayes'_theorem#cite_note-Liberty_Apostle-1)。 44-46, 67 )，以[托马斯-贝叶斯](https://en.wikipedia.org/wiki/Thomas_Bayes)命名，根据可能与事件有关的条件的先验知识，描述了[事件](https://en.wikipedia.org/wiki/Probability)的[概率](https://en.wikipedia.org/wiki/Probability)。<sup>[[2]](https://en.wikipedia.org/wiki/Bayes'_theorem#cite_note-2)</sup>例如，如果已知出现健康问题的风险随着年龄的增长而增加，Bayes定理允许对已知年龄的个人的风险进行评估（通过对其年龄进行调节），而不是简单地假设该个人是整个人群的典型。

One of the1 many applications of Bayes' theorem is [Bayesian inference](https://en.wikipedia.org/wiki/Bayesian_inference), a particular approach to [statistical inference](https://en.wikipedia.org/wiki/Statistical_inference). When applied, the probabilities involved in the theorem may have different [probability interpretations](https://en.wikipedia.org/wiki/Probability_interpretation). With [Bayesian probability](https://en.wikipedia.org/wiki/Bayesian_probability) interpretation, the theorem expresses how a degree of belief, expressed as a probability, should rationally change to account for the availability of related evidence. Bayesian inference is fundamental to [Bayesian statistics](https://en.wikipedia.org/wiki/Bayesian_statistics), being considered "to the theory of probability what Pythagoras's theorem is to geometry."[[3]](https://en.wikipedia.org/wiki/Bayes'_theorem#cite_note-3)

> 贝叶斯定理的众多应用之一是[贝叶斯推理](https://en.wikipedia.org/wiki/Bayesian_inference)，这是一种特殊的[统计推理](https://en.wikipedia.org/wiki/Statistical_inference)方法。在应用时，该定理中涉及的概率可能有不同的[概率解释](https://en.wikipedia.org/wiki/Probability_interpretation)。通过[贝叶斯概率](https://en.wikipedia.org/wiki/Bayesian_probability)的解释，该定理表达了以概率表示的信念程度应如何合理地改变，以考虑到相关证据的可用性。贝叶斯推断是[贝叶斯统计学](https://en.wikipedia.org/wiki/Bayesian_statistics)的基础，被认为是 "对概率理论的作用就像毕达哥拉斯定理对几何学的作用一样。"[[3]](https://en.wikipedia.org/wiki/Bayes'_Theorem#cite_note-3)
>

## Statement of theorem

Bayes' theorem is stated mathematically as the following equation:[[4\]](https://en.wikipedia.org/wiki/Bayes'_theorem#cite_note-4)

> 贝叶斯定理在数学上被表述为以下公式：[[4]](https://en.wikipedia.org/wiki/Bayes'_theorem#cite_note-4)
>

![{\displaystyle P(A\mid B)={\frac {P(B\mid A)P(A)}{P(B)}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/87c061fe1c7430a5201eef3fa50f9d00eac78810)



在这里A和B是事件，且 ![{\displaystyle P(B)\neq 0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4696c4543d63622a09c29cbb00c0fea4e0b8d7b7).

- ![P(A\mid B)](https://wikimedia.org/api/rest_v1/media/math/render/svg/8f8f30f4da85b53901e0871eb41ed8827f511bb7) 是一个条件概率：当给定的事件B是真的时候，事件A出现的概率。它也称为在给定B的情况下，A的后验概率。
- ![{\displaystyle P(B\mid A)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e2fe9ad0fdfd8920e56ca948400e111852af0665) 也是一个条件概率：当给定的事件A是真的时候，事件B出现的概率。它也可以被解释为在固定的B条件下A的可能性，因为![{\displaystyle P(B\mid A)=L(A\mid B)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/28cfc18ecc74984b90db23005914dcb649b7e30e).
- ![P(A)](https://wikimedia.org/api/rest_v1/media/math/render/svg/4f264d19e21604793c6dc54f8044df454db82744) 和 ![P(B)](https://wikimedia.org/api/rest_v1/media/math/render/svg/e593d180a26fd68657ea50368dbfe1a661e652aa)是没有任何给定条件下，分别代表A和B的可观测概率；它们被称为边际概率或先验概率。

### Proof

#### For event

Bayes' theorem may be derived from the definition of [conditional probability](https://en.wikipedia.org/wiki/Conditional_probability):

> 贝叶斯定理可以从[条件概率](https://en.wikipedia.org/wiki/Conditional_probability)的定义中得出：

![{\displaystyle P(A\mid B)={\frac {P(A\cap B)}{P(B)}},{\text{ if }}P(B)\neq 0,}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7b424233f9f41ed1e6e96deecab00e0e158029ec)





---

# Artificial intelligence

**Artificial intelligence** (**AI**) is [intelligence](https://en.wikipedia.org/wiki/Intelligence) demonstrated by [machines](https://en.wikipedia.org/wiki/Machine), as opposed to the **natural intelligence** displayed by [animals](https://en.wikipedia.org/wiki/Animal_cognition) including [humans](https://en.wikipedia.org/wiki/Human_intelligence). AI research has been defined as the field of study of [intelligent agents](https://en.wikipedia.org/wiki/Intelligent_agent), which refers to any system that perceives its environment and takes actions that maximize its chance of achieving its goals.[[a\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Definition_of_AI-1)

> **人工智能**（**AI**）是由[机器](https://en.wikipedia.org/wiki/Machine)展示的[智能](https://en.wikipedia.org/wiki/Intelligence)，与包括[人类](https://en.wikipedia.org/wiki/Human_intelligence)在内的[动物](https://en.wikipedia.org/wiki/Animal_cognition)展示的**自然智能**相对应。人工智能研究被定义为[智能工具](https://en.wikipedia.org/wiki/Intelligent_agent)的研究领域，它指的是任何能够感知其环境并采取最大限度地实现其目标的行动的系统。[[a]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Definition_of_AI-1)

The term "artificial intelligence" had previously been used to describe machines that mimic and display "human" cognitive skills that are associated with the [human mind](https://en.wikipedia.org/wiki/Human_mind), such as "learning" and "problem-solving". This definition has since been rejected by major AI researchers who now describe AI in terms of [rationality](https://en.wikipedia.org/wiki/Rationality) and acting rationally, which does not limit how intelligence can be articulated.[[b\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-3)

> "人工智能 "一词以前被用来描述模仿和显示与[人类思维](https://en.wikipedia.org/wiki/Human_mind)有关的 "人类 "认知技能的机器，如 "学习 "和 "解决问题"。这个定义后来被主要的人工智能研究者所拒绝，他们现在用[理性](https://en.wikipedia.org/wiki/Rationality)和理性行事来描述人工智能，这并不限制智能的表达方式。[[b]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-3)

[AI applications](https://en.wikipedia.org/wiki/AI_applications) include advanced [web search](https://en.wikipedia.org/wiki/Web_search) engines (e.g., [Google](https://en.wikipedia.org/wiki/Google_Search)), [recommendation systems](https://en.wikipedia.org/wiki/Recommender_system) (used by [YouTube](https://en.wikipedia.org/wiki/YouTube), [Amazon](https://en.wikipedia.org/wiki/Amazon_(company)) and [Netflix](https://en.wikipedia.org/wiki/Netflix)), [understanding human speech](https://en.wikipedia.org/wiki/Natural-language_understanding) (such as [Siri](https://en.wikipedia.org/wiki/Siri) and [Alexa](https://en.wikipedia.org/wiki/Amazon_Alexa)), [self-driving cars](https://en.wikipedia.org/wiki/Self-driving_car) (e.g., [Tesla](https://en.wikipedia.org/wiki/Tesla,_Inc.)), [automated decision-making](https://en.wikipedia.org/wiki/Automated_decision-making) and competing at the highest level in [strategic game](https://en.wikipedia.org/wiki/Strategic_game) systems (such as [chess](https://en.wikipedia.org/wiki/Chess) and [Go](https://en.wikipedia.org/wiki/Go_(game))).[[2\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEGoogle2016-4) As machines become increasingly capable, tasks considered to require "intelligence" are often removed from the definition of AI, a phenomenon known as the [AI effect](https://en.wikipedia.org/wiki/AI_effect).[[3\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcCorduck2004204-5) For instance, [optical character recognition](https://en.wikipedia.org/wiki/Optical_character_recognition) is frequently excluded from things considered to be AI,[[4\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEAshok832019-6) having become a routine technology.[[5\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTESchank199138-7)

> [人工智能应用](https://en.wikipedia.org/wiki/AI_applications)包括先进的[网络搜索](https://en.wikipedia.org/wiki/Web_search)引擎（如[谷歌](https://en.wikipedia.org/wiki/Google_Search)）、[推荐系统](https://en.wikipedia.org/wiki/Recommender_system)（由[YouTube](https://en.wikipedia.org/wiki/YouTube)、[亚马逊](https://en.wikipedia.org/wiki/Amazon_(公司))和[Netflix](https://en.wikipedia.org/wiki/Netflix)使用）、[理解人类语音](https://en.wikipedia.org/wiki/Natural-language_understanding)（如[Siri](https://en.wikipedia.org/wiki/Siri) 和[Alexa](https://en.wikipedia.org/wiki/Amazon_Alexa) ）、[自动驾驶汽车](https://en.wikipedia.org/wiki/Self-driving_car) （例如。[Tesla](https://en.wikipedia.org/wiki/Tesla,_Inc.))、[自动决策](https://en.wikipedia.org/wiki/Automated_decision-making)以及在[战略游戏](https://en.wikipedia.org/wiki/Strategic_game)系统中进行最高水平的竞争(如[国际象棋](https://en.wikipedia.org/wiki/Chess)和[围棋](https://en.wikipedia.org/wiki/Go_(游戏))。[[2\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEGoogle2016-4) 随着机器变得越来越有能力，被认为需要 "智能 "的任务往往从人工智能的定义中删除，这一现象被称为[人工智能效应](https://en.wikipedia.org/wiki/AI_effect)。[[3\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcCorduck2004204-5) 例如，[光学字符识别](https://en.wikipedia.org/wiki/Optical_character_recognition)经常被排除在被认为是人工智能的事物之外，[[4\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEAshok832019-6)已经成为一种常规技术。[[5\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTESchank199138-7)

Artificial intelligence was founded as an academic discipline in 1956, and in the years since has experienced several waves of optimism,[[6\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTECrevier1993109-8)[[7\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_in_the_80s-9) followed by disappointment and the loss of funding (known as an "[AI winter](https://en.wikipedia.org/wiki/AI_winter)"),[[8\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-First_AI_winter-10)[[9\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Second_AI_winter-11) followed by new approaches, success and renewed funding.[[7\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_in_the_80s-9)[[10\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEClark2015b-12) AI research has tried and discarded many different approaches since its founding, including simulating the brain, [modeling human problem solving](https://en.wikipedia.org/wiki/Symbolic_AI#Cognitive_simulation), [formal logic](https://en.wikipedia.org/wiki/Symbolic_AI#Logic-based), [large databases of knowledge](https://en.wikipedia.org/wiki/Symbolic_AI#Knowledge-based) and imitating animal behavior. In the first decades of the 21st century, highly mathematical-statistical [machine learning](https://en.wikipedia.org/wiki/Machine_learning) has dominated the field, and this technique has proved highly successful, helping to solve many challenging problems throughout industry and academia.[[10\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEClark2015b-12)[[11\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_widely_used_1990s-13)

> 人工智能作为一门学术学科成立于1956年，在此后的几年里，经历了几波乐观的浪潮，随后是失望和失去资金（被称为"[人工智能的冬天](https://en.wikipedia.org/wiki/AI_winter)"），随后是新方法、成功和重新得到资金。人工智能研究自成立以来已经尝试并抛弃了许多不同的方法，包括模拟大脑、[模拟人类解决问题](https://en.wikipedia.org/wiki/Symbolic_AI#Cognitive_simulation)、[形式逻辑](https://en.wikipedia.org/wiki/Symbolic_AI#Logic-based)、[大型知识数据库](https://en.wikipedia.org/wiki/Symbolic_AI#Knowledge-based)和模仿动物行为。在21世纪的前几十年，高度数学-统计学的[机器学习](https://en.wikipedia.org/wiki/Machine_learning)在该领域占主导地位，这种技术已被证明非常成功，有助于解决整个工业和学术界的许多挑战性问题。[[10]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEClark2015b-12)[[11]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_widely_used_1990s-13)
>

The various sub-fields of AI research are centered around particular goals and the use of particular tools. The traditional goals of AI research include [reasoning](https://en.wikipedia.org/wiki/Automated_reasoning), [knowledge representation](https://en.wikipedia.org/wiki/Knowledge_representation), [planning](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling), [learning](https://en.wikipedia.org/wiki/Machine_learning), [natural language processing](https://en.wikipedia.org/wiki/Natural_language_processing), [perception](https://en.wikipedia.org/wiki/Machine_perception), and the ability to move and manipulate objects.[[c\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Problems_of_AI-14) [General intelligence](https://en.wikipedia.org/wiki/Artificial_general_intelligence) (the ability to solve an arbitrary problem) is among the field's long-term goals.[[12\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Artificial_General_Intelligence-15) To solve these problems, AI researchers have adapted and integrated a wide range of problem-solving techniques—including search and mathematical optimization, formal logic, [artificial neural networks](https://en.wikipedia.org/wiki/Artificial_neural_network), and methods based on [statistics](https://en.wikipedia.org/wiki/Statistics), [probability](https://en.wikipedia.org/wiki/Probability) and [economics](https://en.wikipedia.org/wiki/Economics). AI also draws upon [computer science](https://en.wikipedia.org/wiki/Computer_science), [psychology](https://en.wikipedia.org/wiki/Psychology), [linguistics](https://en.wikipedia.org/wiki/Linguistics), [philosophy](https://en.wikipedia.org/wiki/Philosophy), and many other fields.

> 人工智能研究的各个子领域都围绕着特定的目标和特定工具的使用。人工智能研究的传统目标包括[推理](https://en.wikipedia.org/wiki/Automated_reasoning)、[知识表示](https://en.wikipedia.org/wiki/Knowledge_representation)、[计划](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling)、[学习](https://en.wikipedia.org/wiki/Machine_learning)、[自然语言处理](https://en.wikipedia.org/wiki/Natural_language_processing)、[感知](https://en.wikipedia.org/wiki/Machine_perception)以及移动和操纵物体的能力。 [通用智能](https://en.wikipedia.org/wiki/Artificial_general_intelligence)（解决任意问题的能力）是该领域的长期目标之一。[[12]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Artificial_General_Intelligence-15) 为了解决这些问题，人工智能研究人员已经适应并整合了广泛的问题解决技术--包括搜索和数学优化、形式逻辑、[人工神经网络](https://en.wikipedia.org/wiki/Artificial_neural_network)，以及基于[统计学](https://en.wikipedia.org/wiki/Statistics)、[概率](https://en.wikipedia.org/wiki/Probability)和[经济学](https://en.wikipedia.org/wiki/Economics)的方法。人工智能还借鉴了[计算机科学](https://en.wikipedia.org/wiki/Computer_science)、[心理学](https://en.wikipedia.org/wiki/Psychology)、[语言学](https://en.wikipedia.org/wiki/Linguistics)、[哲学](https://en.wikipedia.org/wiki/Philosophy)以及许多其他领域的方法。

The field was founded on the assumption that human intelligence "can be so precisely described that a machine can be made to simulate it".[[d\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-17) This raised philosophical arguments about the mind and the ethical consequences of creating artificial beings endowed with human-like intelligence; these issues have previously been explored by [myth](https://en.wikipedia.org/wiki/History_of_artificial_intelligence#Precursors), [fiction](https://en.wikipedia.org/wiki/Artificial_intelligence_in_fiction) and [philosophy](https://en.wikipedia.org/wiki/Philosophy_of_artificial_intelligence) since antiquity.[[14\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTENewquist199445–53-18) [Computer scientists](https://en.wikipedia.org/wiki/Computer_scientist) and [philosophers](https://en.wikipedia.org/wiki/Philosopher) have since suggested that AI may become an [existential risk](https://en.wikipedia.org/wiki/Existential_risk) to humanity if its rational capacities are not steered towards beneficial goals.[[e\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Future_risks_of_AI-19)

> 这个领域建立在这样的假设上：人类的智力 "可以被精确地描述，以至于可以制造出一台机器来模拟它。"这引起了关于心灵和创造具有类似人类智力的人造人的伦理后果的哲学争论；这些问题之前已经由[神话](https://en.wikipedia.org/wiki/History_of_artificial_intelligence#Precursors)、[小说](https://en.wikipedia.org/wiki/Artificial_intelligence_in_fiction)和[哲学](https://en)探讨过了。 自古以来就在探讨这些问题。[[14]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTENewquist199445-53-18) [计算机科学家](https://en.wikipedia.org/wiki/Computer_scientist)和[哲学家](https://en.wikipedia.org/wiki/Philosopher)后来提出，如果不将人工智能的理性能力引向有益的目标，它可能成为人类的[生存危险](https://en.wikipedia.org/wiki/Existential_risk)。
>

## History

### Fictions and early concepts

[Artificial beings](https://en.wikipedia.org/wiki/Artificial_being) with intelligence appeared as [storytelling devices](https://en.wikipedia.org/wiki/Storytelling_device) in antiquity,[[15\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_in_myth-20) and have been common in fiction, as in [Mary Shelley](https://en.wikipedia.org/wiki/Mary_Shelley)'s *[Frankenstein](https://en.wikipedia.org/wiki/Frankenstein)* or [Karel Čapek](https://en.wikipedia.org/wiki/Karel_Čapek)'s *[R.U.R.](https://en.wikipedia.org/wiki/R.U.R.)*[[16\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcCorduck200417–25-21) These characters and their fates raised many of the same issues now discussed in the [ethics of artificial intelligence](https://en.wikipedia.org/wiki/Ethics_of_artificial_intelligence).[[17\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcCorduck2004340–400-22)

The study of mechanical or ["formal" reasoning](https://en.wikipedia.org/wiki/Formal_reasoning) began with [philosophers](https://en.wikipedia.org/wiki/Philosopher) and mathematicians in antiquity. The study of mathematical logic led directly to [Alan Turing](https://en.wikipedia.org/wiki/Alan_Turing)'s [theory of computation](https://en.wikipedia.org/wiki/Theory_of_computation), which suggested that a machine, by shuffling symbols as simple as "0" and "1", could simulate any conceivable act of mathematical deduction. This insight that digital computers can simulate any process of formal reasoning is known as the [Church–Turing thesis](https://en.wikipedia.org/wiki/Church–Turing_thesis).[[18\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEBerlinski2000-23)

The Church-Turing thesis, along with concurrent discoveries in [neurobiology](https://en.wikipedia.org/wiki/Neuroscience), [information theory](https://en.wikipedia.org/wiki/Information_theory) and [cybernetics](https://en.wikipedia.org/wiki/Cybernetics), led researchers to consider the possibility of building an electronic brain.[[19\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-24) The first work that is now generally recognized as AI was [McCullouch](https://en.wikipedia.org/wiki/Warren_McCullouch) and [Pitts](https://en.wikipedia.org/wiki/Walter_Pitts)' 1943 formal design for [Turing-complete](https://en.wikipedia.org/wiki/Turing-complete) "artificial neurons".[[20\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTERussellNorvig200916-25)

> 具有智能的[人造人](https://en.wikipedia.org/wiki/Artificial_being)在古代作为[讲故事的工具](https://en.wikipedia.org/wiki/Storytelling_device)出现，[[15]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_in_myth-20)在小说中也很常见，如[玛丽-雪莱](https://en.wikipedia.org/wiki/Mary_Shelley)的*[弗兰肯斯坦](https://en.wikipedia.org/wiki/Frankenstein)*或[卡雷尔-恰佩克](https://en.wikipedia.org/wiki/Karel_Čapek)的*[R.U.R](https://en.wikipedia.org/wiki/R.U.R)*[[16]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcCorduck200417-25-21) 这些人物和他们的命运提出了许多现在在[人工智能的伦理学](https://en.wikipedia.org/wiki/Ethics_of_artificial_intelligence)中讨论的相同问题。[[17\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcCorduck2004340-400-22)
>
> 对机械或["形式 "推理](https://en.wikipedia.org/wiki/Formal_reasoning)的研究始于古代的[哲学家](https://en.wikipedia.org/wiki/Philosopher)和数学家。对数理逻辑的研究直接导致了[阿兰-图灵](https://en.wikipedia.org/wiki/Alan_Turing)的[计算理论](https://en.wikipedia.org/wiki/Theory_of_computation)，它提出，一台机器通过洗刷简单如 "0 "和 "1 "的符号，可以模拟任何可以想象的数学推理行为。这个关于数字计算机可以模拟任何形式推理过程的见解被称为[Church-Turing thesis](https://en.wikipedia.org/wiki/Church-Turing_thesis)。[[18]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEBerlinski2000-23)
>
> 丘奇-图灵论文，以及同时在[神经生物学](https://en.wikipedia.org/wiki/Neuroscience)、[信息论](https://en.wikipedia.org/wiki/Information_theory)和[控制论](https://en.wikipedia.org/wiki/Cybernetics)中的发现，导致研究人员考虑建立一个电子大脑的可能性。[[19\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-24)现在被普遍认为是人工智能的第一项工作是[McCullouch](https://en.wikipedia.org/wiki/Warren_McCullouch)和[Pitts](https://en.wikipedia.org/wiki/Walter_Pitts) 1943年对[图灵完全](https://en.wikipedia.org/wiki/Turing-complete) "人工神经元 "的形式设计。

### Early researches

By the 1950s, two visions for how to achieve machine intelligence emerged. One vision, known as [Symbolic AI](https://en.wikipedia.org/wiki/Symbolic_AI) or [GOFAI](https://en.wikipedia.org/wiki/GOFAI), was to use computers to create a symbolic representation of the world and systems that could reason about the world. Proponents included [Allen Newell](https://en.wikipedia.org/wiki/Allen_Newell), [Herbert A. Simon](https://en.wikipedia.org/wiki/Herbert_A._Simon), and [Marvin Minsky](https://en.wikipedia.org/wiki/Marvin_Minsky). Closely associated with this approach was the ["heuristic search"](https://en.wikipedia.org/wiki/Heuristic_(computer_science)) approach, which likened intelligence to a problem of exploring a space of possibilities for answers. The second vision, known as the [connectionist approach](https://en.wikipedia.org/wiki/Connectionism), sought to achieve intelligence through learning. Proponents of this approach, most prominently [Frank Rosenblatt](https://en.wikipedia.org/wiki/Frank_Rosenblatt), sought to connect [Perceptron](https://en.wikipedia.org/wiki/Perceptrons) in ways inspired by connections of neurons.[[21\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEManyika20229-26) [James Manyika](https://en.wikipedia.org/wiki/James_Manyika) and others have compared the two approaches to the mind (Symbolic AI) and the brain (connectionist). Manyika argues that symbolic approaches dominated the push for artificial intelligence in this period, due in part to its connection to intellectual traditions of [Descarte](https://en.wikipedia.org/wiki/Descarte), [Boole](https://en.wikipedia.org/wiki/Boole), [Gottlob Frege](https://en.wikipedia.org/wiki/Gottlob_Frege), [Bertrand Russell](https://en.wikipedia.org/wiki/Bertrand_Russell), and others. Connectionist approaches based on [cybernetics](https://en.wikipedia.org/wiki/Cybernetics) or [artificial neural networks](https://en.wikipedia.org/wiki/Artificial_neural_network) were pushed to the background but have gained new prominence in recent decades.[[22\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEManyika202210-27)

The field of AI research was born at [a workshop](https://en.wikipedia.org/wiki/Dartmouth_workshop) at [Dartmouth College](https://en.wikipedia.org/wiki/Dartmouth_College) in 1956.[[f\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-30)[[25\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-31) The attendees became the founders and leaders of AI research.[[g\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-32) They and their students produced programs that the press described as "astonishing":[[h\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-34) computers were learning [checkers](https://en.wikipedia.org/wiki/Draughts) strategies, solving word problems in algebra, proving [logical theorems](https://en.wikipedia.org/wiki/Theorem) and speaking English.[[i\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-35)[[27\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-36) By the middle of the 1960s, research in the U.S. was heavily funded by the [Department of Defense](https://en.wikipedia.org/wiki/DARPA)[[28\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-37) and laboratories had been established around the world.[[29\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEHowe1994-38)

Researchers in the 1960s and the 1970s were convinced that symbolic approaches would eventually succeed in creating a machine with [artificial general intelligence](https://en.wikipedia.org/wiki/Artificial_general_intelligence) and considered this the goal of their field.[[30\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTENewquist199486–86-39) [Herbert Simon](https://en.wikipedia.org/wiki/Herbert_A._Simon) predicted, "machines will be capable, within twenty years, of doing any work a man can do".[[31\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-40) [Marvin Minsky](https://en.wikipedia.org/wiki/Marvin_Minsky) agreed, writing, "within a generation ... the problem of creating 'artificial intelligence' will substantially be solved".[[32\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-41)

They failed to recognize the difficulty of some of the remaining tasks. Progress slowed and in 1974, in response to the [criticism](https://en.wikipedia.org/wiki/Lighthill_report) of [Sir James Lighthill](https://en.wikipedia.org/wiki/Sir_James_Lighthill)[[33\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTELighthill1973-42) and ongoing pressure from the US Congress to [fund more productive projects](https://en.wikipedia.org/wiki/Mansfield_Amendment), both the U.S. and British governments cut off exploratory research in AI. The next few years would later be called an "[AI winter](https://en.wikipedia.org/wiki/AI_winter)", a period when obtaining funding for AI projects was difficult.[[8\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-First_AI_winter-10)

> 到20世纪50年代，出现了两种关于如何实现机器智能的愿景。一种设想被称为[符号人工智能](https://en.wikipedia.org/wiki/Symbolic_AI)或[GOFAI](https://en.wikipedia.org/wiki/GOFAI)，即使用计算机来创建世界的符号表示，以及可以推理世界的系统。支持者包括[Allen Newell](https://en.wikipedia.org/wiki/Allen_Newell)、[Herbert A. Simon](https://en.wikipedia.org/wiki/Herbert_A._Simon)和[Marvin Minsky](https://en.wikipedia.org/wiki/Marvin_Minsky) 。与这种方法密切相关的是["启发式搜索"](https://en.wikipedia.org/wiki/Heuristic_(computer_science))方法，它将智能比作一个探索答案的可能性空间的问题。第二种观点被称为[连接主义方法](https://en.wikipedia.org/wiki/Connectionism)，试图通过学习来实现智能。这种方法的支持者，最突出的是[Frank Rosenblatt](https://en.wikipedia.org/wiki/Frank_Rosenblatt)，试图以受到神经元连接启发的方式连接[Perceptron](https://en.wikipedia.org/wiki/Perceptrons)。[[21]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEManyika20229-26)[James Manyika](https://en.wikipedia.org/wiki/James_Manyika)和其他人将这两种方法与思维（符号型人工智能）和大脑（连接型）相比较。Manyika认为，符号方法在这一时期主导了对人工智能的推动，部分原因是它与[Descarte](https://en.wikipedia.org/wiki/Descarte)、[Boole](https://en.wikipedia.org/wiki/Boole)、[Gottlob Frege](https://en.wikipedia.org/wiki/Gottlob_Frege)、[Bertrand Russell](https://en.wikipedia.org/wiki/Bertrand_Russell)等人的知识传统有关。基于[控制论](https://en.wikipedia.org/wiki/Cybernetics)或[人工神经网络](https://en.wikipedia.org/wiki/Artificial_neural_network)的连接主义方法被推到后台，但在最近几十年里获得了新的突出地位。[[22]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEManyika202210-27)
>
> 人工智能研究领域诞生于1956年[达特茅斯学院](https://en.wikipedia.org/wiki/Dartmouth_College)的[研讨会](https://en.wikipedia.org/wiki/Dartmouth_workshop)。[[f\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-30)[[25\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-31)与会者成为人工智能研究的创始人和领导者。[[g\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-32)他们和他们的学生制作的程序被媒体称为 "令人震惊"：[[h\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-34) 计算机正在学习[跳棋](https://en.wikipedia.org/wiki/Draughts)策略，解决代数中的文字问题，证明[逻辑定理](https://en.wikipedia.org/wiki/Theorem)和说英语。[[i\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-35)[[27\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-36)到60年代中期，美国的研究得到了[国防部](https://en.wikipedia.org/wiki/DARPA)的大量资助[[28\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-37)，世界各地纷纷建立实验室。
>
> 20世纪60年代和70年代的研究人员相信，符号方法最终会成功地创造出具有[人工通用智能](https://en.wikipedia.org/wiki/Artificial_general_intelligence)的机器，并认为这是他们领域的目标。[[30\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTENewquist199486-86-39) 赫伯特-西蒙[[31\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-40) [Marvin Minsky](https://en.wikipedia.org/wiki/Marvin_Minsky)同意，写道："在一代人之内......创造'人工智能'的问题将大大解决。"[[32\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-41)
>
> 他们没有认识到一些剩余任务的难度。进展放缓，1974年，为了回应[詹姆斯-莱特希尔爵士](https://en.wikipedia.org/wiki/Sir_James_Lighthill)[[33]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTELighthill1973-42)的[批评](https://en.wikipedia.org/wiki/Lighthill_report)和美国国会要求[资助更有成效的项目](https://en.wikipedia.org/wiki/Mansfield_Amendment)的持续压力，美国和英国政府都切断了人工智能的探索性研究。接下来的几年后来被称为"人工智能的冬天“，一个为人工智能项目获得资金的困难时期。[[8]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-First_AI_winter-10)

### From expert systems to machine learning

In the early 1980s, AI research was revived by the commercial success of [expert systems](https://en.wikipedia.org/wiki/Expert_system),[[34\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-43) a form of AI program that simulated the knowledge and analytical skills of human experts. By 1985, the market for AI had reached over a billion dollars. At the same time, Japan's [fifth generation computer](https://en.wikipedia.org/wiki/Fifth_generation_computer) project inspired the U.S and British governments to restore funding for [academic research](https://en.wikipedia.org/wiki/Academic_research).[[7\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_in_the_80s-9) However, beginning with the collapse of the [Lisp Machine](https://en.wikipedia.org/wiki/Lisp_Machine) market in 1987, AI once again fell into disrepute, and a second, longer-lasting winter began.[[9\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Second_AI_winter-11)

Many researchers began to doubt that the [symbolic approach](https://en.wikipedia.org/wiki/Symbolic_AI) would be able to imitate all the processes of human cognition, especially [perception](https://en.wikipedia.org/wiki/Machine_perception), robotics, [learning](https://en.wikipedia.org/wiki/Machine_learning) and [pattern recognition](https://en.wikipedia.org/wiki/Pattern_recognition). A number of researchers began to look into "sub-symbolic" approaches to specific AI problems.[[35\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTENilsson19987-44) [Robotics](https://en.wikipedia.org/wiki/Robotics) researchers, such as [Rodney Brooks](https://en.wikipedia.org/wiki/Rodney_Brooks), rejected symbolic AI and focused on the basic engineering problems that would allow robots to move, survive, and learn their environment.[[j\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-49) Interest in [neural networks](https://en.wikipedia.org/wiki/Artificial_neural_network) and "[connectionism](https://en.wikipedia.org/wiki/Connectionism)" was revived by [Geoffrey Hinton](https://en.wikipedia.org/wiki/Geoffrey_Hinton), [David Rumelhart](https://en.wikipedia.org/wiki/David_Rumelhart) and others in the middle of the 1980s.[[40\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-50) [Soft computing](https://en.wikipedia.org/wiki/Soft_computing) tools were developed in the 80s, such as [neural networks](https://en.wikipedia.org/wiki/Artificial_neural_network), [fuzzy systems](https://en.wikipedia.org/wiki/Fuzzy_system), [Grey system theory](https://en.wikipedia.org/wiki/Grey_system_theory), [evolutionary computation](https://en.wikipedia.org/wiki/Evolutionary_computation) and many tools drawn from [statistics](https://en.wikipedia.org/wiki/Statistics) or [mathematical optimization](https://en.wikipedia.org/wiki/Mathematical_optimization).

AI gradually restored its reputation in the late 1990s and early 21st century by finding specific solutions to specific problems. The narrow focus allowed researchers to produce verifiable results, exploit more mathematical methods, and collaborate with other fields (such as [statistics](https://en.wikipedia.org/wiki/Statistics), [economics](https://en.wikipedia.org/wiki/Economics) and [mathematics](https://en.wikipedia.org/wiki/Mathematical_optimization)).[[41\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_1990s-51) By 2000, solutions developed by AI researchers were being widely used, although in the 1990s they were rarely described as "artificial intelligence".[[11\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_widely_used_1990s-13)

[Faster computers](https://en.wikipedia.org/wiki/Moore's_law), algorithmic improvements, and access to [large amounts of data](https://en.wikipedia.org/wiki/Big_data) enabled advances in [machine learning](https://en.wikipedia.org/wiki/Machine_learning) and perception; data-hungry [deep learning](https://en.wikipedia.org/wiki/Deep_learning) methods started to dominate accuracy benchmarks [around 2012](https://en.wikipedia.org/wiki/Deep_learning#Deep_learning_revolution).[[42\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcKinsey2018-52) According to [Bloomberg's](https://en.wikipedia.org/wiki/Bloomberg_News) Jack Clark, 2015 was a landmark year for artificial intelligence, with the number of software projects that use AI within [Google](https://en.wikipedia.org/wiki/Google) increased from a "sporadic usage" in 2012 to more than 2,700 projects.[[k\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-53) He attributes this to an increase in affordable [neural networks](https://en.wikipedia.org/wiki/Artificial_neural_network), due to a rise in cloud computing infrastructure and to an increase in research tools and datasets.[[10\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEClark2015b-12) In a 2017 survey, one in five companies reported they had "incorporated AI in some offerings or processes".[[43\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-54) The amount of research into AI (measured by total publications) increased by 50% in the years 2015–2019.[[44\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEUNESCO2021-55)

Numerous academic researchers became concerned that AI was no longer pursuing the original goal of creating versatile, fully intelligent machines. Much of current research involves statistical AI, which is overwhelmingly used to solve specific problems, even highly successful techniques such as [deep learning](https://en.wikipedia.org/wiki/Deep_learning). This concern has led to the subfield of [artificial general intelligence](https://en.wikipedia.org/wiki/Artificial_general_intelligence) (or "AGI"), which had several well-funded institutions by the 2010s.[[12\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Artificial_General_Intelligence-15)

> 20世纪80年代初，人工智能研究因[专家系统](https://en.wikipedia.org/wiki/Expert_system)的商业成功而复苏，[[34]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-43)是一种模拟人类专家的知识和分析技能的人工智能程序形式。到1985年，人工智能的市场已经达到10亿美元以上。与此同时，日本的[第五代计算机](https://en.wikipedia.org/wiki/Fifth_generation_computer)项目激发了美国和英国政府恢复对[学术研究](https://en.wikipedia.org/wiki/Academic_research)的资助。[[7\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AI_in_the_80s-9)然而，从1987年[Lisp Machine](https://en.wikipedia.org/wiki/Lisp_Machine)市场的崩溃开始，人工智能再次陷入耻辱，第二个更持久的冬天开始。[[9\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Second_AI_winter-11)
>
> 许多研究人员开始怀疑[符号方法](https://en.wikipedia.org/wiki/Symbolic_AI)是否能够模仿人类认知的所有过程，特别是[感知](https://en.wikipedia.org/wiki/Machine_perception)、机器人、[学习](https://en.wikipedia.org/wiki/Machine_learning)和[模式识别](https://en.wikipedia.org/wiki/Pattern_recognition)。一些研究人员开始研究 "亚符号 "方法来解决具体的人工智能问题。[[35]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTENilsson19987-44)[机器人学](https://en.wikipedia.org/wiki/Robotics)研究人员，如[Rodney Brooks](https://en.wikipedia.org/wiki/Rodney_Brooks)，拒绝了符号人工智能，而专注于使机器人能够移动、生存和学习环境的基本工程问题。[[j]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-49)对[神经网络](https://en.wikipedia.org/wiki/Artificial_neural_network)和[连接主义](https://en.wikipedia.org/wiki/Connectionism) 的兴趣被Geoffrey Hinton、[David Rumelhart](https://en.wikipedia.org/wiki/David_Rumelhart)和其他人在80年代中期恢复了对[[40]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-50)[软计算](https://en.wikipedia.org/wiki/Soft_computing)工具的研究，例如[神经网络](https://en.wikipedia.org/wiki/Artificial_neural_network)、[模糊系统](https://en.wikipedia.org/wiki/Fuzzy_system)、[灰色系统理论](https://en.wikipedia.org/wiki/Grey_system_theory)、[进化计算](https://en.wikipedia.org/wiki/Evolutionary_computation)以及许多从[统计学](https://en.wikipedia.org/wiki/Statistics)或[数学优化](https://en.wikipedia.org/wiki/Mathematical_optimization)中汲取的工具。
>
> 在20世纪90年代末和21世纪初，人工智能通过寻找特定问题的具体解决方案逐渐恢复了其声誉。狭窄的重点使研究人员能够产生可验证的结果，利用更多的数学方法，并与其他领域（如[统计学](https://en.wikipedia.org/wiki/Statistics)、[经济学](https://en.wikipedia.org/wiki/Economics)和[数学](https://en.wikipedia.org/wiki/Mathematical_optimization)）合作。到2000年，人工智能研究人员开发的解决方案被广泛使用，尽管在1990年代，他们很少被描述为 "人工智能"。
>
> [更快的计算机](https://en.wikipedia.org/wiki/Moore's_law)、算法的改进以及对[大量数据](https://en.wikipedia.org/wiki/Big_data)的获取使得[机器学习](https://en.wikipedia.org/wiki/Machine_learning)和感知方面取得了进展；对数据要求很高的[深度学习](https://en.wikipedia.org/wiki/Deep_learning)方法开始在准确性基准方面占据优势[大约在2012年](https://en.wikipedia.org/wiki/Deep_learning#Deep_learning_revolution)。[[42]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcKinsey2018-52) 根据彭博的Jack Clark：2015年是人工智能的一个里程碑，在[谷歌](https://en.wikipedia.org/wiki/Google)内部使用人工智能的软件项目数量从2012年的 "零星使用 "增加到2700多个项目。他将此归因于由于云计算基础设施的上升，以及研究工具和数据集的增加，价格低廉的[神经网络](https://en.wikipedia.org/wiki/Artificial_neural_network)增加了。在2017年的一项调查中，五分之一的公司表示他们已经 "在一些产品或流程中纳入了人工智能"。[[43]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-54) 2015-2019年，对人工智能的研究量（以总出版物衡量）增加了50%。[[44]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEUNESCO2021-55)
>
> 众多学术研究人员开始担心，人工智能不再追求创造多功能、全智能机器的最初目标。目前的许多研究涉及到统计人工智能，它绝大多数被用来解决具体问题，甚至是非常成功的技术，如[深度学习](https://en.wikipedia.org/wiki/Deep_learning)。这种担忧导致了[人工通用智能](https://en.wikipedia.org/wiki/Artificial_general_intelligence)（或 "AGI"）这一子领域的出现，到2010年代，该领域有几个资金充足的机构。

## Goals

The general problem of simulating (or creating) intelligence has been broken down into sub-problems. These consist of particular traits or capabilities that researchers expect an intelligent system to display. The traits described below have received the most attention.[[c\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Problems_of_AI-14)

> 模拟（或创造）智能的一般问题已经被分解为子问题。这些问题由研究人员期望智能系统显示的特定特征或能力组成。下面描述的特征受到了最多的关注。[[c]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Problems_of_AI-14)

### Reasoning, problem-solving

Early researchers developed algorithms that imitated step-by-step reasoning that humans use when they solve puzzles or make logical deductions.[[45\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-56) By the late 1980s and 1990s, AI research had developed methods for dealing with [uncertain](https://en.wikipedia.org/wiki/Uncertainty) or incomplete information, employing concepts from [probability](https://en.wikipedia.org/wiki/Probability) and [economics](https://en.wikipedia.org/wiki/Economics).[[46\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-57)

Many of these algorithms proved to be insufficient for solving large reasoning problems because they experienced a "combinatorial explosion": they became exponentially slower as the problems grew larger.[[47\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Intractability-58) Even humans rarely use the step-by-step deduction that early AI research could model. They solve most of their problems using fast, intuitive judgments.[[48\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Psychological_evidence_of_sub-symbolic_reasoning-59)

> 早期的研究人员开发了模仿人类在解决难题或进行逻辑推理时使用的逐步推理的算法。[[45\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-56) 到20世纪80年代末和90年代，人工智能研究已经开发了处理[不确定](https://en.wikipedia.org/wiki/Uncertainty)或不完整信息的方法，采用了[概率](https://en.wikipedia.org/wiki/Probability)和[经济学](https://en.wikipedia.org/wiki/Economics)的概念。
>
> 许多这些算法被证明不足以解决大型推理问题，因为它们经历了 "组合爆炸"：随着问题的增大，它们的速度也会呈指数增长。[[47]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Intractability-58) 即使是人类也很少使用早期人工智能研究所能模拟的分步推理。他们使用快速、直观的判断来解决大部分的问题。[[48]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Psychological_evidence_of_sub-symbolic_reasoning-59)
>

### Knowledge representation

Knowledge representation and [knowledge engineering](https://en.wikipedia.org/wiki/Knowledge_engineering)[[49\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-60) allow AI programs to answer questions intelligently and make deductions about real-world facts.

A representation of "what exists" is an [ontology](https://en.wikipedia.org/wiki/Ontology_(information_science)): the set of objects, relations, concepts, and properties formally described so that software agents can interpret them.[[50\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTERussellNorvig2003320–328-61) The most general ontologies are called [upper ontologies](https://en.wikipedia.org/wiki/Upper_ontology), which attempt to provide a foundation for all other knowledge and act as mediators between [domain ontologies](https://en.wikipedia.org/wiki/Domain_ontology) that cover specific knowledge about a particular knowledge [domain](https://en.wikipedia.org/wiki/Domain_ontology) (field of interest or area of concern). A truly intelligent program would also need access to commonsense knowledge; the set of facts that an average person knows. The [semantics](https://en.wikipedia.org/wiki/Semantics) of an ontology is typically represented in description logic, such as the [Web Ontology Language](https://en.wikipedia.org/wiki/Web_Ontology_Language).[[51\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_categories_and_relations-62)

AI research has developed tools to represent specific domains, such as objects, properties, categories and relations between objects;[[51\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_categories_and_relations-62) situations, events, states and time;[[52\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_time-63) causes and effects;[[53\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_causation-64) knowledge about knowledge (what we know about what other people know);.[[54\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_knowledge_about_knowledge-65) [default reasoning](https://en.wikipedia.org/wiki/Default_reasoning) (things that humans assume are true until they are told differently and will remain true even when other facts are changing); [[55\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Default_reasoning_and_non-monotonic_logic-66) as well as other domains. Among the most difficult problems in AI are: the breadth of commonsense knowledge (the number of atomic facts that the average person knows is enormous);[[56\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Breadth_of_commonsense_knowledge-67) and the sub-symbolic form of most commonsense knowledge (much of what people know is not represented as "facts" or "statements" that they could express verbally).[[48\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Psychological_evidence_of_sub-symbolic_reasoning-59)

Formal knowledge representations are used in content-based indexing and retrieval,[[57\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTESmoliarZhang1994-68) scene interpretation,[[58\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTENeumannMöller2008-69) clinical decision support,[[59\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEKupermanReichleyBailey2006-70) knowledge discovery (mining "interesting" and actionable inferences from large databases),[[60\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcGarry2005-71) and other areas.[[61\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEBertiniDel_BimboTorniai2006-72)

> 知识表示和[知识工程](https://en.wikipedia.org/wiki/Knowledge_engineering)[[49]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-60)使人工智能程序能够智能地回答问题，并对现实世界的事实作出推论。
>
> 对 "存在的东西 "的表述是一个[本体](https://en.wikipedia.org/wiki/Ontology_(information_science))：正式描述的对象、关系、概念和属性的集合，以便软件代理能够解释它们。[[50]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTERussellNorvig2003320-328-61)最一般的本体被称为[上层本体](https://en.wikipedia.org/wiki/Upper_ontology)，它试图为所有其他知识提供一个基础，并作为涵盖特定知识的[领域本体](https://en.wikipedia.org/wiki/Domain_ontology)（兴趣领域或关注领域）的调解人。一个真正的智能程序还需要访问常识性知识；一个普通人所知道的一组事实。本体的[语义](https://en.wikipedia.org/wiki/Semantics)通常用描述逻辑表示，如[网络本体语言](https://en.wikipedia.org/wiki/Web_Ontology_Language)。[[51]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_categories_and_relations-62)
>
> 人工智能研究已经开发出代表特定领域的工具，如对象、属性、类别和对象之间的关系；情况、事件、状态和时间；原因和效果；关于知识的知识（我们对其他人所知道的知识）；默认推理]（人类认为是真实的事情，直到他们被告知不同的情况，即使其他事实在变化，也会保持真实）；以及其他领域。人工智能中最困难的问题是：常识性知识的广度（一般人知道的原子事实的数量是巨大的）；[[56]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Breadth_of_commonsense_knowledge-67)和大多数常识性知识的亚符号形式（人们知道的许多东西并不表示为他们可以口头表达的 "事实 "或 "陈述"）。[[48]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Psychological_evidence_of_sub-symbolic_reasoning-59)
>
> 正式的知识表示被用于基于内容的索引和检索、[[57\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTESmoliarZhang1994-68)场景解释、[[58\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTENeumannMöller2008-69)临床决策支持、[[59\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEKupermanReichleyBailey2006-70)知识发现（从大型数据库中挖掘 "有趣 "和可操作的推论）、[[60\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMcGarry2005-71) 和其他领域。

### Planning

*Main article:* [Automated planning and scheduling](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling)

An intelligent agent that can [plan](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling) makes a representation of the state of the world, makes predictions about how their actions will change it and make choices that maximize the [utility](https://en.wikipedia.org/wiki/Utility) (or "value") of the available choices.[[62\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-73) In classical planning problems, the agent can assume that it is the only system acting in the world, allowing the agent to be certain of the consequences of its actions.[[63\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-74) However, if the agent is not the only actor, then it requires that the agent reason under uncertainty, and continuously re-assess its environment and adapt.[[64\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-75) [Multi-agent planning](https://en.wikipedia.org/wiki/Multi-agent_planning) uses the [cooperation](https://en.wikipedia.org/wiki/Cooperation) and competition of many agents to achieve a given goal. [Emergent behavior](https://en.wikipedia.org/wiki/Emergent_behavior) such as this is used by [evolutionary algorithms](https://en.wikipedia.org/wiki/Evolutionary_algorithms) and [swarm intelligence](https://en.wikipedia.org/wiki/Swarm_intelligence).[[65\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-76)

> 一个能够[计划](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling)的智能工具对世界的状态进行表述，对他们的行动将如何改变世界进行预测，并做出选择，使现有选择的[效用](https://en.wikipedia.org/wiki/Utility)最大化。[[62\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-73)在经典的计划问题中，代理可以假设它是世界上唯一的行动系统，使代理能够确定其行动的后果。 [[63\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-74)然而，如果代理人不是唯一的行动者，那么就要求工具在不确定的情况下进行推理，并不断重新评估其环境和适应。[[64\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-75)[多层工具规划](https://en.wikipedia.org/wiki/Multi-agent_planning)利用许多工具的[合作](https://en.wikipedia.org/wiki/Cooperation)和竞争来实现一个特定目标。像这样的[突发行为](https://en.wikipedia.org/wiki/Emergent_behavior)被[进化算法](https://en.wikipedia.org/wiki/Evolutionary_algorithms)和[蜂群智能](https://en.wikipedia.org/wiki/Swarm_intelligence)所使用。[[65\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-76)

### Learning

*Main article:* [Machine learning](https://en.wikipedia.org/wiki/Machine_learning)

Machine learning (ML), a fundamental concept of AI research since the field's inception,[[l\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-79) is the study of computer algorithms that improve automatically through experience.[[m\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-81)

[Unsupervised learning](https://en.wikipedia.org/wiki/Unsupervised_learning) finds patterns in a stream of input. [Supervised learning](https://en.wikipedia.org/wiki/Supervised_learning) requires a human to label the input data first, and comes in two main varieties: [classification](https://en.wikipedia.org/wiki/Statistical_classification) and numerical [regression](https://en.wikipedia.org/wiki/Regression_analysis). Classification is used to determine what category something belongs in—the program sees a number of examples of things from several categories and will learn to classify new inputs. Regression is the attempt to produce a function that describes the relationship between inputs and outputs and predicts how the outputs should change as the inputs change. Both classifiers and regression learners can be viewed as "function approximators" trying to learn an unknown (possibly implicit) function; for example, a spam classifier can be viewed as learning a function that maps from the text of an email to one of two categories, "spam" or "not spam".[[69\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-82) In [reinforcement learning](https://en.wikipedia.org/wiki/Reinforcement_learning) the agent is rewarded for good responses and punished for bad ones. The agent classifies its responses to form a strategy for operating in its problem space.[[70\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-83) [Transfer learning](https://en.wikipedia.org/wiki/Transfer_learning) is when the knowledge gained from one problem is applied to a new problem.[[71\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEThe_Economist2016-84)

[Computational learning theory](https://en.wikipedia.org/wiki/Computational_learning_theory) can assess learners by [computational complexity](https://en.wikipedia.org/wiki/Computational_complexity), by [sample complexity](https://en.wikipedia.org/wiki/Sample_complexity) (how much data is required), or by other notions of [optimization](https://en.wikipedia.org/wiki/Optimization_theory).[[72\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEJordanMitchell2015-85)

> 机器学习（ML）是人工智能研究领域成立以来的一个基本概念，[[l]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-79)是对通过经验自动改进的计算机算法的研究。[[m]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-81)
>
> [Unsupervised learning](https://en.wikipedia.org/wiki/Unsupervised_learning)在输入流中寻找模式。[监督学习](https://en.wikipedia.org/wiki/Supervised_learning)需要人类首先对输入的数据进行标记，主要有两种类型。[分类](https://en.wikipedia.org/wiki/Statistical_classification)和数字[回归](https://en.wikipedia.org/wiki/Regression_analysis)。分类是用来确定某样东西属于哪一类--程序从几个类别中看到一些例子，并将学习对新的输入进行分类。回归是试图产生一个描述输入和输出之间关系的函数，并预测随着输入的变化输出应该如何变化。分类器和回归学习器都可以被看作是 "函数近似器"，试图学习一个未知的（可能是隐含的）函数；例如，垃圾邮件分类器可以被看作是学习一个函数，将电子邮件的文本映射到两个类别之一，"垃圾邮件 "或 "非垃圾邮件"。[[69]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-82) 在[强化学习](https://en.wikipedia.org/wiki/Reinforcement_learning)中，工具对好的反应给予奖励，对坏的反应给予惩罚。工具对其反应进行分类，以形成在其问题空间中的操作策略。[[70]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-83) [转移学习](https://en.wikipedia.org/wiki/Transfer_learning)是指从一个问题中获得的知识被应用于一个新的问题。[[71]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEThe_Economist2016-84)
>
> [计算学习理论](https://en.wikipedia.org/wiki/Computational_learning_theory)可以通过[计算复杂性](https://en.wikipedia.org/wiki/Computational_complexity)、[样本复杂性](https://en.wikipedia.org/wiki/Sample_complexity)（需要多少数据）或其他[优化](https://en.wikipedia.org/wiki/Optimization_theory)的概念来评估学习者。

### Natural language processing

*Main article:* [Natural language processing](https://en.wikipedia.org/wiki/Natural_language_processing)

Natural language processing (NLP)[[73\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-86) allows machines to read and [understand](https://en.wikipedia.org/wiki/Natural-language_understanding) human language. A sufficiently powerful natural language processing system would enable [natural-language user interfaces](https://en.wikipedia.org/wiki/Natural-language_user_interface) and the acquisition of knowledge directly from human-written sources, such as newswire texts. Some straightforward applications of NLP include [information retrieval](https://en.wikipedia.org/wiki/Information_retrieval), [question answering](https://en.wikipedia.org/wiki/Question_answering) and [machine translation](https://en.wikipedia.org/wiki/Machine_translation).[[74\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-87)

[Symbolic AI](https://en.wikipedia.org/wiki/Symbolic_AI) used formal [syntax](https://en.wikipedia.org/wiki/Syntax) to translate the [deep structure](https://en.wikipedia.org/wiki/Deep_structure) of sentences into [logic](https://en.wikipedia.org/wiki/Logic). This failed to produce useful applications, due to the [intractability](https://en.wikipedia.org/wiki/Intractability_(complexity)) of logic[[47\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Intractability-58) and the breadth of commonsense knowledge.[[56\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Breadth_of_commonsense_knowledge-67) Modern statistical techniques include co-occurrence frequencies (how often one word appears near another), "Keyword spotting" (searching for a particular word to retrieve information), [transformer](https://en.wikipedia.org/wiki/Transformer_(machine_learning_model))-based [deep learning](https://en.wikipedia.org/wiki/Deep_learning) (which finds patterns in text), and others.[[75\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-88) They have achieved acceptable accuracy at the page or paragraph level, and, by 2019, could generate coherent text.[[76\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEVincent2019-89)

> 自然语言处理（NLP）[[73]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-86)使机器能够阅读和[理解](https://en.wikipedia.org/wiki/Natural-language_understanding)人类语言。一个足够强大的自然语言处理系统可以实现[自然语言用户界面](https://en.wikipedia.org/wiki/Natural-language_user_interface)和直接从人类书写的来源（如新闻网文本）获取知识。NLP的一些直接应用包括[信息检索](https://en.wikipedia.org/wiki/Information_retrieval)、[问题回答](https://en.wikipedia.org/wiki/Question_answering)和[机器翻译](https://en.wikipedia.org/wiki/Machine_translation)。[[74]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-87)
>
> [符号人工智能](https://en.wikipedia.org/wiki/Symbolic_AI)使用正式的[语法](https://en.wikipedia.org/wiki/Syntax)将句子的[深层结构](https://en.wikipedia.org/wiki/Deep_structure)翻译成[逻辑](https://en.wikipedia.org/wiki/Logic)。由于逻辑[[47]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Intractability-58)的[不可控性](https://en.wikipedia.org/wiki/Intractability_(复杂性))和常识性知识的广泛性，这未能产生有用的应用。[[56]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Breadth_of_commonsense_knowledge-67) 现代统计技术包括共现频率（一个词在另一个词附近出现的频率）、"关键词发现"（搜索一个特定的词来检索信息）、基于[转化器](https://en.wikipedia.org/wiki/Transformer_(machine_learning_model))的[深度学习](https://en.wikipedia.org/wiki/Deep_learning)（在文本中寻找模式），以及其他。[[75\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-88) 它们在页面或段落层面已经达到了可接受的准确性，到2019年，可以生成连贯的文本。

### Perception

*Main articles:* [Machine perception](https://en.wikipedia.org/wiki/Machine_perception)*,* [Computer vision](https://en.wikipedia.org/wiki/Computer_vision)*, and* [Speech recognition](https://en.wikipedia.org/wiki/Speech_recognition)

Machine perception[[77\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-90) is the ability to use input from sensors (such as cameras, microphones, wireless signals, and active [lidar](https://en.wikipedia.org/wiki/Lidar), sonar, radar, and [tactile sensors](https://en.wikipedia.org/wiki/Tactile_sensor)) to deduce aspects of the world. Applications include [speech recognition](https://en.wikipedia.org/wiki/Speech_recognition),[[78\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-91) [facial recognition](https://en.wikipedia.org/wiki/Facial_recognition_system), and [object recognition](https://en.wikipedia.org/wiki/Object_recognition).[[79\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-92) Computer vision is the ability to analyze visual input.[[80\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-93)

> 机器感知[[77\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-90)是利用来自传感器（如照相机、麦克风、无线信号以及主动式[激光雷达](https://en.wikipedia.org/wiki/Lidar)、声纳、雷达和[触觉传感器](https://en.wikipedia.org/wiki/Tactile_sensor)）的输入来推断世界各个方面的能力。应用包括[语音识别](https://en.wikipedia.org/wiki/Speech_recognition)、[[78\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-91)[面部识别](https://en.wikipedia.org/wiki/Facial_recognition_system)和[物体识别](https://en.wikipedia.org/wiki/Object_recognition)。[[79\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-92) 计算机视觉是分析视觉输入的能力。

### Motion and manipulation

Main article: [Robotics](https://en.wikipedia.org/wiki/Robotics)

AI is heavily used in robotics.[[81\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-94) [Localization](https://en.wikipedia.org/wiki/Robot_localization) is how a robot knows its location and [maps](https://en.wikipedia.org/wiki/Robotic_mapping) its environment. When given a small, static, and visible environment, this is easy; however, dynamic environments, such as (in [endoscopy](https://en.wikipedia.org/wiki/Endoscopy)) the interior of a patient's breathing body, pose a greater challenge.[[82\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-95)

[Motion planning](https://en.wikipedia.org/wiki/Motion_planning) is the process of breaking down a movement task into "primitives" such as individual joint movements. Such movement often involves compliant motion, a process where movement requires maintaining physical contact with an object. Robots can learn from experience how to move efficiently despite the presence of friction and gear slippage.[[83\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-96)

> 人工智能在机器人技术中得到了大量的应用。[[81]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-94)[定位](https://en.wikipedia.org/wiki/Robot_localization)是机器人如何知道自己的位置并[绘制](https://en.wikipedia.org/wiki/Robotic_mapping)其环境。当给定一个小的、静态的、可见的环境时，这很容易；然而，动态的环境，如（在[内窥镜](https://en.wikipedia.org/wiki/Endoscopy)中）病人呼吸的身体内部，会带来更大的挑战。[[82]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-95)
>
> [运动规划](https://en.wikipedia.org/wiki/Motion_planning)是将运动任务分解成 "基元 "的过程，如单个关节运动。这种运动往往涉及顺应性运动，在这个过程中，运动需要与物体保持物理接触。机器人可以从经验中学习如何在存在摩擦和齿轮打滑的情况下有效地运动。

### Social intelligence

Main article: [Affective computing](https://en.wikipedia.org/wiki/Affective_computing)

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b8/Kismet_robot_at_MIT_Museum.jpg/220px-Kismet_robot_at_MIT_Museum.jpg)](https://en.wikipedia.org/wiki/File:Kismet_robot_at_MIT_Museum.jpg)

[Kismet](https://en.wikipedia.org/wiki/Kismet_(robot)), a robot with rudimentary social skills[[84\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEMIT_AIL2014-97)

Affective computing is an interdisciplinary umbrella that comprises systems that recognize, interpret, process or simulate human [feeling, emotion and mood](https://en.wikipedia.org/wiki/Affect_(psychology)).[[85\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-98) For example, some [virtual assistants](https://en.wikipedia.org/wiki/Virtual_assistant) are programmed to speak conversationally or even to banter humorously; it makes them appear more sensitive to the emotional dynamics of human interaction, or to otherwise facilitate [human–computer interaction](https://en.wikipedia.org/wiki/Human–computer_interaction). However, this tends to give naïve users an unrealistic conception of how intelligent existing computer agents actually are.[[86\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEWaddell2018-99) Moderate successes related to affective computing include textual [sentiment analysis](https://en.wikipedia.org/wiki/Sentiment_analysis) and, more recently, [multimodal sentiment analysis](https://en.wikipedia.org/wiki/Multimodal_sentiment_analysis)), wherein AI classifies the affects displayed by a videotaped subject.[[87\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEPoriaCambriaBajpaiHussain2017-100)

> 情感计算是一个跨学科的总括，包括识别、解释、处理或模拟人类[感觉、情感和情绪](https://en.wikipedia.org/wiki/Affect_(心理学))的系统。例如，一些[虚拟助手](https://en.wikipedia.org/wiki/Virtual_assistant)被编程为谈话式，甚至是幽默地戏谑；这使它们看起来对人类互动的情感动态更加敏感，或者以其他方式促进[人机互动](https://en.wikipedia.org/wiki/Human-computer_interaction)。然而，这往往会让天真的用户对现有计算机代理的实际智能程度产生不切实际的概念。[[86]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEWaddell2018-99) 与情感计算相关的适度成功包括文本[情感分析](https://en.wikipedia.org/wiki/Sentiment_analysis)和最近的[多模态情感分析](https://en.wikipedia.org/wiki/Multimodal_sentiment_analysis))，其中人工智能对录像对象所显示的情感进行分类。[[87]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEPoriaCambriaBajpaiHussain2017-100)

### General intelligenc

Main article: [Artificial general intelligence](https://en.wikipedia.org/wiki/Artificial_general_intelligence)

A machine with general intelligence can solve a wide variety of problems with breadth and versatility similar to human intelligence. There are several competing ideas about how to develop artificial general intelligence. [Hans Moravec](https://en.wikipedia.org/wiki/Hans_Moravec) and [Marvin Minsky](https://en.wikipedia.org/wiki/Marvin_Minsky) argue that work in different individual domains can be incorporated into an advanced [multi-agent system](https://en.wikipedia.org/wiki/Multi-agent_system) or [cognitive architecture](https://en.wikipedia.org/wiki/Cognitive_architecture) with general intelligence.[[88\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-101) [Pedro Domingos](https://en.wikipedia.org/wiki/Pedro_Domingos) hopes that there is a conceptually straightforward, but mathematically difficult, "[master algorithm](https://en.wikipedia.org/wiki/The_Master_Algorithm)" that could lead to AGI.[[89\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTEDomingos2015Chpt._9-102) Others believe that [anthropomorphic](https://en.wikipedia.org/wiki/Anthropomorphism) features like an [artificial brain](https://en.wikipedia.org/wiki/Artificial_brain)[[90\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-103) or simulated [child development](https://en.wikipedia.org/wiki/Developmental_robotics)[[n\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-104) will someday reach a critical point where general intelligence [emerges](https://en.wikipedia.org/wiki/Emergence).

> 具有通用智能的机器可以解决各种各样的问题，其广度和通用性与人类智能相似。关于如何发展人工通用智能，有几个相互竞争的观点。[Hans Moravec](https://en.wikipedia.org/wiki/Hans_Moravec)和[Marvin Minsky](https://en.wikipedia.org/wiki/Marvin_Minsky)认为，不同个体领域的工作可以被纳入具有通用智能的高级[多工具系统](https://en.wikipedia.org/wiki/Multi-agent_system)或[认知架构](https://en.wikipedia.org/wiki/Cognitive_architecture)。[[88\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-101) [Pedro Domingos](https://en.wikipedia.org/wiki/Pedro_Domingos)希望有一种概念上简单但数学上困难的"[主算法](https://en.wikipedia.org/wiki/The_Master_Algorithm) "，可以导致AGI。其他人认为，像[人工大脑](https://en.wikipedia.org/wiki/Artificial_brain)[[90\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-103)或模拟[儿童发展](https://en.wikipedia.org/wiki/Developmental_robotics)[[n\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-104)这样的[拟人化](https://en.wikipedia.org/wiki/Anthropomorphism)特征有朝一日会达到一个临界点，通用智能[出现](https://en.wikipedia.org/wiki/Emergence)。

## Tools

### Search and optimization

Main articles: [Search algorithm](https://en.wikipedia.org/wiki/Search_algorithm), [Mathematical optimization](https://en.wikipedia.org/wiki/Mathematical_optimization), and [Evolutionary computation](https://en.wikipedia.org/wiki/Evolutionary_computation)

Many problems in AI can be solved theoretically by intelligently searching through many possible solutions:[[91\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-105) [Reasoning](https://en.wikipedia.org/wiki/Applications_of_artificial_intelligence#Deduction,_reasoning,_problem_solving) can be reduced to performing a search. For example, logical proof can be viewed as searching for a path that leads from [premises](https://en.wikipedia.org/wiki/Premise) to [conclusions](https://en.wikipedia.org/wiki/Logical_consequence), where each step is the application of an [inference rule](https://en.wikipedia.org/wiki/Inference_rule).[[92\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Logic_as_search-106) [Planning](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling) algorithms search through trees of goals and subgoals, attempting to find a path to a target goal, a process called [means-ends analysis](https://en.wikipedia.org/wiki/Means-ends_analysis).[[93\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Planning_as_search-107) [Robotics](https://en.wikipedia.org/wiki/Robotics) algorithms for moving limbs and grasping objects use [local searches](https://en.wikipedia.org/wiki/Local_search_(optimization)) in [configuration space](https://en.wikipedia.org/wiki/Configuration_space_(physics)).[[94\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Configuration_space-108)

Simple exhaustive searches[[95\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Uninformed_search-109) are rarely sufficient for most real-world problems: the [search space](https://en.wikipedia.org/wiki/Search_algorithm) (the number of places to search) quickly grows to [astronomical numbers](https://en.wikipedia.org/wiki/Astronomically_large). The result is a search that is [too slow](https://en.wikipedia.org/wiki/Computation_time) or never completes. The solution, for many problems, is to use "[heuristics](https://en.wikipedia.org/wiki/Heuristics)" or "rules of thumb" that prioritize choices in favor of those more likely to reach a goal and to do so in a shorter number of steps. In some search methodologies, heuristics can also serve to eliminate some choices unlikely to lead to a goal (called "[pruning](https://en.wikipedia.org/wiki/Pruning_(algorithm)) the [search tree](https://en.wikipedia.org/wiki/Search_tree)"). [Heuristics](https://en.wikipedia.org/wiki/Heuristics) supply the program with a "best guess" for the path on which the solution lies.[[96\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Informed_search-110) Heuristics limit the search for solutions into a smaller sample size.[[97\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTETecuci2012-111)

> 人工智能中的许多问题在理论上可以通过智能地搜索许多可能的解决方案来解决：[[91]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-105) [推理](https://en.wikipedia.org/wiki/Applications_of_artificial_intelligence#Deduction,_reasoning,_problem_solving)可以简化为执行搜索。例如，逻辑证明可以被看作是寻找一条从[前提](https://en.wikipedia.org/wiki/Premise)到[结论](https://en.wikipedia.org/wiki/Logical_consequence)的路径，其中每一步都是[推理规则](https://en.wikipedia.org/wiki/Inference_rule)的应用。[[92]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Logic_as_search-106)[规划](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling)算法通过目标和子目标的树进行搜索，试图找到一条通往目标的路径，这个过程称为[手段-结果分析](https://en。 wikipedia.org/wiki/Means-ends_analysis）。[[93\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Planning_as_search-107) [机器人](https://en.wikipedia.org/wiki/Robotics) 移动肢体和抓取物体的算法在[配置空间](https://en.wikipedia.org/wiki/Configuration_space_(物理学))中使用[局部搜索](https://en.wikipedia.org/wiki/Local_search_(优化))。
>
> 简单的穷举搜索[[95]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Uninformed_search-109)很少能满足大多数现实世界的问题：[搜索空间](https://en.wikipedia.org/wiki/Search_algorithm)（要搜索的地方的数量）迅速增长到[天文数字](https://en.wikipedia.org/wiki/Astronomically_large)。其结果是搜索[太慢](https://en.wikipedia.org/wiki/Computation_time)或永远无法完成。对于许多问题，解决方案是使用"[启发式方法](https://en.wikipedia.org/wiki/Heuristics) "或 "经验法则"，优先考虑那些更有可能达到目标的选择，并以更短的步骤完成。在一些搜索方法中，启发式方法也可以用来消除一些不太可能达到目标的选择（称为"[剪枝](https://en.wikipedia.org/wiki/Pruning_(algorithm))[搜索树](https://en.wikipedia.org/wiki/Search_tree)"）。Heuristics为程序提供解决方案所在路径的 "最佳猜测"。[[96/]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Informed_search-110)启发式方法将解决方案的搜索限制在较小的样本量中。[[97/]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-FOOTNOTETecuci2012-111)

### Logic

[Logic](https://en.wikipedia.org/wiki/Logic)[[101\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Logic-115) is used for knowledge representation and problem-solving, but it can be applied to other problems as well. For example, the [satplan](https://en.wikipedia.org/wiki/Satplan) algorithm uses logic for [planning](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling)[[102\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Satplan-116) and [inductive logic programming](https://en.wikipedia.org/wiki/Inductive_logic_programming) is a method for [learning](https://en.wikipedia.org/wiki/Machine_learning).[[103\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Symbolic_learning_techniques-117)

Several different forms of logic are used in AI research. [Propositional logic](https://en.wikipedia.org/wiki/Propositional_logic)[[104\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Propositional_logic-118) involves [truth functions](https://en.wikipedia.org/wiki/Truth_function) such as "or" and "not". [First-order logic](https://en.wikipedia.org/wiki/First-order_logic)[[105\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-First-order_logic-119) adds [quantifiers](https://en.wikipedia.org/wiki/Quantifier_(logic)) and [predicates](https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)) and can express facts about objects, their properties, and their relations with each other. [Fuzzy logic](https://en.wikipedia.org/wiki/Fuzzy_logic) assigns a "degree of truth" (between 0 and 1) to vague statements such as "Alice is old" (or rich, or tall, or hungry), that are too linguistically imprecise to be completely true or false.[[106\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Fuzzy_logic-120) [Default logics](https://en.wikipedia.org/wiki/Default_logic), [non-monotonic logics](https://en.wikipedia.org/wiki/Non-monotonic_logic) and [circumscription](https://en.wikipedia.org/wiki/Circumscription_(logic)) are forms of logic designed to help with default reasoning and the [qualification problem](https://en.wikipedia.org/wiki/Qualification_problem).[[55\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Default_reasoning_and_non-monotonic_logic-66) Several extensions of logic have been designed to handle specific domains of [knowledge](https://en.wikipedia.org/wiki/Knowledge_representation), such as [description logics](https://en.wikipedia.org/wiki/Description_logic);[[51\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_categories_and_relations-62) [situation calculus](https://en.wikipedia.org/wiki/Situation_calculus), [event calculus](https://en.wikipedia.org/wiki/Event_calculus) and [fluent calculus](https://en.wikipedia.org/wiki/Fluent_calculus) (for representing events and time);[[52\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_time-63) [causal calculus](https://en.wikipedia.org/wiki/Causality#Causal_calculus);[[53\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_causation-64) [belief calculus (belief revision)](https://en.wikipedia.org/wiki/Belief_revision); and [modal logics](https://en.wikipedia.org/wiki/Modal_logic).[[54\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Representing_knowledge_about_knowledge-65) Logics to model contradictory or inconsistent statements arising in multi-agent systems have also been designed, such as [paraconsistent logics](https://en.wikipedia.org/wiki/Paraconsistent_logic).[[107\]](https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-AbeNakamatsu-121)





---

# Machine learning

**Machine learning** (**ML**) is a field of inquiry devoted to understanding and building methods that 'learn', that is, methods that leverage data to improve performance on some set of tasks.[[1\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-1) It is seen as a part of [artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence). Machine learning algorithms build a model based on sample data, known as [training data](https://en.wikipedia.org/wiki/Training_data), in order to make predictions or decisions without being explicitly programmed to do so.[[2\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-2) Machine learning algorithms are used in a wide variety of applications, such as in medicine, [email filtering](https://en.wikipedia.org/wiki/Email_filtering), [speech recognition](https://en.wikipedia.org/wiki/Speech_recognition), and [computer vision](https://en.wikipedia.org/wiki/Computer_vision), where it is difficult or unfeasible to develop conventional algorithms to perform the needed tasks.[[3\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-tvt-3)

A subset of machine learning is closely related to [computational statistics](https://en.wikipedia.org/wiki/Computational_statistics), which focuses on making predictions using computers, but not all machine learning is statistical learning. The study of [mathematical optimization](https://en.wikipedia.org/wiki/Mathematical_optimization) delivers methods, theory and application domains to the field of machine learning. [Data mining](https://en.wikipedia.org/wiki/Data_mining) is a related field of study, focusing on [exploratory data analysis](https://en.wikipedia.org/wiki/Exploratory_data_analysis) through [unsupervised learning](https://en.wikipedia.org/wiki/Unsupervised_learning).[[5\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-5)[[6\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-6) Some implementations of machine learning use data and [neural networks](https://en.wikipedia.org/wiki/Neural_networks) in a way that mimics the working of a biological brain.[[7\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-7)[[8\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-8) In its application across business problems, machine learning is also referred to as [predictive analytics](https://en.wikipedia.org/wiki/Predictive_analytics).

> **机器学习**（**ML**）是一个致力于理解和建立 "学习"方法的研究领域，也就是说，利用数据来提高某些任务的性能。[[1]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-1)它被视为[人工智能](https://en.wikipedia.org/wiki/Artificial_intelligence)的一部分。机器学习算法基于样本数据（称为[训练数据](https://en.wikipedia.org/wiki/Training_data)）建立模型，以便在没有明确编程的情况下做出预测或决定。[[2\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-2)机器学习算法被广泛用于各种应用，如医学、[电子邮件过滤](https://en.wikipedia.org/wiki/Email_filtering)、[语音识别](https://en.wikipedia.org/wiki/Speech_recognition)和[计算机视觉](https://en.wikipedia.org/wiki/Computer_vision)，在这些应用中，开发传统算法来执行所需的任务是困难或不可行的。[[3\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-tvt-3)
>
> 机器学习的一个子集与[计算统计学](https://en.wikipedia.org/wiki/Computational_statistics)密切相关，它侧重于使用计算机进行预测，但并非所有的机器学习都是统计学习。[数学优化](https://en.wikipedia.org/wiki/Mathematical_optimization)的研究为机器学习领域提供了方法、理论和应用的领域。[数据挖掘](https://en.wikipedia.org/wiki/Data_mining)是一个相关的研究领域，侧重于通过[无监督学习](https://en.wikipedia.org/wiki/Unsupervised_learning)进行[探索性数据分析](https://en.wikipedia.org/wiki/Exploratory_data_analysis)。[[5\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-5)[[6\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-6)机器学习的一些实现使用数据和[神经网络](https://en.wikipedia.org/wiki/Neural_networks)的方式来模仿生物大脑的工作。[[7\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-7)[[8\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-8) 在商业问题的应用中，机器学习也被称为[预测分析](https://en.wikipedia.org/wiki/Predictive_analytics)。

## Overview

Learning algorithms work on the basis that strategies, algorithms, and inferences that worked well in the past are likely to continue working well in the future. These inferences can be obvious, such as "since the sun rose every morning for the last 10,000 days, it will probably rise tomorrow morning as well". They can be nuanced, such as "X% of [families](https://en.wikipedia.org/wiki/Family_(biology)) have geographically separate species with color variants, so there is a Y% chance that undiscovered [black swans](https://en.wikipedia.org/wiki/Black_swan_theory) exist".[[9\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-FOOTNOTEDomingos2015Chapter_6,_Chapter_7-9)

Machine learning programs can perform tasks without being explicitly programmed to do so. It involves computers learning from data provided so that they carry out certain tasks. For simple tasks assigned to computers, it is possible to program algorithms telling the machine how to execute all steps required to solve the problem at hand; on the computer's part, no learning is needed. For more advanced tasks, it can be challenging for a human to manually create the needed algorithms. In practice, it can turn out to be more effective to help the machine develop its own algorithm, rather than having human programmers specify every needed step.[[10\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Alpaydin2020-10)

The discipline of machine learning employs various approaches to teach computers to accomplish tasks where no fully satisfactory algorithm is available. In cases where vast numbers of potential answers exist, one approach is to label some of the correct answers as valid. This can then be used as training data for the computer to improve the algorithm(s) it uses to determine correct answers. For example, to train a system for the task of digital character recognition, the [MNIST](https://en.wikipedia.org/wiki/MNIST_database) dataset of handwritten digits has often been used.[[10\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Alpaydin2020-10)

> 学习算法的工作基础是，过去行之有效的策略、算法和推论有可能在未来继续行之有效。这些推论可以是显而易见的，比如 "既然过去一万天里太阳每天早上都会升起，那么它明天早上也可能会升起"。它们可以是细微的，例如 "X%的[科](https://en.wikipedia.org/wiki/Family_(biology))有地理上独立的物种，有颜色变异，所以有Y%的机会存在未发现的[黑天鹅](https://en.wikipedia.org/wiki/Black_swan_theory)"。[[9\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-FOOTNOTEDomingos2015Chapter_6,_Chapter_7-9)
>
> 机器学习程序可以在不被明确编程的情况下执行任务。它涉及到计算机从提供的数据中学习，从而执行某些任务。对于分配给计算机的简单任务，有可能通过编程告诉机器如何执行解决手头问题所需的所有步骤；在计算机方面，不需要学习。对于更高级的任务，由人类手动创建所需的算法可能是一个挑战。在实践中，帮助机器开发自己的算法，而不是让人类程序员指定每一个需要的步骤，可能会变得更加有效。[[10]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Alpaydin2020-10)
>
> 机器学习这门学科采用了各种方法来教计算机完成没有完全令人满意的算法的任务。在存在大量潜在答案的情况下，一种方法是将一些正确的答案标记为有效。然后，这可以作为计算机的训练数据，以改进它用来确定正确答案的算法。例如，为了训练数字字符识别任务的系统，经常使用[MNIST](https://en.wikipedia.org/wiki/MNIST_database)的手写数字数据集。[10\]

## History and relationship to other fields

The term *machine learning* was coined in 1959 by [Arthur Samuel](https://en.wikipedia.org/wiki/Arthur_Samuel), an [IBM](https://en.wikipedia.org/wiki/IBM) employee and pioneer in the field of [computer gaming](https://en.wikipedia.org/wiki/Computer_gaming) and [artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence).[[11\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Samuel-11)[[12\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-12) Also the synonym *self-teaching computers* were used in this time period.[[13\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-cyberthreat-13)[[14\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-14)

By the early 1960s an experimental "learning machine" with [punched tape](https://en.wikipedia.org/wiki/Punched_tape) memory, called Cybertron, had been developed by [Raytheon Company](https://en.wikipedia.org/wiki/Raytheon_Company) to analyze sonar signals, electrocardiograms and speech patterns using rudimentary [reinforcement learning](https://en.wikipedia.org/wiki/Reinforcement_learning). It was repetitively "trained" by a human operator/teacher to recognize patterns and equipped with a "[goof](https://en.wikipedia.org/wiki/Goof)" button to cause it to re-evaluate incorrect decisions.[[15\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-15) A representative book on research into machine learning during the 1960s was Nilsson's book on Learning Machines, dealing mostly with machine learning for pattern classification.[[16\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-16) Interest related to pattern recognition continued into the 1970s, as described by Duda and Hart in 1973.[[17\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-17) In 1981 a report was given on using teaching strategies so that a [neural network](https://en.wikipedia.org/wiki/Neural_network) learns to recognize 40 characters (26 letters, 10 digits, and 4 special symbols) from a computer terminal.[[18\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-18)

[Tom M. Mitchell](https://en.wikipedia.org/wiki/Tom_M._Mitchell) provided a widely quoted, more formal definition of the algorithms studied in the machine learning field: "A computer program is said to learn from experience *E* with respect to some class of tasks *T* and performance measure *P* if its performance at tasks in *T*, as measured by *P*, improves with experience *E*."[[19\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Mitchell-1997-19) This definition of the tasks in which machine learning is concerned offers a fundamentally [operational definition](https://en.wikipedia.org/wiki/Operational_definition) rather than defining the field in cognitive terms. This follows [Alan Turing](https://en.wikipedia.org/wiki/Alan_Turing)'s proposal in his paper "[Computing Machinery and Intelligence](https://en.wikipedia.org/wiki/Computing_Machinery_and_Intelligence)", in which the question "Can machines think?" is replaced with the question "Can machines do what we (as thinking entities) can do?".[[20\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-20)

Modern day machine learning has two objectives, one is to classify data based on models which have been developed, the other purpose is to make predictions for future outcomes based on these models. A hypothetical algorithm specific to classifying data may use computer vision of moles coupled with supervised learning in order to train it to classify the cancerous moles. A machine learning algorithm for stock trading may inform the trader of future potential predictions.[[21\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-21)

> 术语*机器学习*是由[IBM](https://en.wikipedia.org/wiki/Arthur_Samuel)员工、[计算机游戏](https://en.wikipedia.org/wiki/Computer_gaming)和[人工智能](https://en.wikipedia.org/wiki/Artificial_intelligence)领域的先驱阿瑟-塞缪尔在1959年提出的。[[11\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Samuel-11)[[12\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-12)在这个时期还使用了*自学计算机*的同义词。
>
> 到20世纪60年代初，[雷神公司](https://en.wikipedia.org/wiki/Raytheon_Company)开发了一种带有[打孔磁带](https://en.wikipedia.org/wiki/Punched_tape)存储器的实验性 "学习机"，名为赛博坦，可以使用初级的[强化学习](https://en.wikipedia.org/wiki/Reinforcement_learning)来分析声纳信号、心电图和语音模式。它被人类操作员/教师反复 "训练 "以识别模式，并配备了一个"[goof](https://en.wikipedia.org/wiki/Goof) "按钮，使其重新评估不正确的决定。[[15]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-15) 20世纪60年代机器学习研究的代表性书籍是尼尔森的《学习机器》，主要涉及模式分类的机器学习。[[16]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-16)与模式识别相关的兴趣一直持续到20世纪70年代，正如Duda和Hart在1973年所描述的那样。[[17\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-17) 1981年，一份关于使用教学策略使[神经网络](https://en.wikipedia.org/wiki/Neural_network)学会识别计算机终端的40个字符（26个字母、10个数字和4个特殊符号）的报告。[[18\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-18)
>
> [Tom M. Mitchell](https://en.wikipedia.org/wiki/Tom_M._Mitchell)为机器学习领域研究的算法提供了一个被广泛引用的、更正式的定义。"如果一个计算机程序在*T*中的任务中的表现，正如*P*所衡量的那样，随着经验的增加，*E*得到了改善，那么我们就说它从经验中学习了*E*。"[[19]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Mitchell-1997-19)这个关于机器学习所涉及的任务的定义从根本上提供了一个[操作定义](https://en.wikipedia.org/wiki/Operational_definition)，而不是从认知的角度定义该领域。这遵循了[Alan Turing](https://en.wikipedia.org/wiki/Alan_Turing)在其论文"[计算机械与智能](https://en.wikipedia.org/wiki/Computing_Machinery_and_Intelligence) "中的提议，其中 "机器能思考吗？"的问题被替换为 "机器能做我们（作为思考实体）能做的事吗？"。[[20\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-20)
>
> 现代的机器学习有两个目标，一个是根据已经建立的模型对数据进行**分类**，另一个目的是根据这些模型对未来的结果进行**预测**。一个专门用于数据分类的假设算法可以使用计算机视觉的痣加上监督学习，以训练它对癌痣进行分类。一个用于股票交易的机器学习算法可以告知交易者未来的潜在预测。[[21/]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-21)
>

### Artificial intelligence

As a scientific endeavor, machine learning grew out of the quest for artificial intelligence. In the early days of AI as an [academic discipline](https://en.wikipedia.org/wiki/Discipline_(academia)), some researchers were interested in having machines learn from data. They attempted to approach the problem with various symbolic methods, as well as what was then termed "[neural networks](https://en.wikipedia.org/wiki/Neural_network)"; these were mostly [perceptrons](https://en.wikipedia.org/wiki/Perceptron) and [other models](https://en.wikipedia.org/wiki/ADALINE) that were later found to be reinventions of the [generalized linear models](https://en.wikipedia.org/wiki/Generalized_linear_model) of statistics.[[24\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-24) [Probabilistic reasoning](https://en.wikipedia.org/wiki/Probabilistic_reasoning) was also employed, especially in [automated medical diagnosis](https://en.wikipedia.org/wiki/Automated_medical_diagnosis).[[25\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-aima-25): 488 

However, an increasing emphasis on the [logical, knowledge-based approach](https://en.wikipedia.org/wiki/GOFAI) caused a rift between AI and machine learning. Probabilistic systems were plagued by theoretical and practical problems of data acquisition and representation.[[25\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-aima-25): 488  By 1980, [expert systems](https://en.wikipedia.org/wiki/Expert_system) had come to dominate AI, and statistics was out of favor.[[26\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-changing-26) Work on symbolic/knowledge-based learning did continue within AI, leading to [inductive logic programming](https://en.wikipedia.org/wiki/Inductive_logic_programming), but the more statistical line of research was now outside the field of AI proper, in [pattern recognition](https://en.wikipedia.org/wiki/Pattern_recognition) and [information retrieval](https://en.wikipedia.org/wiki/Information_retrieval).[[25\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-aima-25): 708–710, 755  Neural networks research had been abandoned by AI and [computer science](https://en.wikipedia.org/wiki/Computer_science) around the same time. This line, too, was continued outside the AI/CS field, as "[connectionism](https://en.wikipedia.org/wiki/Connectionism)", by researchers from other disciplines including [Hopfield](https://en.wikipedia.org/wiki/John_Hopfield), [Rumelhart](https://en.wikipedia.org/wiki/David_Rumelhart) and [Hinton](https://en.wikipedia.org/wiki/Geoff_Hinton). Their main success came in the mid-1980s with the reinvention of [backpropagation](https://en.wikipedia.org/wiki/Backpropagation).[[25\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-aima-25): 25 

Machine learning (ML), reorganized as a separate field, started to flourish in the 1990s. The field changed its goal from achieving artificial intelligence to tackling solvable problems of a practical nature. It shifted focus away from the [symbolic approaches](https://en.wikipedia.org/wiki/Symbolic_artificial_intelligence) it had inherited from AI, and toward methods and models borrowed from statistics, [fuzzy logic](https://en.wikipedia.org/wiki/Fuzzy_logic), and [probability theory](https://en.wikipedia.org/wiki/Probability_theory).[[26\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-changing-26)

The difference between ML and AI is frequently misunderstood. ML learns and predicts based on passive observations, whereas AI implies an agent interacting with the environment to learn and take actions that maximize its chance of successfully achieving its goals.[[27\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:3-27)

As of 2020, many sources continue to assert that ML remains a subfield of AI.[[28\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:4-28)[[29\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-islr-29)[[26\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-changing-26) Others have the view that not all ML is part of AI, but only an 'intelligent subset' of ML should be considered AI.[[4\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-bishop2006-4)[[30\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:5-30)[[31\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-alpaydin-31)

> 作为一项科学工作，机器学习是从对人工智能的追求中发展起来的。在人工智能作为一个[学术学科](https://en.wikipedia.org/wiki/Discipline_(academia))的早期，一些研究人员对让机器从数据中学习感兴趣。他们试图用各种符号方法以及当时被称为"[神经网络](https://en.wikipedia.org/wiki/Neural_network) "的方法来解决这个问题；这些方法主要是[感知器](https://en.wikipedia.org/wiki/Perceptron)和[其他模型](https://en.wikipedia.org/wiki/ADALINE)，后来发现它们是统计学中[广义线性模型](https://en.wikipedia.org/wiki/Generalized_linear_model)的再创造。[[24](https://en.wikipedia.org/wiki/Machine_learning#cite_note-24)[概率推理](https://en.wikipedia.org/wiki/Probabilistic_reasoning)也被采用，尤其在[自动医疗诊断](https://en.wikipedia.org/wiki/Automated_medical_diagnosis)中。 488 
>
> 然而，对[逻辑的、基于知识的方法](https://en.wikipedia.org/wiki/GOFAI)的日益强调造成了人工智能和机器学习之间的裂痕。概率系统被数据获取和表示的理论和实践问题所困扰。[[25]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-aima-25)。 488到了1980年，[专家系统](https://en.wikipedia.org/wiki/Expert_system)已经主导了人工智能，而统计学则不再受欢迎。在人工智能内部，关于符号/知识学习的工作确实在继续，导致了[归纳逻辑编程](https://en.wikipedia.org/wiki/Inductive_logic_programming)，但更多的统计学研究路线现在在人工智能领域之外，在[模式识别](https://en.wikipedia.org/wiki/Pattern_recognition)和[信息检索](https://en.wikipedia.org/wiki/Information_retrieval)。 708-710, 755 神经网络研究在同一时间被人工智能和[计算机科学](https://en.wikipedia.org/wiki/Computer_science)放弃了。这条路线也在人工智能/计算机科学领域之外被其他学科的研究人员，包括[Hopfield](https://en.wikipedia.org/wiki/John_Hopfield)、[Rumelhart](https://en.wikipedia.org/wiki/David_Rumelhart)和[Hinton](https://en.wikipedia.org/wiki/Geoff_Hinton)，作为"[连接主义](https://en.wikipedia.org/wiki/Connectionism) "继续下去。他们的主要成功出现在20世纪80年代中期，重新发明了[反向传播](https://en.wikipedia.org/wiki/Backpropagation)。[[25]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-aima-25)。 25 
>
> 机器学习（ML），作为一个独立的领域被重新组织，在20世纪90年代开始蓬勃发展。该领域改变了其目标，从实现人工智能到解决实际性质的可解决的问题。它将重点从它从人工智能继承的[符号方法](https://en.wikipedia.org/wiki/Symbolic_artificial_intelligence)转移到从统计学、[模糊逻辑](https://en.wikipedia.org/wiki/Fuzzy_logic)和[概率论](https://en.wikipedia.org/wiki/Probability_theory)借用的方法和模型。[[26]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-changing-26)
>
> ML和AI之间的区别经常被误解。ML基于被动的观察进行学习和预测，而人工智能则意味着代理人与环境互动，以学习和采取行动，使其成功实现其目标的机会最大化。[[27\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:3-27)
>
> 截至2020年，许多消息来源继续断言，ML仍然是人工智能的一个子领域。[[28\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:4-28)[[29\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-islr-29)[[26\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-changing-26)其他人认为，并非所有ML都是人工智能的一部分，但只有ML的 "智能子集 "应被视为人工智能。
>

### Date mining

Machine learning and [data mining](https://en.wikipedia.org/wiki/Data_mining) often employ the same methods and overlap significantly, but while machine learning focuses on prediction, based on *known* properties learned from the training data, [data mining](https://en.wikipedia.org/wiki/Data_mining) focuses on the [discovery](https://en.wikipedia.org/wiki/Discovery_(observation)) of (previously) *unknown* properties in the data (this is the analysis step of [knowledge discovery](https://en.wikipedia.org/wiki/Knowledge_discovery) in databases). Data mining uses many machine learning methods, but with different goals; on the other hand, machine learning also employs data mining methods as "unsupervised learning" or as a preprocessing step to improve learner accuracy. Much of the confusion between these two research communities (which do often have separate conferences and separate journals, [ECML PKDD](https://en.wikipedia.org/wiki/ECML_PKDD) being a major exception) comes from the basic assumptions they work with: in machine learning, performance is usually evaluated with respect to the ability to *reproduce known* knowledge, while in knowledge discovery and data mining (KDD) the key task is the discovery of previously *unknown* knowledge. Evaluated with respect to known knowledge, an uninformed (unsupervised) method will easily be outperformed by other supervised methods, while in a typical KDD task, supervised methods cannot be used due to the unavailability of training data.

> 机器学习和[数据挖掘](https://en.wikipedia.org/wiki/Data_mining)经常采用相同的方法，并且有很大的重叠，但机器学习侧重于预测，基于从训练数据中学习到的*已知属性，而[数据挖掘](https://en.wikipedia.org/wiki/Data_mining)则侧重于[发现](https://en.wikipedia.org/wiki/Discovery_(observation))数据中（以前）*未知的属性（这就是数据库中[知识发现](https://en.wikipedia.org/wiki/Knowledge_discovery)的分析步骤）。数据挖掘使用了许多机器学习方法，但目标不同；另一方面，机器学习也采用数据挖掘方法作为 "无监督学习 "或作为提高学习者准确性的预处理步骤。这两个研究团体（它们经常有独立的会议和独立的期刊，[ECML PKDD](https://en.wikipedia.org/wiki/ECML_PKDD)是一个主要的例外）之间的大部分混淆来自于它们工作的基本假设：在机器学习中，性能通常是以*产生已知*知识的能力来评估的，而在知识发现和数据挖掘（KDD）中，关键任务是发现以前*未知*的知识。就已知知识而言，一个无信息（无监督）的方法很容易被其他有监督的方法所超越，而在一个典型的KDD任务中，由于无法获得训练数据，有监督的方法无法使用。

### Optimization

Machine learning also has intimate ties to [optimization](https://en.wikipedia.org/wiki/Mathematical_optimization): many learning problems are formulated as minimization of some [loss function](https://en.wikipedia.org/wiki/Loss_function) on a training set of examples. Loss functions express the discrepancy between the predictions of the model being trained and the actual problem instances (for example, in classification, one wants to assign a label to instances, and models are trained to correctly predict the pre-assigned labels of a set of examples).[[32\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-32)

> 机器学习也与[优化](https://en.wikipedia.org/wiki/Mathematical_optimization)有着密切的联系：许多学习问题被表述为在训练的实例集上最小化一些[损失函数](https://en.wikipedia.org/wiki/Loss_function)。损失函数表示被训练的模型的预测和实际问题实例之间的差异（例如，在分类中，人们希望给实例分配一个标签，模型被训练成正确预测一组实例的预分配标签）。[[32]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-32)

### Generalization

The difference between optimization and machine learning arises from the goal of generalization: while optimization algorithms can minimize the loss on a training set, machine learning is concerned with minimizing the loss on unseen samples. Characterizing the generalization of various learning algorithms is an active topic of current research, especially for [deep learning](https://en.wikipedia.org/wiki/Deep_learning) algorithms.

> 优化和机器学习的区别来自于泛化的目标：优化算法可以最小化训练集上的损失，而机器学习关注的是最小化未见过的样本上的损失。表征各种学习算法的泛化是当前研究的一个活跃话题，特别是对于[深度学习](https://en.wikipedia.org/wiki/Deep_learning)算法。
>

### Statistics

Machine learning and [statistics](https://en.wikipedia.org/wiki/Statistics) are closely related fields in terms of methods, but distinct in their principal goal: statistics draws population [inferences](https://en.wikipedia.org/wiki/Statistical_inference) from a [sample](https://en.wikipedia.org/wiki/Sample_(statistics)), while machine learning finds generalizable predictive patterns.[[33\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-33) According to [Michael I. Jordan](https://en.wikipedia.org/wiki/Michael_I._Jordan), the ideas of machine learning, from methodological principles to theoretical tools, have had a long pre-history in statistics.[[34\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-mi_jordan_ama-34) He also suggested the term [data science](https://en.wikipedia.org/wiki/Data_science) as a placeholder to call the overall field.[[34\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-mi_jordan_ama-34)

[Leo Breiman](https://en.wikipedia.org/wiki/Leo_Breiman) distinguished two statistical modeling paradigms: data model and algorithmic model,[[28\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:4-28) wherein "algorithmic model" means more or less the machine learning algorithms like [Random forest](https://en.wikipedia.org/wiki/Random_forest).

Some statisticians have adopted methods from machine learning, leading to a combined field that they call *statistical learning*.[[29\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-islr-29)

> 机器学习和[统计学](https://en.wikipedia.org/wiki/Statistics)在方法上是密切相关的领域，但在主要目标上是不同的：统计学从[样本](https://en.wikipedia.org/wiki/Sample_(statistics))中得出群体[推论](https://en.wikipedia.org/wiki/Statistical_inference)，而机器学习则找到可概括的预测模式。[[33\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-33) 根据[Michael I。Jordan](https://en.wikipedia.org/wiki/Michael_I._Jordan)认为，机器学习的思想，从方法论原则到理论工具，在统计学中都有很长的前史。[[34\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-mi_jordan_ama-34)他还建议用[数据科学](https://en.wikipedia.org/wiki/Data_science)这个词来称呼整个领域。[[34\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-mi_jordan_ama-34)
>
> [Leo Breiman](https://en.wikipedia.org/wiki/Leo_Breiman)区分了两种统计建模范式：数据模型和算法模型，[[28]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:4-28)其中 "算法模型 "或多或少意味着像[随机森林](https://en.wikipedia.org/wiki/Random_forest)这样的机器学习算法。
>
> 一些统计学家采用了机器学习的方法，形成了一个综合的领域，他们称之为*统计学习*。[[29]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-islr-29)
>

## Theory

A core objective of a learner is to generalize from its experience.[[4\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-bishop2006-4)[[30\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:5-30) Generalization in this context is the ability of a learning machine to perform accurately on new, unseen examples/tasks after having experienced a learning data set. The training examples come from some generally unknown probability distribution (considered representative of the space of occurrences) and the learner has to build a general model about this space that enables it to produce sufficiently accurate predictions in new cases.

The computational analysis of machine learning algorithms and their performance is a branch of [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science) known as [computational learning theory](https://en.wikipedia.org/wiki/Computational_learning_theory) via the [Probably Approximately Correct Learning](https://en.wikipedia.org/wiki/Probably_approximately_correct_learning) (PAC) model. Because training sets are finite and the future is uncertain, learning theory usually does not yield guarantees of the performance of algorithms. Instead, probabilistic bounds on the performance are quite common. The [bias–variance decomposition](https://en.wikipedia.org/wiki/Bias–variance_decomposition) is one way to quantify generalization [error](https://en.wikipedia.org/wiki/Errors_and_residuals).

For the best performance in the context of generalization, the complexity of the hypothesis should match the complexity of the function underlying the data. If the hypothesis is less complex than the function, then the model has under fitted the data. If the complexity of the model is increased in response, then the training error decreases. But if the hypothesis is too complex, then the model is subject to [overfitting](https://en.wikipedia.org/wiki/Overfitting) and generalization will be poorer.[[31\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-alpaydin-31)

In addition to performance bounds, learning theorists study the time complexity and feasibility of learning. In computational learning theory, a computation is considered feasible if it can be done in [polynomial time](https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time). There are two kinds of [time complexity](https://en.wikipedia.org/wiki/Time_complexity) results: Positive results show that a certain class of functions can be learned in polynomial time. Negative results show that certain classes cannot be learned in polynomial time.

> 学习者的一个核心目标是从它的经验中进行概括。[[4\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-bishop2006-4)[[30\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:5-30)这里的概括是指学习机在经历了一个学习数据集之后，对新的、未曾见过的例子/任务准确执行的能力。训练实例来自一些普遍未知的概率分布（被认为是发生空间的代表），学习者必须建立一个关于这个空间的一般模型，使其能够在新的情况下产生足够准确的预测。
>
> 对机器学习算法及其性能的计算分析是[理论计算机科学](https://en.wikipedia.org/wiki/Theoretical_computer_science)的一个分支，通过[大概正确的学习](https://en.wikipedia.org/wiki/Probably_approximately_correct_learning)(PAC)模型被称为[计算学习理论](https://en.wikipedia.org/wiki/Computational_learning_theory)。由于训练集是有限的，而且未来是不确定的，学习理论通常不能产生对算法性能的保证。相反，关于性能的概率界线是很常见的。[偏置-变异分解](https://en.wikipedia.org/wiki/Bias-variance_decomposition)是量化概括[误差](https://en.wikipedia.org/wiki/Errors_and_residuals)的一种方法。
>
> 对于泛化的最佳性能，假设的复杂性应该与数据基础函数的复杂性相匹配。如果假设的复杂程度低于函数的复杂程度，那么模型对数据的拟合不足。如果模型的复杂性相应地增加，那么训练误差就会减少。但如果假设太复杂，那么模型就会出现[过拟合](https://en.wikipedia.org/wiki/Overfitting)，泛化效果会更差。[[31]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-alpaydin-31)
>
> 除了性能界限之外，学习理论家们还研究学习的时间复杂性和可行性。在计算学习理论中，如果一个计算可以在[多项式时间](https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time)内完成，就被认为是可行的。有两种[时间复杂性](https://en.wikipedia.org/wiki/Time_complexity)的结果。正面结果表明，某类函数可以在多项式时间内学会。消极的结果表明，某些类别的函数不能在多项式时间内学会。

### Approaches

Machine learning approaches are traditionally divided into three broad categories, which correspond to learning paradigms, depending on the nature of the "signal" or "feedback" available to the learning system:

- [Supervised learning](https://en.wikipedia.org/wiki/Supervised_learning): The computer is presented with example inputs and their desired outputs, given by a "teacher", and the goal is to learn a general rule that [maps](https://en.wikipedia.org/wiki/Map_(mathematics)) inputs to outputs.
- [Unsupervised learning](https://en.wikipedia.org/wiki/Unsupervised_learning): No labels are given to the learning algorithm, leaving it on its own to find structure in its input. Unsupervised learning can be a goal in itself (discovering hidden patterns in data) or a means towards an end ([feature learning](https://en.wikipedia.org/wiki/Feature_learning)).
- [Reinforcement learning](https://en.wikipedia.org/wiki/Reinforcement_learning): A computer program interacts with a dynamic environment in which it must perform a certain goal (such as [driving a vehicle](https://en.wikipedia.org/wiki/Autonomous_car) or playing a game against an opponent). As it navigates its problem space, the program is provided feedback that's analogous to rewards, which it tries to maximize.[[4\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-bishop2006-4)

> 机器学习方法在传统上被分为三大类，它们与学习范式相对应，取决于学习系统可用的 "信号 "或 "反馈 "的性质。
>
> - [监督学习](https://en.wikipedia.org/wiki/Supervised_learning)。计算机收到由 "老师 "提供的输入和期望输出的例子，目标是学习一个[映射](https://en.wikipedia.org/wiki/Map_(mathematics))输入到输出的一般规则。
> - [无监督学习](https://en.wikipedia.org/wiki/Unsupervised_learning)。没有给学习算法任何标签，让它自己在输入中寻找结构。无监督学习本身可以是一个目标（发现数据中的隐藏模式），也可以是达到目的的一种手段（[特征学习](https://en.wikipedia.org/wiki/Feature_learning)）。
> - [强化学习](https://en.wikipedia.org/wiki/Reinforcement_learning)。一个计算机程序与一个动态环境互动，在这个环境中它必须完成某个目标（例如[驾驶车辆](https://en.wikipedia.org/wiki/Autonomous_car)或与对手进行游戏）。当它在问题空间中导航时，程序会得到类似于奖励的反馈，它试图使奖励最大化。[[4]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-bishop2006-4)
>

### Supervised learning

Supervised learning algorithms build a mathematical model of a set of data that contains both the inputs and the desired outputs.[[35\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-35) The data is known as [training data](https://en.wikipedia.org/wiki/Training_data), and consists of a set of training examples. Each training example has one or more inputs and the desired output, also known as a supervisory signal. In the mathematical model, each training example is represented by an [array](https://en.wikipedia.org/wiki/Array_data_structure) or vector, sometimes called a feature vector, and the training data is represented by a [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)). Through [iterative optimization](https://en.wikipedia.org/wiki/Mathematical_optimization#Computational_optimization_techniques) of an [objective function](https://en.wikipedia.org/wiki/Loss_function), supervised learning algorithms learn a function that can be used to predict the output associated with new inputs.[[36\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-36) An optimal function will allow the algorithm to correctly determine the output for inputs that were not a part of the training data. An algorithm that improves the accuracy of its outputs or predictions over time is said to have learned to perform that task.[[19\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Mitchell-1997-19)

Types of supervised-learning algorithms include [active learning](https://en.wikipedia.org/wiki/Active_learning_(machine_learning)), [classification](https://en.wikipedia.org/wiki/Statistical_classification) and [regression](https://en.wikipedia.org/wiki/Regression_analysis).[[27\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:3-27) Classification algorithms are used when the outputs are restricted to a limited set of values, and regression algorithms are used when the outputs may have any numerical value within a range. As an example, for a classification algorithm that filters emails, the input would be an incoming email, and the output would be the name of the folder in which to file the email.

[Similarity learning](https://en.wikipedia.org/wiki/Similarity_learning) is an area of supervised machine learning closely related to regression and classification, but the goal is to learn from examples using a similarity function that measures how similar or related two objects are. It has applications in [ranking](https://en.wikipedia.org/wiki/Ranking), [recommendation systems](https://en.wikipedia.org/wiki/Recommender_system), visual identity tracking, face verification, and speaker verification.

> 监督学习算法为一组数据建立数学模型，这组数据包含输入和期望输出。[[35]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-35)这些数据被称为[训练数据](https://en.wikipedia.org/wiki/Training_data)，由一组训练实例组成。每个训练实例都有一个或多个输入和期望输出，也被称为监督信号。在数学模型中，每个训练实例用一个[数组](https://en.wikipedia.org/wiki/Array_data_structure)或向量表示，有时也称为特征向量，而训练数据则用一个[矩阵](https://en.wikipedia.org/wiki/Matrix_(数学))表示。通过对[目标函数](https://en.wikipedia.org/wiki/Loss_function)的[迭代优化](https://en.wikipedia.org/wiki/Mathematical_optimization#Computational_optimization_techniques)，监督学习算法学会了一个可以用来预测与新输入相关的输出的函数。[[36]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-36)一个最佳函数将允许算法正确确定那些不属于训练数据的输入的输出。随着时间的推移，一个能提高其输出或预测准确性的算法被称为已经学会了执行该任务。[[19]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-Mitchell-1997-19)
>
> 监督学习算法的类型包括[主动学习](https://en.wikipedia.org/wiki/Active_learning_(machine_learning))、[分类](https://en.wikipedia.org/wiki/Statistical_classification)和[回归](https://en.wikipedia.org/wiki/Regression_analysis)。[[27]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-:3-27)分类算法用于输出被限制在一组有限的值中，而回归算法用于输出可以在一定范围内有任何数值。举例来说，对于一个过滤电子邮件的分类算法来说，输入是一封收到的电子邮件，而输出则是将该电子邮件归档的文件夹名称。
>
> [相似性学习](https://en.wikipedia.org/wiki/Similarity_learning)是监督式机器学习的一个领域，与回归和分类密切相关，但其目标是使用衡量两个对象的相似性或相关程度的相似性函数从实例中学习。它在[排名](https://en.wikipedia.org/wiki/Ranking)、[推荐系统](https://en.wikipedia.org/wiki/Recommender_system)、视觉身份追踪、人脸验证和说话人验证中都有应用。

## Unsupervised learning

Unsupervised learning algorithms take a set of data that contains only inputs, and find structure in the data, like grouping or clustering of data points. The algorithms, therefore, learn from test data that has not been labeled, classified or categorized. Instead of responding to feedback, unsupervised learning algorithms identify commonalities in the data and react based on the presence or absence of such commonalities in each new piece of data. A central application of unsupervised learning is in the field of [density estimation](https://en.wikipedia.org/wiki/Density_estimation) in [statistics](https://en.wikipedia.org/wiki/Statistics), such as finding the [probability density function](https://en.wikipedia.org/wiki/Probability_density_function).[[37\]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-JordanBishop2004-37) Though unsupervised learning encompasses other domains involving summarizing and explaining data features.

Cluster analysis is the assignment of a set of observations into subsets (called *clusters*) so that observations within the same cluster are similar according to one or more predesignated criteria, while observations drawn from different clusters are dissimilar. Different clustering techniques make different assumptions on the structure of the data, often defined by some *similarity metric* and evaluated, for example, by *internal compactness*, or the similarity between members of the same cluster, and *separation*, the difference between clusters. Other methods are based on *estimated density* and *graph connectivity*.

> 无监督学习算法采取一组只包含输入的数据，并在数据中寻找结构，如数据点的分组或聚类。因此，这些算法从未被标记、分类或归类的测试数据中学习。无监督学习算法不是对反馈作出反应，而是识别数据中的共性，并根据每个新数据中是否存在这种共性作出反应。无监督学习的一个核心应用是在[统计学](https://en.wikipedia.org/wiki/Statistics)中的[密度估计](https://en.wikipedia.org/wiki/Density_estimation)领域，如寻找[概率密度函数](https://en.wikipedia.org/wiki/Probability_density_function)。[[37]](https://en.wikipedia.org/wiki/Machine_learning#cite_note-JordanBishop2004-37)尽管无监督学习包含了涉及总结和解释数据特征的其他领域。
>
> 聚类分析是将一组观察值分配到子集（称为*聚类*）中，以便根据一个或多个预先指定的标准，同一聚类中的观察值是相似的，而来自不同聚类的观察值是不相似的。不同的聚类技术对数据的结构做了不同的假设，通常由一些*相似性指标*来定义，例如，通过*内部紧凑性*，或同一聚类成员之间的相似性，以及*分离*，聚类之间的差异来评估。其他方法是基于*估计的密度*和*图形连接*。
>



---

# Metasyntax

In [logic](https://en.wikipedia.org/wiki/Logic) and [computer science](https://en.wikipedia.org/wiki/Computer_science), a **metasyntax** describes the allowable structure and composition of phrases and sentences of a [metalanguage](https://en.wikipedia.org/wiki/Metalanguage), which is used to describe either a [natural language](https://en.wikipedia.org/wiki/Natural_language) or a computer [programming language](https://en.wikipedia.org/wiki/Programming_language).[[1\]](https://en.wikipedia.org/wiki/Metasyntax#cite_note-1) Some of the widely used formal metalanguages for computer languages are [Backus–Naur form](https://en.wikipedia.org/wiki/Backus–Naur_form) (BNF), [extended Backus–Naur form](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form) (EBNF), [Wirth syntax notation](https://en.wikipedia.org/wiki/Wirth_syntax_notation) (WSN), and [augmented Backus–Naur form](https://en.wikipedia.org/wiki/Augmented_Backus–Naur_form) (ABNF).

> 在[逻辑学](https://en.wikipedia.org/wiki/Logic)和[计算机科学](https://en.wikipedia.org/wiki/Computer_science)中，**元语法**描述了被用来描述[自然语言](https://en.wikipedia.org/wiki/Natural_language)或计算机[编程语言](https://en.wikipedia.org/wiki/Programming_language)的[元语言](https://en.wikipedia.org/wiki/Metalanguage)的可允许的短语和句子两者的结构和组成。一些广泛使用的计算机语言的形式元语言是[Backus-Naur形式](https://en.wikipedia.org/wiki/Backus-Naur_form)（BNF），[扩展的Backus-Naur形式](https://en.wikipedia.org/wiki/Extended_Backus-Naur_form)（EBNF），[Wirth syntax notation](https://en.wikipedia.org/wiki/Wirth_syntax_notation)（WSN），以及[增强的Backus-Naur形式](https://en.wikipedia.org/wiki/Augmented_Backus-Naur_form) （ABNF）。

These metalanguages have their own metasyntax each composed of [terminal symbols](https://en.wikipedia.org/wiki/Terminal_symbol), [nonterminal symbols](https://en.wikipedia.org/wiki/Nonterminal_symbol), and *metasymbols*. A terminal symbol, such as a word or a token, is a stand-alone structure in a language being defined. A nonterminal symbol represents a [syntactic](https://en.wikipedia.org/wiki/Syntactic) category, which defines one or more valid phrasal or sentence structure consisted of an n-element subset. Metasymbols provide syntactic information for denotational purposes in a given metasyntax. Terminals, nonterminals, and metasymbols do not apply across all metalanguages.

> 这些元语言有自己的元语法，每一种都由[终端符号](https://en.wikipedia.org/wiki/Terminal_symbol)、[非终端符号](https://en.wikipedia.org/wiki/Nonterminal_symbol)和*元符号*组成。一个终端符号，如一个词或一个标记，是被定义的语言中一个独立的结构。一个非终端符号代表一个[句法](https://en.wikipedia.org/wiki/Syntactic)类别，它定义了一个或多个由n个元素子集组成的有效短语或句子结构。元符号在特定的元语法中为指称目的提供句法信息。终端、非终端和元符号并不适用于所有元语言。

Typically, the metalanguage for token-level languages (formally called "[regular languages](https://en.wikipedia.org/wiki/Regular_language)") does not have nonterminals because nesting is not an issue in these regular languages. English, as a metalanguage for describing certain languages, does not contain metasymbols since all explanation could be done using English expression. There are only certain formal metalanguages used for describing recursive languages (formally called [context-free languages](https://en.wikipedia.org/wiki/Context-free_language)) that have terminals, nonterminals, and metasymbols in their metasyntax.

> 通常，标记级语言（正式名称为"[常规语言](https://en.wikipedia.org/wiki/Regular_language)"）的元语言没有非终端符，因为嵌套在这些常规语言中不是一个问题。英语，作为描述某些语言的元语言，不包含元符号，因为所有的解释都可以用英语表达。只有某些用于描述递归语言的正式元语言（正式称为[无语境语言](https://en.wikipedia.org/wiki/Context-free_language)）在其元语法中具有终端、非终端和元符号。

## Element of metesyntax

- Terminals: a stand-alone syntactic structure. Terminals could be denoted by double quoting the name of the terminals.

  e.g. `"else"`, `"if"`, `"then"`, `while`

- Nonterminals: a symbolic representation defining a set of allowable syntactic structures that is composed of a subset of elements. Nonterminals could be denoted by angle bracketing the name of the nonterminals.

  e.g. `<int>`, `<char>`, `<boolean>`

- Metasymbol: a symbolic representation denoting syntactic information.

  e.g. `:=`, `|`, `{}`, `()`, `[]`, `*`

> - 终端符：一个独立的句法结构。终端符可以通过双引号来表示终端符的名称。
>
>   例如：`"else"`, `"if"`, `"then"`, `"while"`。
>
> - 非终端符：一个符号表示法，定义了一组可允许的句法结构，由一个元素子集组成。非终结符可以用角括号表示非终结符的名称。
>
>   例如：`<int>`, `<char>`, `<boolean>`。
>
> - 元符号：表示句法信息的符号代表。
>
>   例如：`:=`, `|`, `{}`, `()`, `[]`, `*`。

## Method of phrase termination

- Juxtaposition: e.g. `A B`
- Alternation: e.g. `A|B`
- Repetition: e.g. `{A B}`
- Optional phrase: e.g. `[A B]`
- Grouping: e.g. `(A|B)`

> - 并列：如：`A B`
> - 备选（或）：如：`A|B`
> - 重复：例如：`{A B}`
> - 可选短语：如：`[A B]`
> - 分组：如：`(A|B)`

## Specific metasyntax conventions

### The standard convention

- '[Backus–Naur form](https://en.wikipedia.org/wiki/Backus–Naur_form)' denotes [nonterminal symbols](https://en.wikipedia.org/wiki/Nonterminal_symbol) by angle bracketing the name of the [syntactic category](https://en.wikipedia.org/wiki/Syntactic_category), while it denotes [terminal symbols](https://en.wikipedia.org/wiki/Terminal_symbol) by double quoting the terminal words. Terminals can never appear on the left-hand side of the metasymbol `::=` in a [derivation](https://en.wikipedia.org/wiki/Parse_tree) rule. The body of the definition on the right-hand side may be composed with several alternative forms with each alternative syntactic construct being separated by the metasymbol `|`. Each of these alternative construct may be either terminal or nonterminal.

> '[Backus-Naur形式](https://en.wikipedia.org/wiki/Backus-Naur_form)'通过角括号表示[非终端符号](https://en.wikipedia.org/wiki/Nonterminal_symbol)，而它通过双引号扩住终端词表示[终端符号](https://en.wikipedia.org/wiki/Terminal_symbol)。在[派生](https://en.wikipedia.org/wiki/Parse_tree)（语法分析树）规则中，终端词永远不能出现在元符号`::=`的左侧。右侧的定义主体可以由几个备选（或）形式组成，每个备选（或）的句法结构都由元符号`|`分隔。每个备选结构都可以是终端符或非终端符。

- '[Extended Backus–Naur form](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form)' uses all facilities in BNF and introduces two more metasymbols for additional features. One of these two new features is applied to denote an optional phrase in a statement by square bracketing the optional phrase. The second feature is applied to denote a phrase that is to be repeated zero or more times by curly bracketing the phrase.

> '[Extended Backus-Naur form](https://en.wikipedia.org/wiki/Extended_Backus-Naur_form)'使用了BNF中的所有功能，并为额外的特征引入了两个元符号。这两个新特征中的一个被用来表示语句中的可选短语，即用方括号表示可选短语。第二个特征用于表示一个重复了0次或更多次的短语，用大括号括住该短语。

- '[Wirth syntax notation](https://en.wikipedia.org/wiki/Wirth_syntax_notation)' uses all facilities in EBNF except that the nonterminals are not necessarily angle bracketed but is always defined on the right-hand side of `=` in its production rule. It also does not require every nonterminal to be explicitly defined. Nonterminals such as `<text>` and `<opt-whitespace>` are implicitly defined as ASCII-character and optional white space respectively.

> '[Wirth syntax notation](https://en.wikipedia.org/wiki/Wirth_syntax_notation)'使用EBNF中的所有功能，除了非终端不一定要用角括号，但在其产生规则中总是定义在`=`的右侧。它也不要求每个非终端符都被明确定义。诸如`<text>`和`<opt-whitespace>`这样的非终端符分别被隐含地定义为ASCII字符和可选的空格。

- '[Augmented Backus–Naur form](https://en.wikipedia.org/wiki/Augmented_Backus–Naur_form)' denotes nonterminal symbols by starting a one-word-name with an alphabet as the name of the syntactic category. Angle brackets are not required. Terminal symbols are either denoted by double quoted words or denoted by the following numeric structure: a `%`, followed by `b` or `x` or `d`, followed by a numeric value or a *concatenation of numeric values* separated by `.`. Metasymbol `-` is placed between two numeric values to denote *value range*. As that of BNF, the terminals of ABNF never occurs on the left-hand-side of the metasymbol `=` in the derivation rule. Metasymbol `/` denotes *alternations*. White space is used to separate elements in the body of the definition. The metasyntax for *repetition* in ABNF has several forms. A `*` preceding an element denotes the element to be repeated zero or more times. Numeric value n1 followed by `*` followed by numeric value n2 followed by an element denotes the element to be repeated at least n1 times and at most n2 times. A single numeric value n preceding an element denotes the element to be repeated n times. *Comments* may be express after metasymbol `;`. As in EBNF, square bracketing a phrase denotes the phrase to be *optional*.

> '[Augmented Backus-Naur form](https://en.wikipedia.org/wiki/Augmented_Backus-Naur_form)'通过以一个字母作为句法类别的名称开始一个单字名来表示非终端符号。角括号是不需要的。终端符号要么用双引号表示，要么用以下数字结构表示：一个`%`，后面是`b`或`x`或`d`，后面是一个数字值或一个由`.`分隔的*数字值的连词*。元符号`-`放在两个数值之间，表示*数值范围*。和BNF一样，ABNF的终端永远不会出现在派生规则中的元符号`=`的左侧。元符号`/`表示*备选（或）项*。空格用于分隔定义主体中的元素。ABNF中的*重复*的元语法有几种形式。一个元素前面的`*`表示该元素将被重复零次或多次。数字值n1后面是`*`，后面是数字值n2，后面是一个元素，表示这个元素至少要重复n1次，最多重复n2次。一个元素前的单一数值n表示该元素将被重复n次。*注释*可以在元符号`;`之后表达。在EBNF中，一个短语的方括号表示该短语是*可选择的*。

### Variations

The metasyntax convention of these formal metalanguages are not yet formalized. Many metasyntactic variations or extensions exist in the reference manual of various computer programming languages. One variation to the standard convention for denoting nonterminals and terminals is to remove metasymbols such as angle brackets and quotations and apply *font types* to the intended words. In [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language)), for example, syntactic categories are denoted by applying lower case [sans-serif font](https://en.wikipedia.org/wiki/Sans-serif_font) on the intended words or symbols. All terminal words or symbols, in Ada, consist of characters of code position between 16#20# and 16#7E# (inclusive). The definition for each character set is referred to the International Standard described by [ISO/IEC](https://en.wikipedia.org/wiki/ISO/IEC) 10646:2003. In [C](https://en.wikipedia.org/wiki/C_(programming_language)) and [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), syntactic categories are denoted using [italic font](https://en.wikipedia.org/wiki/Italic_font) while terminal symbols are denoted by [gothic](https://en.wikipedia.org/wiki/Sans-serif) font. In [J](https://en.wikipedia.org/wiki/J_(programming_language)), its metasyntax does not apply metasymbols to describe J's syntax at all. Rather, all syntactic explanations are done in a metalanguage very similar to English called Dictionary, which is uniquely documented for J.

> 这些形式化的元语言的元语法惯例还没有正式确定。在各种计算机编程语言的参考手册中存在许多元语法的变化或扩展。表示非终端和终端的标准惯例的一个变体是删除元符号，如角括号和引号，并将*字体类型*应用于预定的词语。例如，在[Ada](https://en.wikipedia.org/wiki/Ada_(programming_language))中，句法类别的表示方法是将小写的[sans-serif font](https://en.wikipedia.org/wiki/Sans-serif_font)应用于预期的单词或符号。在Ada中，所有的终端词或符号都由代码位置在16#20#和16#7E#（包括）之间的字符组成。每个字符集的定义都参考了[ISO/IEC](https://en.wikipedia.org/wiki/ISO/IEC) 10646:2003所描述的国际标准。在[C](https://en.wikipedia.org/wiki/C_(programming_language))和[Java](https://en.wikipedia.org/wiki/Java_(programming_language))中，句法类别用[斜体](https://en.wikipedia.org/wiki/Italic_font)表示，而终端符号则用[哥特式](https://en.wikipedia.org/wiki/Sans-serif)字体表示。在[J](https://en.wikipedia.org/wiki/J_(programming_language))中，其元语法完全没有应用元符号来描述J的句法。相反，所有的句法解释都是在一种与英语非常相似的元语言中完成的，这种语言被称为Dictionary，是J独有的文档。

### Advantage of extension

The purpose of the new extensions is to provide a simpler and unambiguous metasyntax. In terms of simplicity, BNF's metanotation definitely does not help to make the metasyntax easier-to-read as the open-end and close-end metasymbols appear too abundantly. In terms of ambiguity, BNF's metanotation generates unnecessary complexity when quotation marks, apostrophes, less-than signs or greater-than signs come to serve as terminal symbols, which they often do. The extended metasyntax utilizes properties such as case, font, and code position of characters to reduce unnecessary aforementioned complexity. Moreover, some metalanguages use fonted separator categories to incorporate metasyntactic features for layout conventions, which are not formally supported by BNF.

> 新扩展的目的是为了提供一个更简单和明确的元语法。就简单性而言，BNF的元注释绝对无助于使元语法更容易阅读，因为开口和闭口的元符号出现得太多了。在模糊性方面，当引号、撇号、小于号或大于号被用作终端符号时，BNF的元符号产生了不必要的复杂性，而它们经常这样做。扩展的元语法利用字符的大小写、字体和代码位置等属性来减少上述不必要的复杂性。此外，一些元语言使用字体化的分隔符类别来纳入布局惯例的元语法特征，而这并没有得到BNF的正式支持。

## See also

- [Adaptive grammar](https://en.wikipedia.org/wiki/Adaptive_grammar)
- [Comparison of parser generators](https://en.wikipedia.org/wiki/Comparison_of_parser_generators)
- [Metapragmatics](https://en.wikipedia.org/wiki/Metapragmatics)
- [Metasemantics](https://en.wikipedia.org/wiki/Metasemantics)
- [Metavariable (logic)](https://en.wikipedia.org/wiki/Metavariable_(logic))



---

# Backus-Naur form

In [computer science](https://en.wikipedia.org/wiki/Computer_science), **Backus–Naur form** ([/ˌbækəs ˈnaʊər/](https://en.wikipedia.org/wiki/Help:IPA/English)) or **Backus normal form** (**BNF**) is a [metasyntax](https://en.wikipedia.org/wiki/Metasyntax) notation for [context-free grammars](https://en.wikipedia.org/wiki/Context-free_grammar), often used to describe the [syntax](https://en.wikipedia.org/wiki/Syntax_(programming_languages)) of [languages](https://en.wikipedia.org/wiki/Formal_language#Programming_languages) used in computing, such as computer [programming languages](https://en.wikipedia.org/wiki/Programming_language), [document formats](https://en.wikipedia.org/wiki/Document_format), [instruction sets](https://en.wikipedia.org/wiki/Instruction_set) and [communication protocols](https://en.wikipedia.org/wiki/Communication_protocol). They are applied wherever exact descriptions of languages are needed: for instance, in official language specifications, in manuals, and in textbooks on programming language theory.

> 在[计算机科学](https://en.wikipedia.org/wiki/Computer_science)中，**Backus-Naur形式**（[/ˌbækəs ˈnaʊər/](https://en.wikipedia.org/wiki/Help:IPA/English)）或**Backus normal form**（**BNF**）是[无语境语法](https://en.wikipedia.org/wiki/Metasyntax)的一种[元语法](https://en.wikipedia.org/wiki/Context-free_grammar)符号，通常用于描述计算机中使用的语言的语法，用于计算机[编程语言](https://en.wikipedia.org/wiki/Programming_language)、[文档格式](https://en.wikipedia.org/wiki/Document_format)、[指令集](https://en.wikipedia.org/wiki/Instruction_set)和[通信协议](https://en.wikipedia.org/wiki/Communication_protocol)。它们被应用于需要对语言进行精确描述的地方：例如，在官方语言规范、手册和编程语言理论的教科书中。

Many extensions and variants of the original Backus–Naur notation are used; some are exactly defined, including [extended Backus–Naur form](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form) (EBNF) and [augmented Backus–Naur form](https://en.wikipedia.org/wiki/Augmented_Backus–Naur_form) (ABNF).

> 使用了许多原始Backus-Naur符号的扩展和变体；有些是确切定义的，包括[扩展Backus-Naur形式](https://en.wikipedia.org/wiki/Extended_Backus-Naur_form) (EBNF)和[增强Backus-Naur形式](https://en.wikipedia.org/wiki/Augmented_Backus-Naur_form) (ABNF)。
>

## Overview

A BNF specification is a set of derivation rules, written as

> BNF规范是一组推导规则，写为

```bash
<symbol> ::= __expresssion__
```

where:

- \<[symbol](https://en.wikipedia.org/wiki/Symbol)> [[1\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-class-1) is a *[nonterminal](https://en.wikipedia.org/wiki/Nonterminal)* (variable) and the [\__expression__](https://en.wikipedia.org/wiki/Expression_(mathematics)) consists of one or more sequences of either terminal or nonterminal symbols;
- `::=` means that the symbol on the left must be replaced with the expression on the right.
- more sequences [of symbols] are separated by the [vertical bar](https://en.wikipedia.org/wiki/Vertical_bar) "|", indicating a [choice](https://en.wikipedia.org/wiki/Alternation_(formal_language_theory)), the whole being a possible substitution for the symbol on the left.

Symbols that never appear on a left side are *[terminals](https://en.wikipedia.org/wiki/Terminal_symbol)*. On the other hand, symbols that appear on a left side are *[non-terminals](https://en.wikipedia.org/wiki/Nonterminal_symbol)* and are always enclosed between the pair <>.[[1\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-class-1)

> 其中：
>
> - \<[symbol](https://en.wikipedia.org/wiki/Symbol)> [[1]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-class-1)是一个*[非终端符](https://en.wikipedia.org/wiki/Nonterminal)*(变量)，[\__expression__](https://en.wikipedia.org/wiki/Expression_(数学))由一个或多个终端或非终端符号的序列组成。
> - `::=`意味着左边的符号必须被右边的表达式所替换。
> - 更多的[符号]序列被[竖条](https://en.wikipedia.org/wiki/Vertical_bar)"|"隔开，表示一个[选择](https://en.wikipedia.org/wiki/Alternation_(formal_language_theory))，整体是左边的符号的可能替代物。
>
> 从未出现在左边的符号是*[终端符](https://en.wikipedia.org/wiki/Terminal_symbol)*。另一方面，出现在左边的符号是*[非终端符](https://en.wikipedia.org/wiki/Nonterminal_symbol)*，并且总是被包围在一对<>之间。

## Example

As an example, consider this possible BNF for a U.S. [postal address](https://en.wikipedia.org/wiki/Address_(geography)):

> 作为一个例子，思考一下美国[邮政地址](https://en.wikipedia.org/wiki/Address_(geography))的这个可能的BNF：

```bash
<postal-address> ::= <name-part> <street-address> <zip-part>
<name-part> ::= <personal-part> <last-name> <opt-suffix-part> <EOL> | <personal-part> <name-part>
<personal-part> ::= <initial> "." | <first-name>
<street-address> ::= <house-num> <street-num> <opt-apt-num> <EOL>
<zip-part> ::= <town-name> "," <state-code> <ZIP-code> <EOL>
<opt-suffix-part> ::= "Sr." | "Jr." | <roman-numeral> | ""
<opt-apt-num> ::= <apt-num> | ""
```

This translates into English as:

- A postal address consists of a name-part, followed by a [street-address](https://en.wikipedia.org/wiki/Street_name) part, followed by a [zip-code](https://en.wikipedia.org/wiki/ZIP_Code) part.
- A name-part consists of either: a personal-part followed by a [last name](https://en.wikipedia.org/wiki/Last_name) followed by an optional [suffix](https://en.wikipedia.org/wiki/Suffix_(name)) (Jr., Sr., or dynastic number) and [end-of-line](https://en.wikipedia.org/wiki/End-of-line), or a personal part followed by a name part (this rule illustrates the use of [recursion](https://en.wikipedia.org/wiki/Recursion_(computer_science)) in BNFs, covering the case of people who use multiple first and middle names and initials).
- A personal-part consists of either a [first name](https://en.wikipedia.org/wiki/First_name) or an [initial](https://en.wikipedia.org/wiki/Initial) followed by a dot.
- A street address consists of a house number, followed by a street name, followed by an optional [apartment](https://en.wikipedia.org/wiki/Apartment) specifier, followed by an end-of-line.
- A zip-part consists of a [town](https://en.wikipedia.org/wiki/Town)-name, followed by a comma, followed by a [state code](https://en.wikipedia.org/wiki/U.S._postal_abbreviations), followed by a ZIP-code followed by an end-of-line.
- An opt-suffix-part consists of a suffix, such as "Sr.", "Jr." or a [roman-numeral](https://en.wikipedia.org/wiki/Roman_numerals), or an empty string (i.e. nothing).
- An opt-apt-num consists of an apartment number or an empty string (i.e. nothing).

Note that many things (such as the format of a first-name, apartment number, ZIP-code, and Roman numeral) are left unspecified here. If necessary, they may be described using additional BNF rules.

> 这句话翻译成英文就是：
>
> - 邮政地址由姓名部分，然后是[街道地址](https://en.wikipedia.org/wiki/Street_name)部分，然后是[邮政编码](https://en.wikipedia.org/wiki/ZIP_Code)部分，组成的。
> - 姓名部分包括：个人部分，后面是[姓氏](https://en.wikipedia.org/wiki/Last_name)，后面是可选的[后缀](https://en.wikipedia.org/wiki/Suffix_(name))(Jr., Sr., or dynastic number)和[行末](https://en.wikipedia.org/wiki/End-of-line)，或者个人部分后面是姓名部分（此规则说明了BNF中[递归](https://en.wikipedia.org/wiki/Recursion_(computer_science))的使用，包括使用多个首和中名及首字母的人的情况）。
> - 个人部分由[名](https://en.wikipedia.org/wiki/First_name)或[首字母](https://en.wikipedia.org/wiki/Initial)组成，后面有一个点。
> - 一个街道地址由一个门牌号和一个街道名称组成，然后是一个可选的[公寓](https://en.wikipedia.org/wiki/Apartment)指定符，最后是一个行末。
> - 一个邮编部分由一个[镇](https://en.wikipedia.org/wiki/Town)名称组成，后面是一个逗号，接着是一个[州代码](https://en.wikipedia.org/wiki/U.S._postal_abbreviations)，然后是一个邮政编码，最后是行末。
> - opt-suffix-part由一个后缀组成，如 "Sr."、"Jr. "或[罗马数字](https://en.wikipedia.org/wiki/Roman_numerals)，或一个空字符串（即没有）。
> - opt-apt-num由一个公寓号码或一个空字符串（即什么都没有）组成。
>
> 请注意，许多东西（例如名字、公寓号码、邮政编码和罗马数字的格式）在这里没有被指定。如果有必要，可以使用额外的BNF规则来描述它们。

## History

The idea of describing the structure of language using [rewriting rules](https://en.wikipedia.org/wiki/Rewrite_rule) can be traced back to at least the work of [Pāṇini](https://en.wikipedia.org/wiki/Pāṇini), an ancient Indian Sanskrit grammarian and a revered scholar in Hinduism who lived sometime between the 6th and 4th century [BC](https://en.wikipedia.org/wiki/Before_Christ).[[2\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-2)[[3\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-3) His notation to describe [Sanskrit](https://en.wikipedia.org/wiki/Sanskrit) word structure is equivalent in power to that of Backus and has many similar properties.

In Western society, grammar was long regarded as a subject for teaching, rather than scientific study; descriptions were informal and targeted at practical usage. In the first half of the 20th century, [linguists](https://en.wikipedia.org/wiki/Linguistics) such as [Leonard Bloomfield](https://en.wikipedia.org/wiki/Leonard_Bloomfield) and [Zellig Harris](https://en.wikipedia.org/wiki/Zellig_Harris) started attempts to formalize the description of language, including phrase structure.

Meanwhile, [string rewriting rules](https://en.wikipedia.org/wiki/Semi-Thue_system) as [formal logical systems](https://en.wikipedia.org/wiki/Formal_logical_systems) were introduced and studied by mathematicians such as [Axel Thue](https://en.wikipedia.org/wiki/Axel_Thue) (in 1914), [Emil Post](https://en.wikipedia.org/wiki/Emil_Post) (1920s–40s) and [Alan Turing](https://en.wikipedia.org/wiki/Alan_Turing) (1936). [Noam Chomsky](https://en.wikipedia.org/wiki/Noam_Chomsky), teaching linguistics to students of [information theory](https://en.wikipedia.org/wiki/Information_theory) at [MIT](https://en.wikipedia.org/wiki/MIT), combined linguistics and mathematics by taking what is essentially Thue's formalism as the basis for the description of the syntax of [natural language](https://en.wikipedia.org/wiki/Natural_language). He also introduced a clear distinction between generative rules (those of [context-free grammars](https://en.wikipedia.org/wiki/Context-free_grammar)) and transformation rules (1956).[[4\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-4)[[5\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-Chomsky1957-5)

> 用[改写规则](https://en.wikipedia.org/wiki/Rewrite_rule)来描述语言结构的想法至少可以追溯到[Pāṇini](https://en.wikipedia.org/wiki/Pāṇini)的工作，他是古代印度的梵文语法学家，也是印度教中受人尊敬的学者，生活在[公元前](https://en.wikipedia.org/wiki/Before_Christ)6世纪的某个时期。[[2\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-2)[[3\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-3) 他用来描述[梵文](https://en.wikipedia.org/wiki/Sanskrit)单词结构的符号与Backus的功能相当，有很多类似的特性。
>
> 在西方社会，语法长期以来被视为教学科目，而不是科学研究；描述是非正式的，以实际使用为目标。在20世纪上半叶，[语言学家](https://en.wikipedia.org/wiki/Linguistics)如[Leonard Bloomfield](https://en.wikipedia.org/wiki/Leonard_Bloomfield)和[Zellig Harris](https://en.wikipedia.org/wiki/Zellig_Harris)开始尝试将语言的描述正规化，包括短语结构。
>
> 同时，[字符串重写规则](https://en.wikipedia.org/wiki/Semi-Thue_system)作为[形式逻辑系统](https://en.wikipedia.org/wiki/Formal_logical_systems)被数学家引入并研究，如[Axel Thue](https://en.wikipedia.org/wiki/Axel_Thue)（1914年）、[Emil Post](https://en.wikipedia.org/wiki/Emil_Post)（1920-40年代）和[Alan Turing](https://en.wikipedia.org/wiki/Alan_Turing)（1936）。[Noam Chomsky](https://en.wikipedia.org/wiki/Noam_Chomsky)在[麻省理工学院](https://en.wikipedia.org/wiki/MIT)向[信息论](https://en.wikipedia.org/wiki/Information_theory)的学生讲授语言学，他把语言学和数学结合起来，把本质上是Thue的形式主义作为描述[自然语言](https://en.wikipedia.org/wiki/Natural_language)语法的基础。他还介绍了生成规则（那些[无语境语法](https://en.wikipedia.org/wiki/Context-free_grammar)）和转换规则（1956）之间的明确区别。[[4\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-4)

[John Backus](https://en.wikipedia.org/wiki/John_Backus), a programming language designer at [IBM](https://en.wikipedia.org/wiki/IBM), proposed a [metalanguage](https://en.wikipedia.org/wiki/Metalanguage) of "metalinguistic formulas"[[1\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-class-1)[[7\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-Backus.1969-7)[[8\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-8) to describe the syntax of the new programming language IAL, known today as [ALGOL 58](https://en.wikipedia.org/wiki/ALGOL_58) (1959). His notation was first used in the ALGOL 60 report.

BNF is a notation for Chomsky's context-free grammars. Backus was familiar with Chomsky's work.[[9\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-9)

As proposed by Backus, the formula defined "classes" whose names are enclosed in angle brackets. For example, `<ab>`. Each of these names denotes a class of basic symbols.[[1\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-class-1)

Further development of [ALGOL](https://en.wikipedia.org/wiki/ALGOL) led to [ALGOL 60](https://en.wikipedia.org/wiki/ALGOL_60). In the committee's 1963 report, [Peter Naur](https://en.wikipedia.org/wiki/Peter_Naur) called Backus's notation *Backus normal form*. [Donald Knuth](https://en.wikipedia.org/wiki/Donald_Knuth) argued that BNF should rather be read as *Backus–Naur form*, as it is "not a [normal form](https://en.wikipedia.org/wiki/Normal_form_(term_rewriting)) in the conventional sense",[[10\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-10) unlike, for instance, [Chomsky normal form](https://en.wikipedia.org/wiki/Chomsky_normal_form). The name *Pāṇini Backus form* was also once suggested in view of the fact that the expansion *Backus normal form* may not be accurate, and that [Pāṇini](https://en.wikipedia.org/wiki/Pāṇini) had independently developed a similar notation earlier.[[11\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-11)

> [John Backus](https://en.wikipedia.org/wiki/John_Backus)，[IBM](https://en.wikipedia.org/wiki/IBM)的一名编程语言设计师，提出了一种 "[元语言]()"[[1\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-class-1)[[7\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-Backus.1969-7)[[8\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-8)来描述新编程语言IAL的语法，今天被称为[ALGOL 58](https://en.wikipedia.org/wiki/ALGOL_58) （1959）。他的符号在ALGOL 60报告中首次使用。
>
> BNF是乔姆斯基的无上下文语法的一种符号。Backus熟悉Chomsky的工作。[[9\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-9)
>
> 按照Backus的提议，该公式定义了 "类"，其名称用角括号括起来。例如，`<ab>`。这些名称中的每一个都表示一类基本符号。[[1]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-class-1)
>
> [ALGOL](https://en.wikipedia.org/wiki/ALGOL)的进一步发展导致了[ALGOL 60](https://en.wikipedia.org/wiki/ALGOL_60)。在委员会1963年的报告中，[Peter Naur](https://en.wikipedia.org/wiki/Peter_Naur)称Backus的符号为*Backus正常形式*。[Donald Knuth](https://en.wikipedia.org/wiki/Donald_Knuth)认为BNF应该被理解为*Backus-Naur形式*，因为它 "不是传统意义上的[正常形式](https://en.wikipedia.org/wiki/Normal_form_(term_rewriting))"，[[10]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-10)与例如[Chomsky正常形式](https://en.wikipedia.org/wiki/Chomsky_normal_form)不同。鉴于*Pāṇini Backus form*的扩展可能并不准确，而且[Pāṇini](https://en.wikipedia.org/wiki/Pāṇini)在更早的时候就独立开发了一个类似的符号，因此也曾经提出过*Pāṇini Backus form*这个名字。[[11\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-11)

BNF is described by Peter Naur in the ALGOL 60 report as *metalinguistic formula*:[[12\]](https://en.wikipedia.org/wiki/Backus–Naur_form#cite_note-ALGOL60RPT-12)

> Sequences of characters enclosed in the brackets <> represent metalinguistic variables whose values are sequences of symbols. The marks "::=" and "|" (the latter with the meaning of "or") are metalinguistic connectives. Any mark in a formula, which is not a variable or a connective, denotes itself. Juxtaposition of marks or variables in a formula signifies juxtaposition of the sequence denoted.

> BNF由Peter Naur在ALGOL 60报告中描述为*metalinguistic formula*：[[12\]](https://en.wikipedia.org/wiki/Backus-Naur_form#cite_note-ALGOL60RPT-12)
>
> >括号内的字符序列<>代表元语言学变量，其值是符号序列。标记"::="和"|"（后者有"或"的含义）是元语言学的连接词。公式中的任何标记，如果不是变量或连接词，则表示其本身。公式中的标记或变量的并列意思是表示的序列的并列。

Another example from the ALGOL 60 report illustrates a major difference between the BNF metalanguage and a Chomsky context-free grammar. Metalinguistic variables do not require a rule defining their formation. Their formation may simply be described in natural language within the <> brackets. The following ALGOL 60 report section 2.3 comments specification, exemplifies how this works:

> For the purpose of including text among the symbols of a program the following "comment" conventions hold:
>
> | The sequence of basic symbols:                               | is equivalent to |
> | ------------------------------------------------------------ | ---------------- |
> | **;** **comment** <any sequence not containing ';'>;         | **;**            |
> | **begin** **comment** <any sequence not containing ';'>;     | **begin**        |
> | **end** <any sequence not containing 'end' or ';' or 'else'> | **end**          |
>
> Equivalence here means that any of the three structures shown in the left column may be replaced, in any occurrence outside of strings, by the symbol shown in the same line in the right column without any effect on the action of the program.

> ALGOL 60报告中的另一个例子说明了BNF金属语言和乔姆斯基无语境语法之间的一个主要区别。元语言的变量不需要定义其形成的规则。它们的形成可以简单地在<>括号内用自然语言描述。下面的ALGOL 60报告第2.3节注释规范，举例说明了这是如何进行的。
>
> > 为了在程序的符号中包括文本，以下 "注释"惯例是有效的。
> >
> > | The sequence of basic symbols:                               | is equivalent to |
> > | ------------------------------------------------------------ | ---------------- |
> > | **;** **comment** <any sequence not containing ';'>;         | **;**            |
> > | **begin** **comment** <any sequence not containing ';'>;     | **begin**        |
> > | **end** <any sequence not containing 'end' or ';' or 'else'> | **end**          |
> >
> > 这里的等价性是指左栏所示的三种结构中的任何一种，在字符串之外的任何场合，都可以被右栏同一行所示的符号所替代，而不会对程序的运行产生任何影响。



...

## Further examples

BNF's syntax itself may be represented with a BNF like the following:

> BNF的语法本身可以用下面这样的BNF来表示：

```bash
<syntax> ::= <rule> | <rule> <syntax>
<rule> ::= <opt-whitespace> "<" <rule-name> ">" <opt-whitespace> "::=" <opt-whitespace> <expression> <line-end>
<opt-whitespace> ::= " " <opt-whitespace> | ""
<expression> ::= <list> | <list> <opt-whitespace> "|" <opt-whitespace> <expression>
<line-end>       ::= <opt-whitespace> <EOL> | <line-end> <line-end>
 <list>           ::= <term> | <term> <opt-whitespace> <list>
 <term>           ::= <literal> | "<" <rule-name> ">"
 <literal>        ::= '"' <text1> '"' | "'" <text2> "'"
 <text1>          ::= "" | <character1> <text1>
 <text2>          ::= '' | <character2> <text2>
 <character>      ::= <letter> | <digit> | <symbol>
 <letter>         ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
 <digit>          ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
 <symbol>         ::=  "|" | " " | "!" | "#" | "$" | "%" | "&" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | ">" | "=" | "<" | "?" | "@" | "[" | "\" | "]" | "^" | "_" | "`" | "{" | "}" | "~"
 <character1>     ::= <character> | "'"
 <character2>     ::= <character> | '"'
 <rule-name>      ::= <letter> | <rule-name> <rule-char>
 <rule-char>      ::= <letter> | <digit> | "-"
```

Note that "" is the [empty string](https://en.wikipedia.org/wiki/Empty_string).

The original BNF did not use quotes as shown in `<literal>` rule. This assumes that no [whitespace](https://en.wikipedia.org/wiki/Whitespace_(computer_science)) is necessary for proper interpretation of the rule.

`<EOL>` represents the appropriate [line-end](https://en.wikipedia.org/wiki/Newline) specifier (in [ASCII](https://en.wikipedia.org/wiki/ASCII), carriage-return, line-feed or both depending on the [operating system](https://en.wikipedia.org/wiki/Operating_system)). `<rule-name>` and `<text>` are to be substituted with a declared rule's name/label or literal text, respectively.

In the U.S. postal address example above, the entire block-quote is a syntax. Each line or unbroken grouping of lines is a rule; for example one rule begins with `<name-part> ::=`. The other part of that rule (aside from a line-end) is an expression, which consists of two lists separated by a pipe `|`. These two lists consists of some terms (three terms and two terms, respectively). Each term in this particular rule is a rule-name.

> 注意，""是[空字符串](https://en.wikipedia.org/wiki/Empty_string)。
>
> 最初的BNF没有使用引号，如`<literal>`规则中所示。这假定没有[空白字符](https://en.wikipedia.org/wiki/Whitespace_(computer_science))对于规则的正确解释是必要的。
>
> `<EOL>`代表适当的[行结束](https://en.wikipedia.org/wiki/Newline)指定符（在[ASCII](https://en.wikipedia.org/wiki/ASCII)中，回车符、换行符或两者都有，取决于[操作系统](https://en.wikipedia.org/wiki/Operating_system)）。`<rule-name>`和`<text>`将分别被替换为声明的规则名称/标签或字面文本。
>
> 在上面的美国邮政地址例子中，整个块引用是一个语法。每一行或不间断的一组行是一条规则；例如，一条规则以`<name-part> ::=`开始。该规则的另一部分（除了行尾）是一个表达式，它由两个列表组成，用管子`|`分开。这两个列表由一些术语组成（分别是三个术语和两个术语）。这个特定规则中的每个术语都是一个规则名称。

[Extended Backus-Naur form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)

[Formal language](https://en.wikipedia.org/wiki/Formal_language)



...

## See also

- [Compiler Description Language](https://en.wikipedia.org/wiki/Compiler_Description_Language) (CDL)
- [Syntax diagram](https://en.wikipedia.org/wiki/Syntax_diagram) – railroad diagram
- [Translational Backus–Naur form](https://en.wikipedia.org/wiki/Translational_Backus–Naur_form) (TBNF)
- [Wirth syntax notation](https://en.wikipedia.org/wiki/Wirth_syntax_notation) – an alternative to BNF from 1977
- [Definite clause grammar](https://en.wikipedia.org/wiki/Definite_clause_grammar) – a more expressive alternative to BNF used in Prolog
- [Van Wijngaarden grammar](https://en.wikipedia.org/wiki/Van_Wijngaarden_grammar) – used in preference to BNF to define [Algol68](https://en.wikipedia.org/wiki/Algol68)
- [Meta-II](https://en.wikipedia.org/wiki/Meta-II) – an early compiler writing tool and notation

reference:

The meaning of syntactic formula may be further explained by saying that words enclosed in the brackets `< >`, like `<ab>`, denote classes whose members are sequences of basic symbols. Class designations of this kind are found in any description of a language. For describing ordinary natural languages designation like word, verb, noun, are used.

> 句法公式的含义可以进一步解释为：括号内的词`< >`，如`<ab>`，表示其成员为基本符号序列的类。在任何语言的描述中都可以找到这种类的称呼。在描述普通自然语言时，会使用像单词、动词、名词这样的指定。

---

# [OOP: Object-Oriented Programming](https://en.wikipedia.org/wiki/Object-oriented_programming)

**Object-oriented programming** (**OOP**) is a [programming paradigm](https://en.wikipedia.org/wiki/Programming_paradigm) based on the concept of "[objects](https://en.wikipedia.org/wiki/Object_(computer_science))", which can contain [data](https://en.wikipedia.org/wiki/Data) and [code](https://en.wikipedia.org/wiki/Computer_program): data in the form of [fields](https://en.wikipedia.org/wiki/Field_(computer_science)) (often known as [attributes](https://en.wikipedia.org/wiki/Attribute_(computing)) or *properties*), and code, in the form of procedures (often known as *[methods](https://en.wikipedia.org/wiki/Method_(computer_science))*). 

A common feature of objects is that procedures (or methods) are  attached to them and can access and modify the object's data fields. In  this brand of OOP, there is usually a special name such as [`this`](https://en.wikipedia.org/wiki/This_(computer_programming)) or `self` used to refer to the current object. In OOP, computer programs are  designed by making them out of objects that interact with one another.[[1\]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-1)[[2\]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-2) OOP languages are diverse, but the most popular ones are [class-based](https://en.wikipedia.org/wiki/Class-based_programming), meaning that objects are [instances](https://en.wikipedia.org/wiki/Instance_(computer_science)) of [classes](https://en.wikipedia.org/wiki/Class_(computer_science)), which also determine their [types](https://en.wikipedia.org/wiki/Data_type).

Many of the most widely used programming languages (such as C++, Java, Python, etc.) are [multi-paradigm](https://en.wikipedia.org/wiki/Multi-paradigm_programming_language) and they support object-oriented programming to a greater or lesser degree, typically in combination with [imperative](https://en.wikipedia.org/wiki/Imperative_programming), [procedural programming](https://en.wikipedia.org/wiki/Procedural_programming). Significant object-oriented languages include: [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [C++](https://en.wikipedia.org/wiki/C%2B%2B), [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [R](https://en.wikipedia.org/wiki/R_(programming_language)), [PHP](https://en.wikipedia.org/wiki/PHP), [Visual Basic.NET](https://en.wikipedia.org/wiki/Visual_Basic.NET), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)), [Perl](https://en.wikipedia.org/wiki/Perl), [SIMSCRIPT](https://en.wikipedia.org/wiki/SIMSCRIPT), [Object Pascal](https://en.wikipedia.org/wiki/Object_Pascal), [Objective-C](https://en.wikipedia.org/wiki/Objective-C), [Dart](https://en.wikipedia.org/wiki/Dart_(programming_language)), [Swift](https://en.wikipedia.org/wiki/Swift_(programming_language)), [Scala](https://en.wikipedia.org/wiki/Scala_(programming_language)), [Kotlin](https://en.wikipedia.org/wiki/Kotlin_(programming_language)), [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp), [MATLAB](https://en.wikipedia.org/wiki/MATLAB), and [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk).

> **面向对象编程**（**OOP**）是一种基于"[对象](https://en.wikipedia.org/wiki/Programming_paradigm) "概念的[编程范式](https://en.wikipedia.org/wiki/Object_(computer_science))，它可以包含[数据](https://en.wikipedia.org/wiki/Data)和[代码](https://en.wikipedia. org/wiki/Computer_program）：数据以[字段](https://en.wikipedia.org/wiki/Field_(computer_science))的形式存在（通常被称为[属性](https://en.wikipedia.org/wiki/Attribute_(computing))或*属性*），而代码则以过程的形式存在（通常被称为*[方法](https://en.wikipedia.org/wiki/Method_(computer_science))*）。
>
> 对象的一个共同特征是，过程（或方法）附属于它们，可以访问和修改对象的数据字段。在这种品牌的OOP中，通常有一个特殊的名称，如[`this`](https://en.wikipedia.org/wiki/This_(computer_programming))或`self`，用来指代当前对象。在OOP中，计算机程序的设计是通过使它们由相互作用的对象组成。[[1]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-1)[[2]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-2) OOP语言多种多样，但最流行的是[基于类](https://en.wikipedia.org/wiki/Class-based_programming)，这意味着对象是[类](https://en.wikipedia.org/wiki/Class_(computer_science))的[实例](https://en.wikipedia.org/wiki/Instance_)，它们也决定了其[类型](https://en.wikipedia.org/wiki/Data_type)。
>
> 许多最广泛使用的编程语言（如C++、Java、Python等）是[多范式](https://en.wikipedia.org/wiki/Multi-paradigm_programming_language)，它们或多或少地支持面向对象编程，通常与[命令式](https://en.wikipedia.org/wiki/Imperative_programming)、[程序式编程](https://en.wikipedia.org/wiki/Procedural_programming)相结合。重要的面向对象语言包括。[Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [C++](https://en.wikipedia.org/wiki/C%2B%2B), [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [R](https://en.wikipedia.org/wiki/R_(programming_language)), [PHP](https://en.wikipedia.org/wiki/PHP), [Visual Basic.NET](https://en.wikipedia.org/wiki/Visual_Basic.NET), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language) ) , [Perl](https://en.wikipedia.org/wiki/Perl) , [SIMSCRIPT](https://en. wikipedia.org/wiki/SIMSCRIPT), [Object Pascal](https://en.wikipedia.org/wiki/Object_Pascal), [Objective-C](https://en.wikipedia.org/wiki/Objective-C), [Dart](https://en.wikipedia.org/wiki/Dart_(programming_language)), [Swift](https://en.wikipedia.org/wiki/Swift_(programming_language)), [Scala](https://en.wikipedia.org/wiki/Scala_(programming_language)), [Kotlin](https://en.wikipedia.org/wiki/Kotlin_(programming_language)), [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp), [MATLAB](https://en.wikipedia.org/wiki/MATLAB) and [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk)。

## Features

Object-oriented programming uses objects, but not all of the  associated techniques and structures are supported directly in languages that claim to support OOP. It performs operations on operands.  The  features listed below are common among languages considered to be  strongly class- and object-oriented (or [multi-paradigm](https://en.wikipedia.org/wiki/Multi-paradigm) with OOP support), with notable exceptions mentioned.[[16\]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-ArmstrongQuarks-16)[[17\]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-17)[[18\]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-18)[[19\]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-pierce-19)

See also: [Comparison of programming languages (object-oriented programming)](https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(object-oriented_programming)) and [List of object-oriented programming terms](https://en.wikipedia.org/wiki/List_of_object-oriented_programming_terms)

> 面向对象的编程使用**对象**，但并非所有相关的技术和结构都能在声称支持OOP的语言中得到直接支持。它对操作数进行操作。 下面列出的特征在被认为是强类和面向对象（或支持OOP的[多范式](https://en.wikipedia.org/wiki/Multi-paradigm)）的语言中是常见的，但也有明显的例外。[[16]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-ArmstrongQuarks-16)[[17]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-17)[[18]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-18)[[19]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-pierce-19)
>
> 也见。[编程语言的比较（面向对象的编程）](https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(object-oriented_programming)) 和 [面向对象的编程术语列表](https://en.wikipedia.org/wiki/List_of_object-oriented_programming_terms)
>

### Shared with non-OOP languages

- [Variables](https://en.wikipedia.org/wiki/Variable_(computer_science)) that can store information formatted in a small number of built-in [data types](https://en.wikipedia.org/wiki/Data_type) like [integers](https://en.wikipedia.org/wiki/Integer_(computer_science)) and alphanumeric [characters](https://en.wikipedia.org/wiki/Character_(computing)).  This may include [data structures](https://en.wikipedia.org/wiki/Data_structures) like [strings](https://en.wikipedia.org/wiki/String_(computer_science)), [lists](https://en.wikipedia.org/wiki/List_(abstract_data_type)), and [hash tables](https://en.wikipedia.org/wiki/Hash_table) that are either built-in or result from combining variables using [memory pointers](https://en.wikipedia.org/wiki/Pointer_(computer_programming)).
- Procedures – also known as functions, methods, routines, or [subroutines](https://en.wikipedia.org/wiki/Subroutine) – that take input, generate output, and manipulate data.  Modern languages include [structured programming](https://en.wikipedia.org/wiki/Structured_programming) constructs like [loops](https://en.wikipedia.org/wiki/Loop_(computing)) and [conditionals](https://en.wikipedia.org/wiki/Conditional_(computer_programming)).

[Modular programming](https://en.wikipedia.org/wiki/Modular_programming) support provides the ability to group procedures into files and modules for organizational purposes.  Modules are [namespaced](https://en.wikipedia.org/wiki/Namespace) so identifiers in one module will not conflict with a procedure or variable sharing the same name in another file or module.

> - [变量](https://en.wikipedia.org/wiki/Variable_(computer_science))可以存储以少量内置[数据类型](https://en.wikipedia.org/wiki/Data_type)如[整数](https://en.wikipedia.org/wiki/Integer_(computer_science))和字母数字[字符](https://en.wikipedia.org/wiki/Character_(computing))为格式的信息。 这可能包括[数据结构](https://en.wikipedia.org/wiki/Data_structures)，如[字符串](https://en.wikipedia.org/wiki/String_(computer_science))、[列表](https://en.wikipedia.org/wiki/List_(abstract_data_type))和[哈希表](https://en.wikipedia.org/wiki/Hash_table)，它们要么是内置的，要么是使用[内存指针](https://en.wikipedia.org/wiki/Pointer_(computer_programming))组合变量而产生。
> - 程序--也被称为函数、方法、例程或[子程序](https://en.wikipedia.org/wiki/Subroutine)--接受输入，产生输出，并操作数据。 现代语言包括[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)结构，如[循环](https://en.wikipedia.org/wiki/Loop_(计算))和[条件](https://en.wikipedia.org/wiki/Conditional_(计算机编程))。
>
> [模块化编程](https://en.wikipedia.org/wiki/Modular_programming)支持提供了将程序分组到**文件**和**模块**中的能力，以达到组织的目的。 模块是[namespaced](https://en.wikipedia.org/wiki/Namespace)，因此一个模块中的标识符不会与另一个文件或模块中的同名存储过程或变量相冲突。

### Object and classes

Languages that support object-oriented programming (OOP) typically use [inheritance](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)) for code reuse and extensibility in the form of either [classes](https://en.wikipedia.org/wiki/Class-based_programming) or [prototypes](https://en.wikipedia.org/wiki/Prototype-based_programming). Those that use classes support two main concepts:

- [Classes](https://en.wikipedia.org/wiki/Class_(computer_science)) – the definitions for the data format and available procedures for a  given type or class of object; may also contain data and procedures  (known as class methods) themselves, i.e. classes contain the data  members and member functions
- [Objects](https://en.wikipedia.org/wiki/Object_(computer_science)) – instances of classes

> 支持面向对象编程（OOP）的语言通常使用[继承](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming))，以[类](https://en.wikipedia.org/wiki/Class-based_programming)或[原型](https://en.wikipedia.org/wiki/Prototype-based_programming)的形式实现**代码复用**和**可扩展**。那些使用类的语言支持两个主要概念。
>
> - [类](https://en.wikipedia.org/wiki/Class_(computer_science)) --为特定类型或类别的对象**定义数据格式**和**可用程序**；也可能包含数据和程序（称为类方法）本身，即类包含**数据成员**和成员函数
> - [对象](https://en.wikipedia.org/wiki/Object_(computer_science)) - 类的实例

Objects sometimes correspond to things found in the real world. For  example, a graphics program may have objects such as "circle", "square", "menu". An online shopping system might have objects such as "shopping  cart", "customer", and "product".[[20\]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-20) Sometimes objects represent more abstract entities, like an object that represents an open file, or an object that provides the service of  translating measurements from U.S. customary to metric.

Each object is said to be an [instance](https://en.wikipedia.org/wiki/Instance_(computer_science)) of a particular class (for example, an object with its name field set  to "Mary" might be an instance of class Employee).  Procedures in  object-oriented programming are known as [methods](https://en.wikipedia.org/wiki/Method_(computer_science)); variables are also known as [fields](https://en.wikipedia.org/wiki/Field_(computer_science)), members, attributes, or properties.  This leads to the following terms:

- [Class variables](https://en.wikipedia.org/wiki/Class_variable) – belong to the *class as a whole*; there is only one copy of each one
- [Instance variables](https://en.wikipedia.org/wiki/Instance_variable) or attributes – data that belongs to individual *objects*; every object has its own copy of each one
- [Member variables](https://en.wikipedia.org/wiki/Member_variable) – refers to both the class and instance variables that are defined by a particular class
- Class methods – belong to the *class as a whole* and have access to only class variables and inputs from the procedure call
- Instance methods – belong to *individual objects*, and have access to instance variables for the specific object they are called on, inputs, and class variables

> 对象有时对应于现实世界中的事物。例如，一个图形程序可能有诸如 "圆"、"方"、"菜单 "等对象。一个在线购物系统可能有诸如 "购物车"、"客户 "和 "产品 "等对象。[[20]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-20)有时对象代表更抽象的实体，比如一个代表打开文件的对象，或者一个提供将测量值从美国习惯法翻译成公制的服务的对象。
>
> 每个对象都被说成是一个特定类的[实例](https://en.wikipedia.org/wiki/Instance_(computer_science))（例如，一个名字字段设置为 "Mary "的对象可能是一个Employee类的实例）。 面向对象编程中的程序被称为[方法](https://en.wikipedia.org/wiki/Method_(computer_science))；变量也被称为[字段](https://en.wikipedia.org/wiki/Field_(computer_science))、成员、属性或属性。 这导致了以下术语的出现。
>
> - [类变量](https://en.wikipedia.org/wiki/Class_variable) - 属于*类的整体*；每个变量只有一个副本
> - [实例变量](https://en.wikipedia.org/wiki/Instance_variable) 或属性--属于单个*对象*的数据；每个对象都有自己的副本
> - [成员变量](https://en.wikipedia.org/wiki/Member_variable) --指的是由某个特定的类定义的类和实例变量。
> - 类方法--属于整个*类*，只能访问类的变量和程序调用的输入。
> - 实例方法--属于*个体对象*，可以访问它们所调用的特定对象的实例变量、输入和类变量

Objects are accessed somewhat like variables with complex internal structure, and in many languages are effectively [pointers](https://en.wikipedia.org/wiki/Pointer_(computer_programming)), serving as actual references to a single instance of said object in memory within a heap or stack.  They provide a layer of [abstraction](https://en.wikipedia.org/wiki/Abstraction_(computer_science)) which can be used to separate internal from external code. External  code can use an object by calling a specific instance method with a  certain set of input parameters, read an instance variable, or write to  an instance variable. Objects are created by calling a special type of  method in the class known as a [constructor](https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)).  A program may create many instances of the same class as it runs,  which operate independently.  This is an easy way for the same  procedures to be used on different sets of data.

Object-oriented programming that uses classes is sometimes called [class-based programming](https://en.wikipedia.org/wiki/Class-based_programming), while [prototype-based programming](https://en.wikipedia.org/wiki/Prototype-based_programming) does not typically use classes. As a result, significantly different  yet analogous terminology is used to define the concepts of *object* and *instance*.

In some languages classes and objects can be composed using other concepts like [traits](https://en.wikipedia.org/wiki/Trait_(computer_programming)) and [mixins](https://en.wikipedia.org/wiki/Mixin).

> 对象的访问有点像具有复杂内部结构的变量，在许多语言中，对象实际上是[指针](https://en.wikipedia.org/wiki/Pointer_(computer_programming))，作为堆或栈中所述对象在内存中的单个实例的实际引用。 它们提供了一个[抽象](https://en.wikipedia.org/wiki/Abstraction_(computer_science))层，可以用来分离内部和外部代码。外部代码可以通过调用具有一定**输入参数**的**特定实例方法**来使用一个对象，读取一个实例变量，或写入一个实例变量。对象是通过调用类中一种特殊类型的方法来创建的，这种方法被称为[构造器](https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming))。 一个程序在运行过程中可以创建同一个类的许多实例，这些实例独立运行。 这是一种简单的方法，可以将相同的程序用于不同的数据集。
>
> 使用类的面向对象编程有时被称为[基于类的编程](https://en.wikipedia.org/wiki/Class-based_programming)，而[基于原型的编程](https://en.wikipedia.org/wiki/Prototype-based_programming)通常不使用类。因此，在定义*对象*和*实例*的概念时，使用了明显不同但类似的术语。
>
> 在一些语言中，类和对象可以用其他概念组成，比如[traits](https://en.wikipedia.org/wiki/Trait_(computer_programming))和[mixins](https://en.wikipedia.org/wiki/Mixin)。

### Class-based vs prototype-based

In [class-based languages](https://en.wikipedia.org/wiki/Class-based_programming) the *classes* are defined beforehand and the *objects* are instantiated based on the classes. If two objects *apple* and *orange* are instantiated from the class *Fruit*, they are inherently fruits and it is guaranteed that you may handle  them in the same way; e.g. a programmer can expect the existence of the  same attributes such as *color* or *sugar_content* or *is_ripe*.

In [prototype-based languages](https://en.wikipedia.org/wiki/Prototype-based_programming) the *objects* are the primary entities. No *classes* even exist. The *prototype* of an object is just another object to which the object is linked. Every object has one *prototype* link (and only one).  New objects can be created based on already  existing objects chosen as their prototype. You may call two different  objects *apple* and *orange* a fruit, if the object *fruit* exists, and both *apple* and *orange* have *fruit* as their prototype. The idea of the *fruit* class doesn't exist explicitly, but as the [equivalence class](https://en.wikipedia.org/wiki/Equivalence_class) of the objects sharing the same prototype. The attributes and methods of the *prototype* are [delegated](https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming)) to all the objects of the equivalence class defined by this prototype. The attributes and methods *owned* individually by the object may not be shared by other objects of the same equivalence class; e.g. the attribute *sugar_content* may be unexpectedly not present in *apple*. Only [single inheritance](https://en.wikipedia.org/wiki/Single_inheritance) can be implemented through the prototype.

> 在[基于类的语言](https://en.wikipedia.org/wiki/Class-based_programming)中，*类*是事先定义好的，*对象*是根据类来**实例化**的。如果两个对象*apple*和*orange*是从*Fruit*类中实例化出来的，那么它们本身就是水果，并且保证你可以用同样的方式处理它们；例如，程序员可以期望存在同样的属性，如*color*或*sugar_content*或*is_ripe*。
>
> 在[基于原型的语言](https://en.wikipedia.org/wiki/Prototype-based_programming)中，*对象*是主要实体。甚至不存在*类*。一个对象的*原型*只是该对象所链接的另一个对象。每个对象都有一个*原型*链接（而且只有一个）。 新的对象可以根据已经存在的对象选择作为其原型来创建。你可以把两个不同的对象*apple*和*orange*称为水果，如果对象*fruit*存在，并且*apple*和*orange*都以*fruit*为原型。*fruit*类的概念并不明确存在，而是作为共享相同原型的对象的[等价类](https://en.wikipedia.org/wiki/Equivalence_class）。原型*的属性和方法被[委托](https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming))给这个原型所定义的等价类中的所有对象。*原型*的属性和方法被[委托](https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming))给这个原型所定义的等价类的所有对象。对象单独*拥有的*属性和方法可能不会被同一等价类的其他对象所共享；例如，*sugar_content*的属性可能意外地不存在于*apple*中。只有[单一继承](https://en.wikipedia.org/wiki/Single_inheritance)可以通过原型实现。

### Dynamic dispatch/message passing

It is the responsibility of the object, not any external code, to  select the procedural code to execute in response to a method call,  typically by looking up the method at run time in a table associated  with the object.  This feature is known as [dynamic dispatch](https://en.wikipedia.org/wiki/Dynamic_dispatch).  If the call variability relies on more than the single type of the  object on which it is called (i.e. at least one other parameter object  is involved in the method choice), one speaks of [multiple dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch).

A method call is also known as *[message passing](https://en.wikipedia.org/wiki/Message_passing)*.  It is conceptualized as a message (the name of the method and its input parameters) being passed to the object for dispatch.

> 选择响应方法调用而执行的程序代码是对象的责任，而不是任何外部代码的责任，通常是通过在运行时在与对象相关的表中查找该方法。 这个特征被称为[动态调度](https://en.wikipedia.org/wiki/Dynamic_dispatch)。 如果调用的可变性依赖于它所调用的对象的单一类型以上（即至少有一个其他的参数对象参与到方法的选择中），人们就会说到[多重调度](https://en.wikipedia.org/wiki/Multiple_dispatch)。
>
> 方法调用也被称为*[消息传递](https://en.wikipedia.org/wiki/Message_passing)*。 它被概念化为一条消息（方法的名称和它的输入参数）被传递给对象进行调度。

### Data Abstraction

Data Abstraction is a design pattern in which data are visible only  to semantically related functions, so as to prevent misuse. The success  of data abstraction leads to frequent incorporation of [data hiding](https://en.wikipedia.org/wiki/Information_hiding) as a design principle in object oriented and pure functional programming.

If a class does not allow calling code to access internal object  data and permits access through methods only, this is a form of  information hiding known as [abstraction](https://en.wikipedia.org/wiki/Abstraction_(computer_science)).  Some languages (Java, for example) let classes enforce access  restrictions explicitly, for example denoting internal data with the `private` keyword and designating methods intended for use by code outside the class with the `public` keyword.  Methods may also be designed public, private, or intermediate levels such as `protected` (which allows access from the same class and its subclasses, but not  objects of a different class).  In other languages (like Python) this is enforced only by convention (for example, `private` methods may have names that start with an [underscore](https://en.wikipedia.org/wiki/Underscore)). 

> **数据抽象**是一种**设计模式**，其中数据只对语义相关的函数可见，以防止误用。数据抽象的成功导致了[数据隐藏](https://en.wikipedia.org/wiki/Information_hiding)经常被纳入面向对象和纯函数式编程的设计原则。
>
> 如果一个类不允许调用代码访问内部对象数据，只允许通过方法访问，这就是一种被称为[抽象化](https://en.wikipedia.org/wiki/Abstraction_(computer_science))的信息隐藏形式。 有些语言（例如Java）允许类明确地执行访问限制，例如用 `private` 关键字表示内部数据，用 `public` 关键字指定供类外代码使用的方法。 方法也可以被设计成公共的、私有的或中间层次的，如 `protected`（允许从同一个类和它的子类中访问，但不允许不同类的对象）。 在其他语言中（如Python），这只是通过惯例来执行（例如，`private`方法的名称可能以一个[下划线](https://en.wikipedia.org/wiki/Underscore)开头）。

### Encapsulation

[Encapsulation](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)) prevents external code from being concerned with the internal workings of an object.  This facilitates [code refactoring](https://en.wikipedia.org/wiki/Code_refactoring), for example allowing the author of the class to change how objects of  that class represent their data internally without changing any external code (as long as "public" method calls work the same way).  It also  encourages programmers to put all the code that is concerned with a  certain set of data in the same class, which organizes it for easy  comprehension by other programmers.  Encapsulation is a technique that  encourages [decoupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming)).

> [封装](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))防止外部代码关注一个对象的内部工作情况。 这有利于[代码重构](https://en.wikipedia.org/wiki/Code_refactoring)，例如，允许类的作者改变该类的对象在内部表示其数据的方式，而不改变任何外部代码（只要 "公共 "方法调用以同样的方式工作）。 它还鼓励程序员把所有与某组数据有关的代码放在同一个类中，这样可以组织起来，便于其他程序员的理解。 封装是一种鼓励[解耦](https://en.wikipedia.org/wiki/Coupling_(computer_programming))的技术。

### Composition, inheritance and delegation

Objects can contain other objects in their instance variables; this is known as [object composition](https://en.wikipedia.org/wiki/Object_composition).  For example, an object in the Employee class might contain (either  directly or through a pointer) an object in the Address class, in  addition to its own instance variables like "first_name" and "position".  Object composition is used to represent "has-a" relationships: every  employee has an address, so every Employee object has access to a place  to store an Address object (either directly embedded within itself, or  at a separate location addressed via a pointer).

Languages that support classes almost always support [inheritance](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)).  This allows classes to be arranged in a hierarchy that represents  "is-a-type-of" relationships.  For example, class Employee might inherit from class Person.  All the data and methods available to the parent  class also appear in the child class with the same names.  For example,  class Person might define variables "first_name" and "last_name" with  method "make_full_name()".  These will also be available in class  Employee, which might add the variables "position" and "salary".  This  technique allows easy re-use of the same procedures and data  definitions, in addition to potentially mirroring real-world  relationships in an intuitive way. Rather than utilizing database tables and programming subroutines, the developer utilizes objects the user  may be more familiar with: objects from their application domain.[[21\]](https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-21)

> 对象可以在其实例变量中包含其他对象；这被称为[对象组合](https://en.wikipedia.org/wiki/Object_composition)。 例如，Employee类中的一个对象可能包含（直接或通过一个指针）Address类中的一个对象，此外还有它自己的实例变量，如 "first_name "和 "position"。 对象组合被用来表示 "有-a "关系：每个雇员都有一个地址，所以每个雇员对象都可以访问一个地方来存储一个地址对象（可以直接嵌入自身，也可以在一个单独的位置通过指针寻址）。
>
> 支持类的语言几乎都支持[继承](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming))。 这允许类被安排在一个代表 "is-a-type-of "关系的层次结构中。 例如，类Employee可能继承自类Person。 父类可用的所有数据和方法也会以相同的名称出现在子类中。 例如，类Person可以定义变量 "first_name "和 "last_name "以及方法 "make_full_name()"。 这些也可以在Employee类中使用，Employee类可能会添加变量 "position "和 "salary"。 这种技术允许轻松重复使用相同的程序和数据定义，此外还可能以一种直观的方式反映现实世界的关系。开发者不是利用数据库表和编程子程序，而是利用用户可能更熟悉的对象：来自他们应用域的对象。

Subclasses can override the methods defined by superclasses. [Multiple inheritance](https://en.wikipedia.org/wiki/Multiple_inheritance) is allowed in some languages, though this can make resolving overrides complicated.  Some languages have special support for [mixins](https://en.wikipedia.org/wiki/Mixin), though in any language with multiple inheritance, a mixin is simply a  class that does not represent an is-a-type-of relationship.  Mixins are  typically used to add the same methods to multiple classes.  For  example, class UnicodeConversionMixin might provide a method  unicode_to_ascii() when included in class FileReader and class  WebPageScraper, which don't share a common parent.

[Abstract classes](https://en.wikipedia.org/wiki/Abstract_class) cannot be instantiated into objects; they exist only for the purpose of inheritance into other "concrete" classes that can be instantiated.  In Java, the `final` keyword can be used to prevent a class from being subclassed.

The doctrine of [composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance) advocates implementing has-a relationships using composition instead of inheritance.  For example, instead of inheriting from class Person,  class Employee could give each Employee object an internal Person  object, which it then has the opportunity to hide from external code  even if class Person has many public attributes or methods.  Some  languages, like [Go](https://en.wikipedia.org/wiki/Go_(programming_language)) do not support inheritance at all.

The "[open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle)" advocates that classes and functions "should be open for extension, but closed for modification".

[Delegation](https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming)) is another language feature that can be used as an alternative to inheritance.

> 子类可以覆盖超类所定义的方法。一些语言允许[多重继承](https://en.wikipedia.org/wiki/Multiple_inheritance)，尽管这可能使解决覆盖问题变得复杂。 一些语言对[混合体](https://en.wikipedia.org/wiki/Mixin)有特殊的支持，尽管在任何具有多重继承的语言中，混合体只是一个不代表is-a-type-of关系的类。 混合器通常用来给多个类添加相同的方法。 例如，当类UnicodeConversionMixin包含在类FileReader和类WebPageScraper中时，可能会提供一个方法unicode_to_ascii()，而这两个类并没有一个共同的父类。
>
> [抽象类](https://en.wikipedia.org/wiki/Abstract_class)不能被实例化为对象；它们的存在只是为了继承到其他可以被实例化的 "具体"类。 在Java中，可以使用`final`关键字来防止一个类被子类化。
>
> [组成大于继承](https://en.wikipedia.org/wiki/Composition_over_inheritance)的学说主张用组成而不是继承来实现有-a关系。 例如，Employee类可以给每个Employee对象一个内部的Person对象，而不是继承自Person类，这样它就有机会从外部代码中隐藏起来，即使Person类有许多公共属性或方法。 有些语言，如[Go](https://en.wikipedia.org/wiki/Go_(programming_language))根本不支持继承。
>
> [开放/封闭原则](https://en.wikipedia.org/wiki/Open/closed_principle) "主张类和函数 "应该对扩展开放，但对修改封闭"。
>
> [委托](https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming))是另一个可以用来替代继承的语言特性。

### Polymorphism

[Subtyping](https://en.wikipedia.org/wiki/Subtyping) – a form of [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) – is when calling code can be independent of which class in the  supported hierarchy it is operating on – the parent class or one of its  descendants.  Meanwhile, the same operation name among objects in an  inheritance hierarchy may behave differently.

For example, objects of type Circle and Square are derived from a common class called Shape.  The Draw function for each type of Shape  implements what is necessary to draw itself while calling code can  remain indifferent to the particular type of Shape being drawn.

This is another type of abstraction that simplifies code external to the class hierarchy and enables strong [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns).

> [子类型化](https://en.wikipedia.org/wiki/Subtyping) -- [多态性](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))的一种形式--是指调用代码可以独立于它在支持的层次结构中的哪个类上进行操作--父类或其子类之一。 同时，在一个继承层次结构中的对象之间，**相同的操作名称可能会有不同的表现**。
>
> 例如，Circle和Square类型的对象是由一个叫做Shape的普通类派生出来的。 每种类型的Shape的Draw函数都实现了绘制自身所需的功能，而调用代码可以对正在绘制的特定类型的Shape保持漠不关心。
>
> 这是另一种类型的抽象，它简化了类层次结构之外的代码，并实现了强大的[关注点分离](https://en.wikipedia.org/wiki/Separation_of_concerns)。

### Open recursion

In languages that support [open recursion](https://en.wikipedia.org/wiki/Open_recursion), object methods can call other methods on the same object (including  themselves), typically using a special variable or keyword called `this` or `self`.  This variable is *[late-bound](https://en.wikipedia.org/wiki/Name_binding)*; it allows a method defined in one class to invoke another method that is defined later, in some subclass thereof.

> 在支持[开放递归](https://en.wikipedia.org/wiki/Open_recursion)的语言中，对象方法可以调用同一对象上的其他方法（包括他们自己），通常使用一个特殊的变量或关键字，称为`this`或`self`。 这个变量是*[后期绑定](https://en.wikipedia.org/wiki/Name_binding)*；它允许一个定义在一个类中的方法调用另一个定义在后面的方法，在其某个子类中。

---

# Regular Expression

[wikipedia link](https://en.wikipedia.org/?curid=25717)

A **regular expression** (shortened as **regex** or **regexp**;[[1\]](https://en.wikipedia.org/?curid=25717#cite_note-1) sometimes referred to as **rational expression**[[2\]](https://en.wikipedia.org/?curid=25717#cite_note-Mitkov2003-2)[[3\]](https://en.wikipedia.org/?curid=25717#cite_note-Lawson2003-3)) is a sequence of [characters](https://en.wikipedia.org/wiki/Character_(computing)) that specifies a [search pattern](https://en.wikipedia.org/wiki/Pattern_matching) in [text](https://en.wikipedia.org/wiki/String_(computer_science)). Usually such patterns are used by [string-searching algorithms](https://en.wikipedia.org/wiki/String-searching_algorithm) for "find" or "find and replace" operations on [strings](https://en.wikipedia.org/wiki/String_(computer_science)), or for [input validation](https://en.wikipedia.org/wiki/Data_validation). Regular expression techniques are developed in [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science) and [formal language](https://en.wikipedia.org/wiki/Formal_language) theory.

> 一个**正则表达式**（简称**regex**或**regexp**；[[1]](https://en.wikipedia.org/?curid=25717#cite_note-1)有时被称为**正则表达式**[[2]](https://en.wikipedia.org/?curid=25717#cite_note-Mitkov2003-2)[[3]](https://en.wikipedia.org/?curid=25717#cite_note-Lawson2003-3)）是一串[字符](https://en.wikipedia.org/wiki/Character_(computer_science))，指定了[文本](https://en.wikipedia.org/wiki/Pattern_matching)中的一个[搜索模式](https://en.wikipedia.org/wiki/String_(computer_science))。通常这种模式被[字符串搜索算法](https://en.wikipedia.org/wiki/String-searching_algorithm)用于对[字符串](https://en.wikipedia.org/wiki/String_(computer_science))进行 "查找 "或 "查找和替换 "操作，或者用于[输入验证](https://en.wikipedia.org/wiki/Data_validation)。正则表达式技术是在[理论计算机科学](https://en.wikipedia.org/wiki/Theoretical_computer_science)和[形式语言](https://en.wikipedia.org/wiki/Formal_language)理论中开发的。

The concept of regular expressions began in the 1950s, when the American mathematician [Stephen Cole Kleene](https://en.wikipedia.org/wiki/Stephen_Cole_Kleene) formalized the concept of a [regular language](https://en.wikipedia.org/wiki/Regular_language). They came into common use with [Unix](https://en.wikipedia.org/wiki/Unix) text-processing utilities. Different [syntaxes](https://en.wikipedia.org/wiki/Syntax_(programming_languages)) for writing regular expressions have existed since the 1980s, one being the [POSIX](https://en.wikipedia.org/wiki/POSIX) standard and another, widely used, being the [Perl](https://en.wikipedia.org/wiki/Perl) syntax.

Regular expressions are used in [search engines](https://en.wikipedia.org/wiki/Search_engine), in search and replace dialogs of [word processors](https://en.wikipedia.org/wiki/Word_processor) and [text editors](https://en.wikipedia.org/wiki/Text_editor), in [text processing](https://en.wikipedia.org/wiki/Text_processing) utilities such as [sed](https://en.wikipedia.org/wiki/Sed) and [AWK](https://en.wikipedia.org/wiki/AWK), and in [lexical analysis](https://en.wikipedia.org/wiki/Lexical_analysis). Most [general-purpose programming languages](https://en.wikipedia.org/wiki/General-purpose_programming_language) support regex capabilities either natively or via [libraries](https://en.wikipedia.org/wiki/Library_(computing)), including [Python](https://en.wikipedia.org/wiki/Python_(programming_language)),[[4\]](https://en.wikipedia.org/?curid=25717#cite_note-4) [C](https://en.wikipedia.org/wiki/C_(programming_language)),[[5\]](https://en.wikipedia.org/?curid=25717#cite_note-5) [C++](https://en.wikipedia.org/wiki/C%2B%2B),[[6\]](https://en.wikipedia.org/?curid=25717#cite_note-6) [Java](https://en.wikipedia.org/wiki/Java_(programming_language)),[[7\]](https://en.wikipedia.org/?curid=25717#cite_note-7) [Rust](https://en.wikipedia.org/wiki/Rust_(programming_language)),[[8\]](https://en.wikipedia.org/?curid=25717#cite_note-8) [OCaml](https://en.wikipedia.org/wiki/OCaml),[[9\]](https://en.wikipedia.org/?curid=25717#cite_note-9) and [JavaScript](https://en.wikipedia.org/wiki/JavaScript).[[10\]](https://en.wikipedia.org/?curid=25717#cite_note-10)

> 正则表达式的概念始于20世纪50年代，当时美国数学家[Stephen Cole Kleene](https://en.wikipedia.org/wiki/Stephen_Cole_Kleene)正式提出了[正则语言](https://en.wikipedia.org/wiki/Regular_language) 的概念。它们随着[Unix](https://en.wikipedia.org/wiki/Unix)文本处理工具的出现而被普遍使用。自20世纪80年代以来，存在不同的用于编写正则表达式的[语法](https://en.wikipedia.org/wiki/Syntax_(programming_languages))，其中一个是[POSIX](https://en.wikipedia.org/wiki/POSIX)标准，另一个是[Perl](https://en.wikipedia.org/wiki/Perl)语法，被广泛使用。
>
> 正则表达式被用于[搜索引擎](https://en.wikipedia.org/wiki/Search_engine)、[文字处理器](https://en.wikipedia.org/wiki/Word_processor)和[文本编辑器](https://en.wikipedia.org/wiki/Text_editor)的搜索和替换对话框、[文本处理](https://en.wikipedia.org/wiki/Text_processing)工具，如[sed](https://en.wikipedia.org/wiki/Sed)和[AWK](https://en.wikipedia.org/wiki/AWK)，以及[词法分析](https://en.wikipedia.org/wiki/Lexical_analysis)中。大多数[通用编程语言](https://en.wikipedia.org/wiki/General-purpose_programming_language)或通过[库](https://en.wikipedia.org/wiki/Library_(computing))支持Rgex功能，包括[Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [[4]](https://en.wikipedia.org/?curid=25717#cite_note-4) [C](https://en.wikipedia.org/wiki/C_(programming_language)), [[5]](https://en.wikipedia.org/?curid=25717#cite_note-5) [C++](https://en.wikipedia. org/wiki/C%2B%2B), [[6]](https://en.wikipedia.org/?curid=25717#cite_note-6) [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [[7]](https://en.wikipedia.org/?curid=25717#cite_note-7) [Rust](https://en.wikipedia.org/wiki/Rust_(programming_language)), [[8]](https://en.wikipedia.org/?curid=25717#cite_note-8) [OCaml](https://en.wikipedia.org/wiki/OCaml), [[9]](https://en.wikipedia.org/?curid=25717#cite_note-9) 和 [JavaScript](https://en.wikipedia.org/wiki/JavaScript)。
>

## Patterns

The phrase *regular expressions*, or *regexes*, is often  used to mean the specific, standard textual syntax for representing  patterns for matching text, as distinct from the mathematical notation  described below. Each character in a regular expression (that is, each  character in the string describing its pattern) is either a [metacharacter](https://en.wikipedia.org/wiki/Metacharacter), having a special meaning, or a regular character that has a literal meaning. For example, in the regex `b.`, 'b' is a literal character that matches just 'b', while '.' is a  metacharacter that matches every character except a newline. Therefore,  this regex matches, for example, 'b%', or 'bx', or 'b5'. Together,  metacharacters and literal characters can be used to identify text of a  given pattern or process a number of instances of it. Pattern matches  may vary from a precise equality to a very general similarity, as  controlled by the metacharacters. For example, `.` is a very general pattern, `[a-z]` (match all lower case letters from 'a' to 'z') is less general and `b` is a precise pattern (matches just 'b'). The metacharacter syntax is  designed specifically to represent prescribed targets in a concise and  flexible way to direct the automation of text processing of a variety of input data, in a form easy to type using a standard [ASCII](https://en.wikipedia.org/wiki/ASCII) [keyboard](https://en.wikipedia.org/wiki/Computer_keyboard).

> 短语*正则表达式*，或*regexes*，经常被用来指具体的、标准的文本语法，用于表示匹配文本的模式，与下面描述的数学符号不同。正则表达式中的每个字符（即描述其模式的字符串中的每个字符）要么是具有特殊含义的[元字符](https://en.wikipedia.org/wiki/Metacharacter)，要么是具有**字面含义**的常规字符。例如，在正则表达式`b.`中，'b'是一个字面意义的字符，只匹配'b'，而'.'是一个**元字符**，匹配除换行（newline）之外的所有字符。因此，这个正则表达式匹配，例如，'b%'，或'bx'，或'b5'。元字符和常量字符一起可以用来识别给定模式的文本或处理它的一些实例。模式匹配可以从**精确的相等性**到非常**广泛的相似性**不等，由**元字符**控制。例如，`.` 是一个非常**广泛的**模式，`[a-z]`（匹配从 "a "到 "z "的所有小写字母）则不太广泛，`b` 是一个**精确的**模式（只匹配 "b"）。元字符语法是专门设计的，以简洁灵活的方式表示**规定的**目标，指导各种输入数据的**自动化文本处理**，其形式易于使用标准的[ASCII](https://en.wikipedia.org/wiki/ASCII)[键盘](https://en.wikipedia.org/wiki/Computer_keyboard)来输入。
>

A very simple case of a regular expression in this syntax is to locate a word spelled two different ways in a [text editor](https://en.wikipedia.org/wiki/Text_editor), the regular expression `seriali[sz]e` matches both "serialise" and "serialize". [Wildcard characters](https://en.wikipedia.org/wiki/Wildcard_character) also achieve this, but are more limited in what they can pattern, as they have fewer metacharacters and a simple language-base.

The usual context of wildcard characters is in [globbing](https://en.wikipedia.org/wiki/Glob_(programming)) similar names in a list of files, whereas regexes are usually employed  in applications that pattern-match text strings in general. For example, the regex `^[ \t]+|[ \t]+$` matches excess whitespace at the beginning or end of a line. An advanced regular expression that matches any numeral is `[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?`.

> 在这种语法中，正则表达式的一个非常简单的例子是在[文本编辑器](https://en.wikipedia.org/wiki/Text_editor)中**定位**一个单词的两种不同拼法，正则表达式`seriali[sz]e`同时匹配 "serialise "和 "serialize"。[通配符](https://en.wikipedia.org/wiki/Wildcard_character)也实现了这一点，但在它们能够模式化的内容方面受到更多限制，因为它们有较少的元字符和简单的语言基础。
>
> 通配符的通常情况是在[globbing](https://en.wikipedia.org/wiki/Glob_(programming))文件列表中的类似名字中使用，而regexes通常是在广泛的模式匹配文本字符串的应用中使用。例如，正则表达式`^[ \t]+|[ \t]+$`可以匹配行首或行尾的多余空白字符。匹配任何数字的高级正则表达式是`[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]? \d+)?`。

[![img](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Thompson-kleene-star.svg/220px-Thompson-kleene-star.svg.png)](https://en.wikipedia.org/wiki/File:Thompson-kleene-star.svg)

[Translating](https://en.wikipedia.org/wiki/Thompson's_construction_algorithm) the [Kleene star](https://en.wikipedia.org/wiki/Kleene_star)
(*s*\* means "zero or more of *s*")

A **regex processor** translates a regular expression in the above syntax into an internal representation that can be executed and matched against a [string](https://en.wikipedia.org/wiki/String_(computing)) representing the text being searched in. One possible approach is the [Thompson's construction algorithm](https://en.wikipedia.org/wiki/Thompson's_construction_algorithm) to construct a [nondeterministic finite automaton](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton) (NFA), which is then [made deterministic](https://en.wikipedia.org/wiki/Powerset_construction) and the resulting [deterministic finite automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) (DFA) is run on the target text string to recognize substrings that match the regular expression. The picture shows the NFA scheme `*N*(*s**)` obtained from the regular expression `*s**`, where *s* denotes a simpler regular expression in turn, which has already been [recursively](https://en.wikipedia.org/wiki/Recursion_(computer_science)) translated to the NFA *N*(*s*).

> 一个**regex处理器**将上述语法中的正则表达式翻译成可以执行的内部表示，并与代表被搜索文本的[字符串](https://en.wikipedia.org/wiki/String_(计算))相匹配。一种可能的方法是用[汤普森构造算法](https://en.wikipedia.org/wiki/Thompson's_construction_algorithm)构造一个[非确定性有限自动机](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton)(NFA)，然后将其[变成确定性的](https://en.wikipedia.org/wiki/Powerset_construction)，将得到的[确定性有限自动机](https://en.wikipedia.org/wiki/Deterministic_finite_automaton)(DFA)在目标文本字符串上运行以识别符合正则表达式的子串。图中显示了从正则表达式`*s**`得到的NFA方案`*N*(*s**)`，其中*s*依次表示一个更简单的正则表达式，它已经被[递归](https://en.wikipedia.org/wiki/Recursion_(computer_science))翻译成NFA *N*(*s*)。

## Basic concepts

A regular expression, often called a *pattern*, specifies a [set](https://en.wikipedia.org/wiki/Set_(computer_science)) of strings required for a particular purpose. A simple way to specify a finite set of strings is to list its [elements](https://en.wikipedia.org/wiki/Data_element) or members. However, there are often more concise ways: for example,  the set containing the three strings "Handel", "Händel", and "Haendel"  can be specified by the pattern `H(ä|ae?)ndel`; we say that this pattern *matches* each of the three strings. However, there can be many ways to write a  regular expression for the same set of strings: for example, `(Hän|Han|Haen)del` also specifies the same set of three strings in this example.

Most formalisms provide the following operations to construct regular expressions.

> 正则表达式，通常被称为*模式*，指定了一个特定目的所需的字符串的[集合](https://en.wikipedia.org/wiki/Set_(computer_science))。指定一个有限字符串集的简单方法是列出其[元素](https://en.wikipedia.org/wiki/Data_element)或成员。然而，通常有更简洁的方法：例如，包含 "Handel"、"Händel "和 "Haendel "三个字符串的集合可以由模式`H(ä|ae?)ndel`指定；我们说这个模式*匹配*这三个字符串中的每一个。然而，对于同一组字符串，可以有很多方法来编写正则表达式：例如，`(Hän|Han|Haen)del`在这个例子中也指定了同一组的三个字符串。
>
> 大多数形式主义提供了以下操作来构造正则表达式。

- Boolean "or"

  A [vertical bar](https://en.wikipedia.org/wiki/Vertical_bar) separates alternatives. For example, `gray|grey` can match "gray" or "grey".

- Grouping

  [Parentheses](https://en.wikipedia.org/wiki/Parentheses) are used to define the scope and precedence of the [operators](https://en.wikipedia.org/wiki/Operator_(programming)) (among other uses). For example, `gray|grey` and `gr(a|e)y` are equivalent patterns which both describe the set of "gray" or "grey".

- Quantification

  A [quantifier](https://en.wikipedia.org/wiki/Quantifier_(linguistics)) after an element (such as a [token](https://en.wikipedia.org/wiki/Lexical_analysis#Token), character, or group) specifies how many times the preceding element is allowed to repeat. The most common quantifiers are the [question mark](https://en.wikipedia.org/wiki/Question_mark) `?`, the [asterisk](https://en.wikipedia.org/wiki/Asterisk) `*` (derived from the [Kleene star](https://en.wikipedia.org/wiki/Kleene_star)), and the [plus sign](https://en.wikipedia.org/wiki/Plus_sign) `+` ([Kleene plus](https://en.wikipedia.org/wiki/Kleene_plus)).

  > - 布尔型 "或"
  >
  >   一个[竖条](https://en.wikipedia.org/wiki/Vertical_bar)分隔了备选方案。例如，`gray|grey`可以匹配 "gray"或 "grey"。
  >
  > - 分组
  >
  >   [括号](https://en.wikipedia.org/wiki/Parentheses)用于明确[运算符](https://en.wikipedia.org/wiki/Operator_(编程))的范围和优先级(还有其他用途)。例如，`gray|grey`和`gr(a|e)y`是等价的模式，都是描述 "gray "或 "grey "的集合。
  >
  > - 量词
  >
  >   在一个元素（如[token](https://en.wikipedia.org/wiki/Lexical_analysis#Token)、字符或组）后面的[量词](https://en.wikipedia.org/wiki/Quantifier_(linguistics))规定了前面的元素允许重复多少次。最常见的量词是[问号](https://en.wikipedia.org/wiki/Question_mark)`?`，[星号](https://en.wikipedia.org/wiki/Asterisk)`*`（源自[克莱因星](https://en.wikipedia.org/wiki/Kleene_star)），以及[加号](https://en.wikipedia.org/wiki/Plus_sign)`+`（[克莱因加](https://en.wikipedia.org/wiki/Kleene_plus)）。

  | `?`                                                          | The question mark indicates *zero or one* occurrences of the preceding element. For example, `colou?r` matches both "color" and "colour". |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | `*`                                                          | The asterisk indicates *zero or more* occurrences of the preceding element. For example, `ab*c` matches "ac", "abc", "abbc", "abbbc", and so on. |
  | `+`                                                          | The plus sign indicates *one or more* occurrences of the preceding element. For example, `ab+c` matches "abc", "abbc", "abbbc", and so on, but not "ac". |
  | `{n}`[[26\]](https://en.wikipedia.org/?curid=25717#cite_note-grep-26) | The preceding item is matched exactly *n* times.             |
  | `{min,}`[[26\]](https://en.wikipedia.org/?curid=25717#cite_note-grep-26) | The preceding item is matched *min* or more times.           |
  | `{,max}`[[26\]](https://en.wikipedia.org/?curid=25717#cite_note-grep-26) | The preceding item is matched up to *max* times.             |
  | `{min,max}`[[26\]](https://en.wikipedia.org/?curid=25717#cite_note-grep-26) | The preceding item is matched at least *min* times, but not more than *max* times. |

- Wildcard

The wildcard `.` matches any character. For example, `a.b` matches any string that contains an "a", and then any character and then "b"; and `a.*b` matches any string that contains an "a", and then the character "b" at some later point.

These constructions can be combined to form arbitrarily complex  expressions, much like one can construct arithmetical expressions from  numbers and the operations +, −, ×, and ÷.

The precise [syntax](https://en.wikipedia.org/wiki/Syntax) for regular expressions varies among tools and with context; more detail is given in [§ Syntax](https://en.wikipedia.org/?curid=25717#Syntax).

> - 通配符
>
> 通配符`.`可以匹配**任何字符**。例如，`a.b`匹配任何包含 "a"，然后是任何字符和 "b "的字符串；`a.*b`匹配任何包含 "a"，然后是 "b "字符在最后的字符串。
>
> 这些结构可以组合成任意复杂的表达式，就像人们可以从数字和+、-、×、÷的运算中构建算术表达式一样。
>
> 正则表达式的精确[语法](https://en.wikipedia.org/wiki/Syntax)因工具和环境而异；更多细节见[§ 语法](https://en.wikipedia.org/?curid=25717#Syntax) 。

## Formal language theory

Regular expressions describe [regular languages](https://en.wikipedia.org/wiki/Regular_language) in [formal language theory](https://en.wikipedia.org/wiki/Formal_language). They have the same expressive power as [regular grammars](https://en.wikipedia.org/wiki/Regular_grammar).

> 正则表达式描述了[形式语言理论](https://en.wikipedia.org/wiki/Regular_language)中的[正则语言](https://en.wikipedia.org/wiki/Formal_language)。它们具有与[正则语法](https://en.wikipedia.org/wiki/Regular_grammar)相同的表达能力。

### Formal definition

Regular expressions consist of constants, which denote sets of strings, and  operator symbols, which denote operations over these sets. The following definition is standard, and found as such in most textbooks on formal  language theory.[[27\]](https://en.wikipedia.org/?curid=25717#cite_note-HopcroftMotwaniUllman01-27)[[28\]](https://en.wikipedia.org/?curid=25717#cite_note-28) Given a finite [alphabet](https://en.wikipedia.org/wiki/Alphabet_(computer_science)) Σ, the following constants are defined as regular expressions:

- (*empty set*) ∅ denoting the set ∅.
- (*[empty string](https://en.wikipedia.org/wiki/Empty_string)*) ε denoting the set containing only the "empty" string, which has no characters at all.
- (*[literal character](https://en.wikipedia.org/wiki/String_literal)*) `a` in Σ denoting the set containing only the character *a*.

Given regular expressions R and S, the following operations over them are defined to produce regular expressions:

- (*[concatenation](https://en.wikipedia.org/wiki/Concatenation)*) `(RS)` denotes the set of strings that can be obtained by concatenating a  string accepted by R and a string accepted by S (in that order). For  example, let R denote {"ab", "c"} and S denote {"d", "ef"}. Then, `(RS)` denotes {"abd", "abef", "cd", "cef"}.
- (*[alternation](https://en.wikipedia.org/wiki/Alternation_(formal_language_theory))*) `(R|S)` denotes the [set union](https://en.wikipedia.org/wiki/Set_union) of sets described by R and S. For example, if R describes {"ab", "c"} and S describes {"ab", "d", "ef"}, expression `(R|S)` describes {"ab", "c", "d", "ef"}.
- (*[Kleene star](https://en.wikipedia.org/wiki/Kleene_star)*) `(R*)` denotes the smallest [superset](https://en.wikipedia.org/wiki/Subset) of the set described by *R* that contains ε and is [closed](https://en.wikipedia.org/wiki/Closure_(mathematics)) under string concatenation. This is the set of all strings that can be  made by concatenating any finite number (including zero) of strings from the set described by R. For example, if R denotes {"0", "1"}, `(R*)` denotes the set of all finite [binary strings](https://en.wikipedia.org/wiki/Binary_string) (including the empty string). If R denotes {"ab", "c"}, `(R*)` denotes {ε, "ab", "c", "abab", "abc", "cab", "cc", "ababab", "abcab", ... }.

To avoid parentheses it is assumed that the Kleene star has the  highest priority, then concatenation and then alternation. If there is  no ambiguity then parentheses may be omitted. For example, `(ab)c` can be written as `abc`, and `a|(b(c*))` can be written as `a|bc*`. Many textbooks use the symbols ∪, +, or ∨ for alternation instead of the vertical bar.

> 正则表达式由**常数**和**运算符**组成，前者表示**字符串的集合**，后者表示对这些集合的**运算**。下面的定义是标准的，在大多数形式语言理论的教科书中都可以找到。[[27]](https://en.wikipedia.org/?curid=25717#cite_note-HopcroftMotwaniUllman01-27)[[28]](https://en.wikipedia.org/?curid=25717#cite_note-28) 给定一个有限的[字母表](https://en.wikipedia.org/wiki/Alphabet_(computer_science))Σ，以下常数被定义为正则表达式：
>
> - (*空集*) ∅表示∅的集合。
> - (*[空字符串](https://en.wikipedia.org/wiki/Empty_string)*) ε表示只包含 "空" 字符串的集合，它没有任何字符。
> - (*[字面字符](https://en.wikipedia.org/wiki/String_literal)*) `a`在Σ中表示只包含字符*a*的集合。
>
> 给出正则表达式R和S，在它们上面定义了以下操作，以产生正则表达式：
>
> - (*[concatenation](https://en.wikipedia.org/wiki/Concatenation)*) `(RS)`表示通过连接R接受的字符串和S接受的字符串（按顺序）可以得到的字符串的集合。例如，让R表示{"ab", "c"}，S表示{"d", "ef"}。那么，`(RS)`表示{"abd", "abef", "cd", "cef"}。
> - (*[供选择的](https://en.wikipedia.org/wiki/Alternation_(formal_language_theory))*) `(R|S)`表示R和S所描述的集合的[集合联合](https://en.wikipedia.org/wiki/Set_union)。例如，如果R描述{"ab", "c"}，S描述{"ab", "d", "ef"}，表达`(R|S)`描述{"ab", "c", "d", "ef"}.
> - (*[Kleene star](https://en.wikipedia.org/wiki/Kleene_star)*) `(R*)`表示*R*所描述的集合中最小的[超集](https://en.wikipedia.org/wiki/Subset)，它包含ε并且在字符串连接下是[封闭的](https://en.wikipedia.org/wiki/Closure_(数学))。例如，如果R表示{"0", "1"}，`(R*)`表示所有有限的[二进制字符串](https://en.wikipedia.org/wiki/Binary_string)（包括空字符串）的集合。如果R表示{"ab", "c"}, `(R*)`表示{ε, "ab", "c", "abab", "abc", "cab", "cc", "ababab", "abcab", ... }.
>
> 为了避免括号，我们假定Kleene星具有**最高的优先权**，然后是**连接**，然后是**供选择的**。如果没有歧义，则可以省略括号。例如，`(ab)c`可以写成`abc`，`a|(b(c*))`可以写成`a|bc*`。许多教科书用符号∪，+，或∨来代替竖条的可供选择。
>

**Examples:**

- `a|b*` denotes {ε, "a", "b", "bb", "bbb", ...}
- `(a|b)*` denotes the set of all strings with no symbols  other than "a" and "b", including the empty string: {ε, "a", "b", "aa",  "ab", "ba", "bb", "aaa", ...}
- `ab*(c|ε)` denotes the set of strings starting with "a",  then zero or more "b"s and finally optionally a "c": {"a", "ac", "ab",  "abc", "abb", "abbc", ...}
- `(0|(1(01*0)*1))*` denotes the set of binary numbers that are multiples of 3: { ε, "0", "00", "11", "000", "011", "110", "0000",  "0011", "0110", "1001", "1100", "1111", "00000", ... }

> - `a|b*`表示{ε, "a", "b", "bb", "bbb", ...}。
> - `(a|b)*`表示除了 "a"和 "b"之外没有其他符号的所有字符串的集合，包括空字符串。{ε, "a", "b", "aa", "ab", "ba", "bb", "aaa", ...}
> - `ab*(c|ε)`表示以 "a "开始，然后是零个或多个 "b"，最后是一个 "c"的字符串的集合。{"a", "ac", "ab", "abc", "abb", "abbc", ...}
> - `(0|(1(01*0)*1))*`表示二进制数乘以3的集合：{ ε, "0", "00", "11", "000", "011", "110", "0000", "0011", "0110", "1001", "1100", "1111", "00000", ... }

### Expressive power and compactness

The formal definition of regular expressions is minimal on purpose, and avoids defining `?` and `+`—these can be expressed as follows: `a+` = `aa*`, and `a?` = `(a|ε)`. Sometimes the [complement](https://en.wikipedia.org/wiki/Set_complement) operator is added, to give a *generalized regular expression*; here *Rc* matches all strings over Σ* that do not match *R*. In principle, the complement operator is redundant, because it doesn't  grant any more expressive power. However, it can make a regular  expression much more concise—eliminating a single complement operator  can cause a [double exponential](https://en.wikipedia.org/wiki/Double_exponential_function) blow-up of its length.[[29\]](https://en.wikipedia.org/?curid=25717#cite_note-29)[[30\]](https://en.wikipedia.org/?curid=25717#cite_note-30)[[31\]](https://en.wikipedia.org/?curid=25717#cite_note-31)

> 正则表达式的正式定义是有目的地最小化的，避免了对`?`和`+`的定义--这些可以表达如下：`a+`=`aa*`，`a?`=`（a|ε）`。有时会添加[补](https://en.wikipedia.org/wiki/Set_complement)运算符，以得到一个*广义的正则表达式*；这里*Rc*匹配Σ\*上所有不匹配*R*的字符串。原则上，补码运算符是多余的，因为它没有赋予任何更多的表达能力。然而，它可以使正则表达式更加简洁--取消一个补码运算符会导致其长度出现[双指数](https://en.wikipedia.org/wiki/Double_exponential_function)爆炸。[[29\]](https://en.wikipedia.org/?curid=25717#cite_note-29)[[30\]](https://en.wikipedia.org/?curid=25717#cite_note-30)[[31\]](https://en.wikipedia.org/?curid=25717#cite_note-31)

Regular expressions in this sense can express the regular languages, exactly the class of languages accepted by [deterministic finite automata](https://en.wikipedia.org/wiki/Deterministic_finite_automata). There is, however, a significant difference in compactness. Some  classes of regular languages can only be described by deterministic  finite automata whose size grows [exponentially](https://en.wikipedia.org/wiki/Exponential_growth) in the size of the shortest equivalent regular expressions. The standard example here is the languages *Lk* consisting of all strings over the alphabet {*a*,*b*} whose *k*th-from-last letter equals *a*. On the one hand, a regular expression describing *L*4 is given by (a|b)*a(a|b)(a|b)(a|b).

> 这种意义上的正则表达式可以表达正则语言，正是[确定性有限自动机](https://en.wikipedia.org/wiki/Deterministic_finite_automata)所接受的那类语言。然而，在紧凑性方面有一个明显的区别。有些类别的正则语言只能由**确定性有限自动机**来描述，其大小在最短的等价正则表达式的大小中[呈指数增长](https://en.wikipedia.org/wiki/Exponential_growth)。这里的标准例子是由字母表{*a*,*b*}上的所有字符串组成的语言*Lk*，其*k*的最后一个字母等于*a*。一方面，描述*L*4的正则表达式由(a|b)*a(a|b)(a|b)(a|b)给出。

Generalizing this pattern to *Lk* gives the expression: (a|b)*a(a|b)(a|b)...(a|b) ((a|b)(a|b)...(a|b) is k-1 times)

> 将这一模式推广到*Lk*，可以得到表达式：(a|b)*a(a|b)(a|b)...(a|b)（(a|b)(a|b)...(a|b)是k-1次）

On the other hand, it is known that every deterministic finite automaton accepting the language *Lk* must have at least 2*k* states. Luckily, there is a simple mapping from regular expressions to the more general [nondeterministic finite automata](https://en.wikipedia.org/wiki/Nondeterministic_finite_automata) (NFAs) that does not lead to such a blowup in size; for this reason  NFAs are often used as alternative representations of regular languages. NFAs are a simple variation of the type-3 [grammars](https://en.wikipedia.org/wiki/Formal_grammar) of the [Chomsky hierarchy](https://en.wikipedia.org/wiki/Chomsky_hierarchy).[[27\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-HopcroftMotwaniUllman01-27)

> 另一方面，众所周知，每个接受语言*Lk*的确定性有限自动机必须至少有2*k*个状态。幸运的是，从正则表达式到更普遍的[非确定性有限自动机](https://en.wikipedia.org/wiki/Nondeterministic_finite_automata) (NFAs)有一个简单的映射，不会导致这样的规模爆炸；由于这个原因，NFAs经常被用作正则语言的替代表示。NFA是[乔姆斯基层次结构](https://en.wikipedia.org/wiki/Chomsky_hierarchy)的第三类[语法](https://en.wikipedia.org/wiki/Formal_grammar)的简单变体。[[27]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-HopcroftMotwaniUllman01-27)
>

In the opposite direction, there are many languages easily  described by a DFA that are not easily described by a regular  expression. For instance, determining the validity of a given [ISBN](https://en.wikipedia.org/wiki/ISBN) requires computing the modulus of the integer base 11, and can be  easily implemented with an 11-state DFA. However, a regular expression  to answer the same problem of divisibility by 11 is at least multiple  megabytes in length.[*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*]

> 在相反的方向上，有许多语言很容易用DFA来描述，但却不容易用正则表达式来描述。例如，确定一个给定的[ISBN](https://en.wikipedia.org/wiki/ISBN)的有效性需要计算整数基数11的模数，可以很容易地用一个11态DFA来实现。然而，回答同样的除以11的问题的正则表达式至少要有多兆字节的长度。[*[需要引用](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*]

Given a regular expression, [Thompson's construction algorithm](https://en.wikipedia.org/wiki/Thompson's_construction_algorithm) computes an equivalent nondeterministic finite automaton. A conversion in the opposite direction is achieved by [Kleene's algorithm](https://en.wikipedia.org/wiki/Kleene's_algorithm).

> 给定一个正则表达式，[Thompson的构造算法](https://en.wikipedia.org/wiki/Thompson's_construction_algorithm)会计算出一个等价的非确定性有限自动机。相反方向的转换是由[Kleene's algorithm](https://en.wikipedia.org/wiki/Kleene's_algorithm)实现的。

Finally, it is worth noting that many real-world "regular  expression" engines implement features that cannot be described by the  regular expressions in the sense of formal language theory; rather, they implement *regexes*. See [below](https://en.wikipedia.org/wiki/Regular_expression#Patterns_for_non-regular_languages) for more on this.

> 最后，值得注意的是，许多现实世界的 "正则表达式 "引擎实现的功能不能由形式语言理论意义上的正则表达式来描述；相反，它们实现了*regexes*。关于这一点，见[下文](https://en.wikipedia.org/wiki/Regular_expression#Patterns_for_non-regular_languages)。
>



### Deciding equivalence of regular expressions

As seen in many of the examples above, there is more than one way to construct a regular expression to achieve the same results.

It is possible to write an [algorithm](https://en.wikipedia.org/wiki/Algorithm) that, for two given regular expressions, decides whether the described  languages are equal; the algorithm reduces each expression to a [minimal deterministic finite state machine](https://en.wikipedia.org/wiki/Minimal_deterministic_finite_state_machine), and determines whether they are [isomorphic](https://en.wikipedia.org/wiki/Isomorphism) (equivalent).

Algebraic laws for regular expressions can be obtained using a  method by Gischer which is best explained along an example: In order to  check whether (*X*+*Y*)* and (*X** *Y**)* denote the same regular language, for all regular expressions *X*, *Y*, it is necessary and sufficient to check whether the particular regular expressions (*a*+*b*)* and (*a** *b**)* denote the same language over the alphabet Σ={*a*,*b*}. More generally, an equation *E*=*F* between regular-expression terms with variables holds if, and only if,  its instantiation with different variables replaced by different symbol  constants holds.[[32\]](https://en.wikipedia.org/?curid=25717#cite_note-32)[[33\]](https://en.wikipedia.org/?curid=25717#cite_note-33)

Every regular expression can be written solely in terms of the [Kleene star](https://en.wikipedia.org/wiki/Kleene_star) and [set unions](https://en.wikipedia.org/wiki/Union_(set_theory)). This is a surprisingly difficult problem. As simple as the regular  expressions are, there is no method to systematically rewrite them to  some normal form. The lack of axiom in the past led to the [star height problem](https://en.wikipedia.org/wiki/Star_height_problem). In 1991, [Dexter Kozen](https://en.wikipedia.org/wiki/Dexter_Kozen) axiomatized regular expressions as a [Kleene algebra](https://en.wikipedia.org/wiki/Kleene_algebra#History), using equational and [Horn clause](https://en.wikipedia.org/wiki/Horn_clause) axioms.[[34\]](https://en.wikipedia.org/?curid=25717#cite_note-34) Already in 1964, Redko had proved that no finite set of purely  equational axioms can characterize the algebra of regular languages.[[35\]](https://en.wikipedia.org/?curid=25717#cite_note-35)

> 正如在上面的许多例子中所看到的那样，有不止一种方法可以构建正则表达式来实现相同的结果。
>
> 可以写一个[算法](https://en.wikipedia.org/wiki/Algorithm)，对于两个给定的正则表达式，决定所描述的语言是否相等；该算法将每个表达式还原为一个[最小确定的有限状态机](https://en.wikipedia.org/wiki/Minimal_deterministic_finite_state_machine)，并决定它们是否[同构](https://en.wikipedia.org/wiki/Isomorphism)（等价）。
>
> 正则表达式的代数定律可以用Gischer的方法得到，最好用一个例子来解释。为了检查(*X*+*Y*)\*和(*X*\* *Y*\*)\*是否表示相同的正则语言，对于所有的正则表达式*X*, *Y*来说，检查特定的正则表达式(*a*+*b*)\*和(*a*\* *b*\*)\*是否表示字母表Σ={*a*,*b*}上的相同语言是必要且充分的。更一般地说，在带有变量的正则表达式条款之间，当且仅当其用不同的符号常数替代不同的变量的实例化成立时，*E*=*F*才成立。[[32]](https://en.wikipedia.org/?curid=25717#cite_note-32)[[33]](https://en.wikipedia.org/?curid=25717#cite_note-33)
>
> 每个正则表达式都可以只用[Kleene star](https://en.wikipedia.org/wiki/Kleene_star)和[set unions](https://en.wikipedia.org/wiki/Union_(set_theory))来写。这是一个令人惊讶的困难问题。尽管正则表达式很简单，但没有任何方法可以将它们系统地改写成某种正常形式。过去由于缺乏公理，导致了[明星高度问题](https://en.wikipedia.org/wiki/Star_height_problem)。1991年，[Dexter Kozen](https://en.wikipedia.org/wiki/Dexter_Kozen)将正则表达式公理化为[Kleene代数](https://en.wikipedia.org/wiki/Kleene_algebra#History)，使用了等价和[Horn条款](https://en.wikipedia.org/wiki/Horn_clause)公理。[[34/]](https://en.wikipedia.org/?curid=25717#cite_note-34) 早在1964年，Redko就已经证明，没有一组有限的纯等价公理可以描述正则语言的代数学。

## Syntax

A regex *pattern* matches a target *string*. The pattern is composed of a sequence of *atoms*. An atom is a single point within the regex pattern which it tries to  match to the target string. The simplest atom is a literal, but grouping parts of the pattern to match an atom will require using `( )` as metacharacters. Metacharacters help form: *atoms*; *quantifiers* telling how many atoms (and whether it is a [*greedy* quantifier](https://en.wikipedia.org/?curid=25717#Lazy_matching) or not); a logical OR character, which offers a set of alternatives,  and a logical NOT character, which negates an atom's existence; and  backreferences to refer to previous atoms of a completing pattern of  atoms. A match is made, not when all the atoms of the string are  matched, but rather when all the pattern atoms in the regex have  matched. The idea is to make a small pattern of characters stand for a  large number of possible strings, rather than compiling a large list of  all the literal possibilities.

Depending on the regex processor there are about fourteen metacharacters, characters that may or may not have their [literal](https://en.wikipedia.org/wiki/Literal_(computer_programming)) character meaning, depending on context, or whether they are "escaped", i.e. preceded by an [escape sequence](https://en.wikipedia.org/wiki/Escape_sequence), in this case, the backslash `\`. Modern and POSIX extended regexes use metacharacters more often than their literal meaning, so to avoid "backslash-osis" or [leaning toothpick syndrome](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome) it makes sense to have a metacharacter escape to a literal mode; but  starting out, it makes more sense to have the four bracketing  metacharacters `( )` and `{ }` be primarily  literal, and "escape" this usual meaning to become metacharacters.  Common standards implement both. The usual metacharacters are ` {}[]()^$.|*+?` and `\`. The usual characters that become metacharacters when escaped are `dswDSW` and `N`.

> 一个regex *pattern* 匹配一个目标*string*。模式是由一连串的*原子*组成。原子是指在regex模式中的一个点，它试图与目标字符串匹配。最简单的原子是一个**字面常量**，但是将模式的一部分分组来匹配一个原子需要使用`()`作为**元字符**。元字符有助于形成：*原子*；告诉多少个原子的*量词*（以及是否是[*greedy*量词](https://en.wikipedia.org/?curid=25717#Lazy_matching))；逻辑OR字符，提供一组备选方案，以及逻辑NOT字符，否定一个原子的存在；以及反向引用，参考一个完整的原子模式的前一个原子。匹配不是在字符串的所有原子都被匹配时进行的，而是在regex中的所有模式原子都被匹配时进行的。这样做的目的是使一个小的字符模式代表大量可能的字符串，而不是编制一个所有文字可能性的大列表。
>
> 根据不同的正则处理器，有大约14个**元字符**，这些字符可能有也可能没有它们的[字面常量](https://en.wikipedia.org/wiki/Literal_(computer_programming))，这取决于语境，或者它们是否被"转义"，即前面有一个[转义序列](https://en.wikipedia.org/wiki/Escape_sequence)，在这里，反斜杠`\`。现代和POSIX扩展的正则使用元字符的频率高于其字面常量，所以为了避免 "反斜杠症 "或[倾斜牙签综合症](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome)，让元字符转义为字面常量模式是有意义的；但是一开始，让四个括号内的元字符`( )`和`{ }`主要是字面常量，并"转义"这一普通意义，成为元字符，则更有意义。 通用标准实现了这两点。通常的元字符是`{}[]()^$.|*+?`和`\`。转义后成为元字符的普通字符是`dswDSW`和`N`。

### Delimiters

When entering a regex in a programming language, they may be represented as a usual string literal, hence usually quoted; this is common in C, Java,  and Python for instance, where the regex `re` is entered as `"re"`. However, they are often written with slashes as [delimiters](https://en.wikipedia.org/wiki/Delimiter), as in `/re/` for the regex `re`. This originates in [ed](https://en.wikipedia.org/wiki/Ed_(text_editor)), where `/` is the editor command for searching, and an expression `/re/` can be used to specify a range of lines (matching the pattern), which  can be combined with other commands on either side, most famously `g/re/p` as in [grep](https://en.wikipedia.org/wiki/Grep) ("global regex print"), which is included in most [Unix](https://en.wikipedia.org/wiki/Unix)-based operating systems, such as [Linux](https://en.wikipedia.org/wiki/Linux) distributions. A similar convention is used in [sed](https://en.wikipedia.org/wiki/Sed), where search and replace is given by `s/re/replacement/` and patterns can be joined with a comma to specify a range of lines as in `/re1/,/re2/`. This notation is particularly well known due to its use in [Perl](https://en.wikipedia.org/wiki/Perl), where it forms part of the syntax distinct from normal string literals. In some cases, such as sed and Perl, alternative delimiters can be used to avoid collision with contents, and to avoid having to escape  occurrences of the delimiter character in the contents. For example, in  sed the command `s,/,X,` will replace a `/` with an `X`, using commas as delimiters.

> 当在编程语言中输入一个gex时，它们可以被表示为普通的字符串**字面常量**，因此通常**有引号**；这在C、Java和Python中很常见，例如正则中的 `re`被输入为`"re"`。然而，它们通常用斜线写成[delimiters](https://en.wikipedia.org/wiki/Delimiter)，如在`/re/`中输入的是正则`re`。这起源于[ed](https://en.wikipedia.org/wiki/Ed_(text_editor))，其中`/`是用于搜索的编辑器命令，表达式`/re/`可以用来指定一个行的范围（匹配模式），它可以与两边的其他命令相结合，最有名的是[grep](https://en.wikipedia.org/wiki/Grep)中的`g/re/p`（"全局正则打印"），它包含在大多数基于[Unix](https://en.wikipedia.org/wiki/Unix)的操作系统，如[Linux](https://en.wikipedia.org/wiki/Linux) 发行本中。在[sed](https://en.wikipedia.org/wiki/Sed)中使用了类似的约定，搜索和替换由`s/re/replacement/`给出，模式可以用逗号连接以指定行的范围，如`re/1/,/re2/`。这种符号由于在[Perl](https://en.wikipedia.org/wiki/Perl)中的使用而特别有名，在那里它构成了不同于普通字符串字面的语法的一部分。在某些情况下，比如sed和Perl，可以使用替代的定界符来避免与内容相冲突，并避免在内容中转义定界符的出现。例如，在sed中，命令`s,/,X,`将用`X`替换`/`，使用逗号作为分隔符。

### Standards

The [IEEE](https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers) [POSIX](https://en.wikipedia.org/wiki/POSIX) standard has three sets of compliance: **BRE** (Basic Regular Expressions),[[36\]](https://en.wikipedia.org/?curid=25717#cite_note-36) **ERE** (Extended Regular Expressions), and **SRE** (Simple Regular Expressions). SRE is [deprecated](https://en.wikipedia.org/wiki/Deprecation),[[37\]](https://en.wikipedia.org/?curid=25717#cite_note-37) in favor of BRE, as both provide [backward compatibility](https://en.wikipedia.org/wiki/Backward_compatibility). The subsection below covering the *character classes* applies to both BRE and ERE.

BRE and ERE work together. ERE adds `?`, `+`, and `|`, and it removes the need to escape the metacharacters `( )` and `{ }`, which are *required* in BRE. Furthermore, as long as the POSIX standard syntax for regexes  is adhered to, there can be, and often is, additional syntax to serve  specific (yet POSIX compliant) applications. Although POSIX.2 leaves  some implementation specifics undefined, BRE and ERE provide a  "standard" which has since been adopted as the default syntax of many  tools, where the choice of BRE or ERE modes is usually a supported  option. For example, [GNU](https://en.wikipedia.org/wiki/GNU) `grep` has the following options: "`grep -E`" for ERE, and "`grep -G`" for BRE (the default), and "`grep -P`" for [Perl](https://en.wikipedia.org/wiki/Perl) regexes.

Perl regexes have become a de facto standard, having a rich and  powerful set of atomic expressions. Perl has no "basic" or "extended"  levels. As in POSIX EREs, `( )` and `{ }` are  treated as metacharacters unless escaped; other metacharacters are known to be literal or symbolic based on context alone. Additional  functionality includes [lazy matching](https://en.wikipedia.org/?curid=25717#Lazy_matching), [backreferences](https://en.wikipedia.org/?curid=25717#backreferences), named capture groups, and [recursive](https://en.wikipedia.org/wiki/Recursion_(computer_science)) patterns.

> [IEEE](https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers) [POSIX](https://en.wikipedia.org/wiki/POSIX)标准有三套标准。**BRE**（基本正则表达式），[[36]](https://en.wikipedia.org/?curid=25717#cite_note-36) **ERE**（扩展正则表达式），以及**SRE**（简单正则表达式）。SRE是[废弃的](https://en.wikipedia.org/wiki/Deprecation)，[[37]](https://en.wikipedia.org/?curid=25717#cite_note-37)，以支持BRE，因为两者都提供[向后兼容](https://en.wikipedia.org/wiki/Backward_compatibility)。下面涉及*字符类的小节*适用于BRE和ERE。
>
> BRE和ERE一起工作。ERE增加了`?`、`+`和`|`，并且取消了转义元字符`( )`"和`{ }`的需要，这在BRE中是*必须的*。此外，只要遵守POSIX的标准语法，就可以有，而且经常有额外的语法来服务于特定的（但符合POSIX标准的）应用。尽管**POSIX.2**没有定义一些实施细节，但BRE和ERE提供了一个 "标准"，后来被作为许多工具的默认语法，其中BRE或ERE模式的选择通常是一个支持的选项。例如，[GNU](https://en.wikipedia.org/wiki/GNU) `grep`有以下选项。"`grep -E`"用于ERE，"`grep -G`"用于BRE（默认），"`grep -P`"用于[Perl](https://en.wikipedia.org/wiki/Perl) regexes。
>
> Perl regexes已经成为事实上的标准，它有一套丰富而强大的原子表达式。Perl没有"基本"或"扩展"级别。与POSIX EREs一样，`( )`和`{ }`被视为元字符，除非被转义；其他元字符仅根据上下文就可以知道是字面常量的还是符号的。额外的功能包括[懒惰匹配](https://en.wikipedia.org/?curid=25717#Lazy_matching)、[反向引用](https://en.wikipedia.org/?curid=25717#backreferences)、命名的捕获组和[递归](https://en.wikipedia.org/wiki/Recursion_(computer_science))模式。

#### POSIX basic and extended

In the [POSIX](https://en.wikipedia.org/wiki/POSIX) standard, Basic Regular Syntax (**BRE**) requires that the [metacharacters](https://en.wikipedia.org/wiki/Metacharacter)`( )` and `{ }` be designated `\(\)` and `\{\}`, whereas Extended Regular Syntax (**ERE**) does not.

> 在[POSIX](https://en.wikipedia.org/wiki/POSIX)标准中，基本正则语法（**BRE**）要求[元字符](https://en.wikipedia.org/wiki/Metacharacter)`( )`和`{ }`被指定为`\(\)`和`\{\}`，而扩展正则语法（**ERE**）则不要求。

| Metacharacter | Description                                                  |
| ------------- | ------------------------------------------------------------ |
| `^`           | Matches the starting position within the string. In line-based tools, it matches the starting position of any line. |
| `.`           | Matches any single character (many applications exclude [newlines](https://en.wikipedia.org/wiki/Newline), and exactly which characters are considered newlines is flavor-,  character-encoding-, and platform-specific, but it is safe to assume  that the line feed character is included). Within POSIX bracket  expressions, the dot character matches a literal dot. For example, `a.c` matches "abc", etc., but `[a.c]` matches only "a", ".", or "c". |
| `[ ]`         | A bracket expression. Matches a single character that is contained within the brackets. For example, `[abc]` matches "a", "b", or "c". `[a-z]` specifies a range which matches any lowercase letter from "a" to "z". These forms can be mixed: `[abcx-z]` matches "a", "b", "c", "x", "y", or "z", as does `[a-cx-z]`. The `-` character is treated as a literal character if it is the last or the first (after the `^`, if present) character within the brackets: `[abc-]`, `[-abc]`. Note that backslash escapes are not allowed. The `]` character can be included in a bracket expression if it is the first (after the `^`) character: `[]abc]`. |
| `[^ ]`        | Matches a single character that is not contained within the brackets. For example, `[^abc]` matches any character other than "a", "b", or "c". `[^a-z]` matches any single character that is not a lowercase letter from "a" to "z". Likewise, literal characters and ranges can be mixed. |
| `$`           | Matches the ending position of the string or the position just  before a string-ending newline. In line-based tools, it matches the  ending position of any line. |
| `( )`         | Defines a marked subexpression. The string matched within the parentheses can be recalled later (see the next entry, `\*n*`). A marked subexpression is also called a block or capturing group. **BRE mode requires `\( \)`**. |
| *`\n`*        | Matches what the *n*th marked subexpression matched, where *n* is a digit from 1 to 9. This construct is vaguely defined in the  POSIX.2 standard. Some tools allow referencing more than nine capturing  groups. Also known as a backreference. **backreferences are only supported in BRE mode** |
| `*`           | Matches the preceding element zero or more times. For example, `ab*c` matches "ac", "abc", "abbbc", etc. `[xyz]*` matches "", "x", "y", "z", "zx", "zyx", "xyzzy", and so on. `(ab)*` matches "", "ab", "abab", "ababab", and so on. |
| *`{m,n}`*     | Matches the preceding element at least *m* and not more than *n* times. For example, `a{3,5}` matches only "aaa", "aaaa", and "aaaaa". This is not found in a few older instances of regexes. **BRE mode requires          `\{\m,n\}`**. |

**Examples:**

- `.at` matches any three-character string ending with  "at", including "hat", "cat", "bat", "4at", "#at" and " at" (starting  with a space).
- `[hc]at` matches "hat" and "cat".
- `[^b]at` matches all strings matched by `.at` except "bat".
- `[^hc]at` matches all strings matched by `.at` other than "hat" and "cat".
- `^[hc]at` matches "hat" and "cat", but only at the beginning of the string or line.
- `[hc]at$` matches "hat" and "cat", but only at the end of the string or line.
- `\[.\]` matches any single character surrounded by "["  and "]" since the brackets are escaped, for example: "[a]", "[b]",  "[7]", "[@]", "[]]", and "[ ]" (bracket space bracket).
- `s.*` matches s followed by zero or more characters, for example: "s", "saw", "seed", "s3w96.7", and "s6#h%(>>>m n mQ".

> - `.at`匹配任何以 "at"结尾的三个字符的字符串，包括 "hat", "cat", "bat", "4at", "#at"和" at"（以空格开始）。
> - `[hc]at`匹配 "hat"和 "cat"。
> - `[^b]at`匹配所有由`.at`匹配的字符串，除了"bat"。
> - `[^hc]at`匹配所有由`.at`匹配的字符串，除了"hat"和"cat"之外。
> - `^[hc]at`匹配 "hat"和 "cat"，但只在字符串或行的开头。
> - `[hc]at$`匹配"hat"和 "cat"，但只在字符串或行的末尾。
> - `\[.\]`匹配任何由"["和"]"包围的单个字符，因为方括号被转义了，例如。"[a]", "[b]", "[7]", "[@]", "[]]", 和 "[ ]"（方括号空格括号）。
> - `s.*`匹配s后面的零个或多个字符，例如。"s", "saw", "seed", "s3w96.7", 和 "s6#h%(>>m n mQ"。

#### POSIX extended

The meaning of metacharacters [escaped](https://en.wikipedia.org/wiki/Escape_character) with a backslash is reversed for some characters in the POSIX Extended Regular Expression (**ERE**) syntax. With this syntax, a backslash causes the metacharacter to be treated as a literal character. So, for example, `\( \)` is now `( )` and `\{ \}` is now `{ }`. Additionally, support is removed for `\*n*` backreferences and the following metacharacters are added:

> 对于POSIX扩展正则表达式（**ERE**）语法中的某些字符，带反斜杠的元字符[escaped](https://en.wikipedia.org/wiki/Escape_character)的含义是相反的。在这种语法中，**反斜杠会使元字符被当作一个字面常量字符来处理**。因此，例如，`\(\)`现在是`()`，`\{ \}`现在是`{ }`。此外，取消了对`\n`反向引用的支持，增加了以下元字符。
>

| Metacharacter | Description                                                  |
| ------------- | ------------------------------------------------------------ |
| `?`           | Matches the preceding element zero or one time. For example, `ab?c` matches only "ac" or "abc". |
| `+`           | Matches the preceding element one or more times. For example, `ab+c` matches "abc", "abbc", "abbbc", and so on, but not "ac". |
| `|`           | The choice (also known as alternation or set union) operator matches either the expression before or the expression after the operator. For  example, `abc|def` matches "abc" or "def". |

**Examples:**

- `[hc]?at` matches "at", "hat", and "cat".
- `[hc]*at` matches "at", "hat", "cat", "hhat", "chat", "hcat", "cchchat", and so on.
- `[hc]+at` matches "hat", "cat", "hhat", "chat", "hcat", "cchchat", and so on, but not "at".
- `cat|dog` matches "cat" or "dog".

POSIX Extended Regular Expressions can often be used with modern Unix utilities by including the [command line](https://en.wikipedia.org/wiki/Command_line) flag -E.

> - `[hc]?at`匹配 "at", "hat", 和 "cat"。
> - `[hc]*at`匹配 "at", "hat", "cat", "hhat", "chat", "hcat", "cchchat"，等等。
> - `[hc]+at`匹配 "hat", "cat", "hat", "chat", "hcat", "cchat", 等等，但不匹配 "at"。
> - `cat|dog`匹配 "cat"或 "dog"。
>
> POSIX扩展正则表达式通常可以通过包括[命令行](https://en.wikipedia.org/wiki/Command_line)标志-E来与现代Unix工具一起使用。

#### Character classes

The character class is the most basic regex concept after a literal match.  It makes one small sequence of characters match a larger set of  characters. For example, `[A-Z]` could stand for any uppercase letter in the English alphabet, and `\d` could mean any digit. Character classes apply to both POSIX levels.

When specifying a range of characters, such as `[a-Z]` (i.e. lowercase *`a`* to uppercase *`Z`*), the computer's locale settings determine the contents by the numeric ordering of the character encoding. They could store digits in that  sequence, or the ordering could be *abc…zABC…Z*, or *aAbBcC…zZ*. So the POSIX standard defines a character class, which will be known by the regex processor installed. Those definitions are in the following  table:

> **字符类**是继字面常量匹配之后最基本的regex概念。 它使一个小的字符序列与一个较大的字符集相匹配。例如，`[A-Z]`可以代表英语字母表中的任何大写字母，而`d`可以代表任何数字。字符类别适用于两个POSIX级别。
>
> 当指定一个字符范围时，如`[a-Z]`（即小写*`a`*到大写*`Z`*），**计算机的区域设置通过字符编码的数字顺序来确定内容**。他们可以按照这个顺序存储数字，或者排序可以是*abc...zABC...Z*，或者*aAbBcC...ZZ*。因此，POSIX标准定义了一个字符类，它将被安装的regex处理器所知道。这些定义在下表中：

| Description                                                  | POSIX        | Non-standard                                                 | Perl/Tcl | Vim     | Java                | ASCII                                |
| ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | -------- | ------- | ------------------- | ------------------------------------ |
| ASCII characters                                             |              | `[:ascii:]`[[38\]](https://en.wikipedia.org/?curid=25717#cite_note-char-classes-emacs-list-2016-38) |          |         | `\p{ASCII}`         | `[\x00-\x7F]`                        |
| Alphanumeric characters                                      | `[:alnum:]`  |                                                              |          |         | `\p{Alnum}`         | `[A-Za-z0-9]`                        |
| Alphanumeric characters plus "_"                             |              | `[:word:]`[[38\]](https://en.wikipedia.org/?curid=25717#cite_note-char-classes-emacs-list-2016-38) | `\w`     | `\w`    | `\w`                | `[A-Za-z0-9_]`                       |
| Non-word characters                                          |              |                                                              | `\W`     | `\W`    | `\W`                | `[^A-Za-z0-9_]`                      |
| Alphabetic characters                                        | `[:alpha:]`  |                                                              |          | `\a`    | `\p{Alpha}`         | `[A-Za-z]`                           |
| Space and tab                                                | `[:blank:]`  |                                                              |          | `\s`    | `\p{Blank}`         | `[ \t]`                              |
| Word boundaries                                              |              |                                                              | `\b`     | `\< \>` | `\b`                | `(?<=\W)(?=\w)|(?<=\w)(?=\W)`        |
| Non-word boundaries                                          |              |                                                              |          |         | `\B`                | `(?<=\W)(?=\W)|(?<=\w)(?=\w)`        |
| [Control characters](https://en.wikipedia.org/wiki/Control_character) | `[:cntrl:]`  |                                                              |          |         | `\p{Cntrl}`         | `[\x00-\x1F\x7F]`                    |
| Digits                                                       | `[:digit:]`  |                                                              | `\d`     | `\d`    | `\p{Digit}` or `\d` | `[0-9]`                              |
| Non-digits                                                   |              |                                                              | `\D`     | `\D`    | `\D`                | `[^0-9]`                             |
| Visible characters                                           | `[:graph:]`  |                                                              |          |         | `\p{Graph}`         | `[\x21-\x7E]`                        |
| Lowercase letters                                            | `[:lower:]`  |                                                              |          | `\l`    | `\p{Lower}`         | `[a-z]`                              |
| Visible characters and the space character                   | `[:print:]`  |                                                              |          | `\p`    | `\p{Print}`         | `[\x20-\x7E]`                        |
| Punctuation characters                                       | `[:punct:]`  |                                                              |          |         | `\p{Punct}`         | `[][!"#$%&'()*+,./:;<=>?@\^_`{|}~-]` |
| [Whitespace characters](https://en.wikipedia.org/wiki/Whitespace_character) | `[:space:]`  |                                                              | `\s`     | `\_s`   | `\p{Space}` or `\s` | `[ \t\r\n\v\f]`                      |
| Non-whitespace characters                                    |              |                                                              | `\S`     | `\S`    | `\S`                | `[^ \t\r\n\v\f]`                     |
| Uppercase letters                                            | `[:upper:]`  |                                                              |          | `\u`    | `\p{Upper}`         | `[A-Z]`                              |
| Hexadecimal digits                                           | `[:xdigit:]` |                                                              |          | `\x`    | `\p{XDigit}`        | `[A-Fa-f0-9]`                        |

POSIX character classes can only be used within bracket expressions. For example, `[[:upper:]ab]` matches the uppercase letters and lowercase "a" and "b".

An additional non-POSIX class understood by some tools is `[:word:]`, which is usually defined as `[:alnum:]` plus underscore. This reflects the fact that in many programming  languages these are the characters that may be used in identifiers. The  editor [Vim](https://en.wikipedia.org/wiki/Vim_(text_editor)) further distinguishes *word* and *word-head* classes (using the notation `\w` and `\h`) since in many programming languages the characters that can begin an  identifier are not the same as those that can occur in other positions:  numbers are generally excluded, so an identifier would look like `\h\w*` or `[[:alpha:]_][[:alnum:]_]*` in POSIX notation.

Note that what the POSIX regex standards call *character classes* are commonly referred to as *POSIX character classes* in other regex flavors which support them. With most other regex flavors, the term *character class* is used to describe what POSIX calls *bracket expressions*.

> POSIX字符类只能在**括号表达式**中使用。例如，`[[:upper:]ab]`匹配大写字母和小写"a"和"b"。
>
> 一些工具可以理解的另外一个非POSIX类是`[:word:]`，它通常被定义为`[:alnum:]`加下划线。这反映了这样一个事实，即在许多编程语言中，这些是可以用于标识符的字符。编辑器[Vim](https://en.wikipedia.org/wiki/Vim_(text_editor))进一步区分了*字*和*字头*类（使用符号`w`和`h`），因为在许多编程语言中，可以开始标识符的字符与可以出现在其他位置的字符不一样：数字通常被排除在外，所以一个标识符看起来像`\h\w*`或`[[:alpha:]_][:alnum:]_]*`在POSIX的符号。
>
> 请注意，POSIX regex标准所称的*字符类*，在其他支持它们的regex**流派**中通常被称为*POSIX字符类*。在大多数其他的regex流派中，术语*字符类*被用来描述POSIX所谓的*括号表达式*。

### Perl and PCRE

See also: [Perl Compatible Regular Expressions](https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions)

Because of its expressive power and (relative) ease of reading, many  other utilities and programming languages have adopted syntax similar to [Perl](https://en.wikipedia.org/wiki/Perl)'s — for example, [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), [Julia](https://en.wikipedia.org/wiki/Julia_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)), [Qt](https://en.wikipedia.org/wiki/Qt_(software)), Microsoft's [.NET Framework](https://en.wikipedia.org/wiki/.NET_Framework), and [XML Schema](https://en.wikipedia.org/wiki/XML_Schema_(W3C)). Some languages and tools such as [Boost](https://en.wikipedia.org/wiki/Boost_C%2B%2B_Libraries) and [PHP](https://en.wikipedia.org/wiki/PHP) support multiple regex flavors. Perl-derivative regex implementations  are not identical and usually implement a subset of features found in  Perl 5.0, released in 1994. Perl sometimes does incorporate features  initially found in other languages. For example, Perl 5.10 implements  syntactic extensions originally developed in PCRE and Python.[[38\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-38)

> 也请参见。[Perl兼容正则表达式](https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions)
>
> 由于它的表达能力和（相对）易读性，许多其他的实用程序和编程语言都采用了与[Perl](https://en.wikipedia.org/wiki/Perl)类似的语法--例如，[Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), [Julia](https://en.wikipedia. org/wiki/Julia_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)), [Qt](https://en.wikipedia.org/wiki/Qt_(software)), Microsoft的[.NET Framework](https://en.wikipedia.org/wiki/.NET_Framework), 和[XML Schema](https://en.wikipedia.org/wiki/XML_Schema_(W3C))。一些语言和工具，如[Boost](https://en.wikipedia.org/wiki/Boost_C%2B%2B_Libraries)和[PHP](https://en.wikipedia.org/wiki/PHP)，支持多种流派的regex。Perl衍生的regex实现并不完全相同，通常是实现1994年发布的Perl 5.0中的一个子集的功能。Perl有时也会加入最初在其他语言中发现的功能。例如，Perl 5.10实现了最初在PCRE和Python中开发的**句法扩展**。

### Lazy matching 忽略优先匹配

In Python and some other implementations (e.g. Java), the three common quantifiers (`*`, `+` and `?`) are [greedy](https://en.wikipedia.org/wiki/Greedy_algorithm) by default because they match as many characters as possible.[[39\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-py-re-39) The regex `".+"` (including the double-quotes) applied to the string

```
"Ganymede," he continued, "is the largest moon in the Solar System."
```

matches the entire line (because the entire line begins and ends with a double-quote) instead of matching only the first part, `"Ganymede,"`. The aforementioned quantifiers may, however, be made *lazy* or *minimal* or *reluctant*, matching as few characters as possible, by appending a question mark: `".+?"` matches only `"Ganymede,"`.[[39\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-py-re-39)

> 在Python和其他一些实现中(例如Java)，三种常见的量词(`*`、`+`和`?`)默认为[greedy](https://en.wikipedia.org/wiki/Greedy_algorithm)，因为它们**尽可能多地**匹配字符。[[39/]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-py-re-39) 将正则表达式`".+"`（包括双引号）应用于字符串
>
> ```
> "Ganymede," he continued, "is the largest moon in the Solar System."
> ```
>
> 匹配整行（因为整行以双引号开始和结束），而不是只匹配第一部分，"Ganymede"。然而，上述量词可以通过附加一个问号，使其变得*忽略*或*最小化*或*勉强*，**尽可能地匹配更少的**字符。`".+?"`只匹配`"Ganymede,"`。[[39\]]()

### Possessive matching 占有优先匹配

In Java and Python 3.11+,[[40\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-40) quantifiers may be made *possessive* by appending a plus sign, which disables backing off (in a backtracking engine), even if doing so would allow the overall match to succeed:[[41\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-es-re-41) While the regex `".*"` applied to the string

```
"Ganymede," he continued, "is the largest moon in the Solar System."
```

matches the entire line, the regex `".*+"` does *not match at all*, because `.*+` consumes the entire input, including the final `"`. Thus, possessive quantifiers are most useful with negated character classes, e.g. `"[^"]*+"`, which matches `"Ganymede,"` when applied to the same string.

Another common extension serving the same function is atomic  grouping, which disables backtracking for a parenthesized group. The  typical syntax is (?>group). For example, while ^(wi|w)i$ matches both wi and wii, ^(?>wi|w)i$ only matches wii because the engine is forbidden from backtracking and so cannot try setting the group to "w" after matching "wi".[[42\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-42)

Possessive quantifiers are easier to implement than greedy and lazy quantifiers, and are typically more efficient at runtime.[[41\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-es-re-41)

> 在Java和Python 3.11+中，[[40\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-40)量词可以通过附加一个加号而变成*占有*，这就使回溯功能失效（在回溯引擎中），即使这样做可以使整个匹配成功：[[41\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-es-re-41) 当正则表达式`".*"`应用到字符串时
>
> ```
> "Ganymede," he continued, "is the largest moon in the Solar System."
> ```
>
> 匹配整行，而正则表达式`".*+"`则*完全不匹配*，因为`.*+`消耗了整个输入，包括最后的`"`。因此，占有式量词对**否定的**字符类最有用，例如`"[^"]*+"`，当应用于同一个字符串时，它匹配`"Ganymede，"。
>
> 另一个具有相同功能的常见扩展是**原子分组**（固化分组，atomic, 固化），它禁止对一个括号内的分组进行回溯操作。典型的语法是`(?>group)`。例如，虽然`^(wi|w)i$`同时匹配wi和wii，但`^(?>wi|w)i$`只匹配wii，因为引擎**被禁止回溯**，所以不能在匹配 "wi "后尝试将组设为 "w"。[[42\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-42)
>
> 占有式量词比贪婪量词和懒惰量词更容易实现，而且在运行时通常更有效率。[[41\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-es-re-41)

## Patterns for non-regular language

Many features found in virtually all modern regular expression libraries provide an expressive power that exceeds the [regular languages](https://en.wikipedia.org/wiki/Regular_language). For example, many implementations allow grouping subexpressions with  parentheses and recalling the value they match in the same expression (*backreferences*). This means that, among other things, a pattern can match strings of repeated words like "papa" or "WikiWiki", called *squares* in formal language theory. The pattern for these strings is `(.+)\1`.

The language of squares is not regular, nor is it [context-free](https://en.wikipedia.org/wiki/Context-free_language), due to the [pumping lemma](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages). However, [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching) with an unbounded number of backreferences, as supported by numerous modern tools, is still [context sensitive](https://en.wikipedia.org/wiki/Context-sensitive_language).[[43\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-43) The general problem of matching any number of backreferences is [NP-complete](https://en.wikipedia.org/wiki/NP-complete), growing exponentially by the number of backref groups used.[[44\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-44)

> 在几乎所有现代正则表达式库中发现的许多功能都提供了超过[正则语言](https://en.wikipedia.org/wiki/Regular_language)的表达能力。例如，许多实现允许用圆括号将子表达式分组，并在同一个表达式中调用它们匹配的值（***backreferences***）。这意味着，除其他外，模式可以匹配像 "papa"或 "WikiWiki "这样的重复词串，在形式语言理论中称为*squares*。这些字符串的模式是`(.+)\1`。
>
> 由于[抽出法](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages)，二次幂语言不是正则的，也不是[无语境](https://en.wikipedia.org/wiki/Context-free_language)的。然而，正如许多现代工具所支持的那样，具有无限制数量的反向引用的[模式匹配](https://en.wikipedia.org/wiki/Pattern_matching)仍然是[上下文敏感的](https://en.wikipedia.org/wiki/Context-sensitive_language)。[[43/]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-43) 匹配任何数量的反向参考的一般问题是[NP-complete](https://en.wikipedia.org/wiki/NP-complete)，通过使用的反向引用组的数量呈指数增长。[[44\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-44)

However, many tools, libraries, and engines that provide such constructions still use the term *regular expression* for their patterns. This has led to a nomenclature where the term regular expression has different meanings in [formal language theory](https://en.wikipedia.org/wiki/Formal_language) and pattern matching. For this reason, some people have taken to using the term *regex*, *regexp*, or simply *pattern* to describe the latter. [Larry Wall](https://en.wikipedia.org/wiki/Larry_Wall), author of the Perl programming language, writes in an essay about the design of [Raku](https://en.wikipedia.org/wiki/Raku_(programming_language)):

> "Regular expressions" […] are only  marginally related to real regular expressions. Nevertheless, the term  has grown with the capabilities of our pattern matching engines, so I'm  not going to try to fight linguistic necessity here. I will, however,  generally call them "regexes" (or "regexen", when I'm in an Anglo-Saxon  mood).[[23\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-Apocalypse5-23)

> 然而，许多提供这种结构的**工具**、**库**和引擎仍然对它们的模式使用*正则表达式*这个**术语**。这导致了正则表达式这个术语在[形式语言理论](https://en.wikipedia.org/wiki/Formal_language)和**模式匹配**中具有不同的含义的命名法。由于这个原因，有些人已经开始使用术语*regex*，*regexp*，或者干脆用*pattern*来描述后者。[Larry Wall](https://en.wikipedia.org/wiki/Larry_Wall)，Perl编程语言的作者，在一篇关于[Raku](https://en.wikipedia.org/wiki/Raku_(programming_language))设计的文章中写道：
>
> > "正则表达式"[......]与真正的正则表达式只有很小的关系。尽管如此，这个术语已经随着我们的模式匹配引擎的能力而增长，所以我不打算在这里试图对抗语言上的必要性。不过，我一般会称它们为 "regexes"（或者 "regexen"，当我处于盎格鲁-撒克逊情绪时）。



### Assertions

Other features not found in describing regular languages include assertions. These include the ubiquitous ^ and $, used since at least 1970,[[45\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-45) as well as some more sophisticated extensions like lookaround that appeared in 1994.[[46\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-perl5-46) Lookarounds define the surrounding of a match and don't spill into the  match itself, a feature only relevant for the use case of string  searching. Some of them can be simulated in a regular language by  treating the surroundings as a part of the language as well.[[47\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-47)

The look-ahead assertions `(?=…)` and `(?!…)` have been attested since at least 1994, starting with Perl 5.[[46\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-perl5-46) The look-behind assertions `(?<=…)` and `(?<!…)` are attested since 1997 in a commit by Ilya Zakharevich to Perl 5.005.[[48\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-48)

> 在描述正则语言中没有的其他特征包括**断言**。这些包括无处不在的^和$，至少从1970年开始使用，[[45\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-45)以及一些更复杂的扩展，如1994年出现的lookaround。[[46\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-perl5-46) Lookarounds定义了一个匹配的周围，并没有**溢出**到匹配本身，这个特点只与字符串搜索的使用情况有关。它们中的一些可以在正则语言中模拟，把周围环境也作为语言的一部分。[[47\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-47)
>
> 顺序环视（look-ahead）断言`(?=...)`和`(?!...)`至少从1994年开始被证实，从Perl 5开始。[[46\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-perl5-46) 逆序环视（look-behind）断言`(?<=...)`和`(?<! ...)`在Ilya Zakharevich对Perl 5.005的提交中被证实。

| Assertion                                                    | Lookbehind       | Lookahead       |
| ------------------------------------------------------------ | ---------------- | --------------- |
| Positive                                                     | (?**<=**pattern) | (?**=**pattern) |
| Negative                                                     | (?**<!**pattern) | (?**!**pattern) |
| Look-behind and look-ahead assertions in [Perl](https://en.wikipedia.org/wiki/Perl) regular expressions |                  |                 |



## Implementations and running times

There are at least three different [algorithms](https://en.wikipedia.org/wiki/Algorithm) that decide whether and how a given regex matches a string.

The oldest and fastest relies on a result in formal language theory that allows every [nondeterministic finite automaton](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton) (NFA) to be transformed into a [deterministic finite automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) (DFA). The DFA can be constructed explicitly and then run on the  resulting input string one symbol at a time. Constructing the DFA for a  regular expression of size *m* has the time and memory cost of [*O*](https://en.wikipedia.org/wiki/Big_O_notation)(2<sup>*m*</sup>), but it can be run on a string of size *n* in time *O*(*n*).  Note that the size of the expression is the size after abbreviations, such as numeric quantifiers, have been expanded.

> 至少有三种不同的[算法](https://en.wikipedia.org/wiki/Algorithm)来决定一个给定的regex是否以及如何匹配一个字符串。
>
> 最古老和最快速的算法依赖于形式语言理论中的一个结果，它允许每个[非确定性有限自动机](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton) (NFA)被转化为[确定性有限自动机](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) (DFA)。DFA可以被明确地构造出来，然后在得到的输入字符串上一次运行一个符号。为大小为*m*的正则表达式构造DFA的时间和内存成本为[*O*](https://en.wikipedia.org/wiki/Big_O_notation)(2<sup>*m*</sup>)，但是它可以在*O*(*n*)的时间内对大小为*n*的字符串运行。 请注意，表达式的大小是在缩写（如数字量词）被扩展后的大小。

An alternative approach is to simulate the NFA directly,  essentially building each DFA state on demand and then discarding it at  the next step. This keeps the DFA implicit and avoids the exponential  construction cost, but running cost rises to *O*(*mn*). The  explicit approach is called the DFA algorithm and the implicit approach  the NFA algorithm. Adding caching to the NFA algorithm is often called  the "lazy DFA" algorithm, or just the DFA algorithm without making a  distinction. These algorithms are fast, but using them for recalling  grouped subexpressions, lazy quantification, and similar features is  tricky.[[49\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-49)[[50\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-50) Modern implementations include the re1-re2-sregex family based on Cox's code.

The third algorithm is to match the pattern against the input string by [backtracking](https://en.wikipedia.org/wiki/Backtracking). This algorithm is commonly called NFA, but this terminology can be  confusing. Its running time can be exponential, which simple  implementations exhibit when matching against expressions like `(a|aa)*b` that contain both alternation and unbounded quantification and force  the algorithm to consider an exponentially increasing number of  sub-cases. This behavior can cause a security problem called [Regular expression Denial of Service](https://en.wikipedia.org/wiki/Regular_expression_Denial_of_Service) (ReDoS).

> 另一种方法是直接模拟NFA，基本上是按要求建立每个DFA状态，然后在下一步丢弃它。这就保持了DFA的隐性，避免了指数级的构建成本，但是运行成本上升到*O*(*mn*)。显式方法被称为**DFA算法**，隐式方法被称为NFA算法。在NFA算法中加入缓存通常被称为 "懒惰的DFA"算法，或者只是DFA算法而不做区分。这些算法速度很快，但是用它们来回忆分组子表达式、懒惰量化和类似的特征是很棘手的。[[49\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-49)[[50\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-50) 现代的实现包括基于Cox代码的re1-re2-sregex系列。
>
> 第三种算法是通过[backtracking](https://en.wikipedia.org/wiki/Backtracking)将模式与输入字符串相匹配。这种算法通常被称为NFA，但这个术语可能会引起混淆。它的运行时间可能是指数级的，当与`(a|aa)*b`这样的表达式匹配时，简单的实现就会表现出来，这些表达式**既包含多选也包含无界的量化**，并迫使算法考虑指数级增加的子案例。这种行为会导致一个安全问题，称为[正则表达式拒绝服务](https://en.wikipedia.org/wiki/Regular_expression_Denial_of_Service) (ReDoS)。

Although backtracking implementations only give an exponential  guarantee in the worst case, they provide much greater flexibility and  expressive power. For example, any implementation which allows the use  of backreferences, or implements the various extensions introduced by  Perl, must include some kind of backtracking. Some implementations try  to provide the best of both algorithms by first running a fast DFA  algorithm, and revert to a potentially slower backtracking algorithm  only when a backreference is encountered during the match. GNU grep (and the underlying gnulib DFA) uses such a strategy.[[51\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-51)

Sublinear runtime algorithms have been achieved using [Boyer-Moore (BM) based algorithms](https://en.wikipedia.org/wiki/Boyer–Moore_string-search_algorithm) and related DFA optimization techniques such as the reverse scan.[[52\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-52) GNU grep, which supports a wide variety of POSIX syntaxes and  extensions, uses BM for a first-pass prefiltering, and then uses an  implicit DFA. Wu [agrep](https://en.wikipedia.org/wiki/Agrep), which implements approximate matching, combines the prefiltering into  the DFA in BDM (backward DAWG matching). NR-grep's BNDM extends the BDM  technique with Shift-Or bit-level parallelism.[[53\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-53)

> 尽管**回溯**的实现在最坏的情况下只能提供指数级的保证，但它们提供了更大的灵活性和表现力。例如，任何允许使用反向引用的实现，或者实现Perl引入的各种扩展，都必须包括某种回溯。一些实现试图通过首先运行快速的DFA算法来提供两种算法的最佳效果，并且只有在匹配过程中遇到**反向引用**时才恢复到潜在的较慢的回溯算法。GNU grep（和底层的gnulib DFA）使用了这样的策略。[[51\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-51)
>
> 使用[基于Boyer-Moore（BM）的算法](https://en.wikipedia.org/wiki/Boyer-Moore_string-search_algorithm)和相关的DFA优化技术，如反向扫描，已经实现了亚线性的运行时间算法。GNU grep支持多种POSIX语法和扩展，使用BM进行第一轮预过滤，然后使用隐式DFA。Wu [agrep](https://en.wikipedia.org/wiki/Agrep)，它实现了近似匹配，将预过滤结合到BDM（后向DAWG匹配）中的DFA。NR-grep的BNDM用Shift-Or位级的并行性扩展了BDM技术。[[53/]]()

A few theoretical alternatives to backtracking for backreferences exist, and their "exponents" are tamer in that they are only related to the number of backreferences, a fixed property of some regexp languages such as POSIX. One naive method that duplicates a non-backtracking NFA  for each backreference note has a complexity of O(n<sup>2k+2</sup>) time and O(n<sup>2k+1</sup>) space for a haystack of length n and k backreferences in the RegExp.[[54\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-54) A very recent theoretical work based on memory automata gives a tighter bound based on "active" variable nodes used, and a polynomial  possibility for some backreferenced regexps.[[55\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-55)

> 存在一些理论上的替代方法可以替代用来反向引用的回溯，它们的"指数"比较温和，因为它们只与反向引用的数量有关，这是一些重构语言（如POSIX）的固定属性。一种天真的方法是为每个反向引用注释复制一个非回溯的NFA，对于一个长度为n的干草堆和正则中的k个反向引用，其复杂度为 O(n<sup>2k+2</sup>)时间和O(n<sup>2k+1</sup>)空间。最近一项基于记忆自动机的理论工作给出了一个基于所使用的 "活动"变量节点的更严格的约束，以及对一些反向引用的表达式的多项式可能性。[[55]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-55)

## Unicode?

In theoretical terms, any token set can be matched by regular  expressions as long as it is pre-defined. In terms of historical  implementations, regexes were originally written to use [ASCII](https://en.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange) characters as their token set though regex libraries have supported numerous other [character sets](https://en.wikipedia.org/wiki/Character_set). Many modern regex engines offer at least some support for [Unicode](https://en.wikipedia.org/wiki/Unicode). In most respects it makes no difference what the character set is, but  some issues do arise when extending regexes to support Unicode.

- **Supported encoding**. Some regex libraries expect to work  on some particular encoding instead of on abstract Unicode characters.  Many of these require the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) encoding, while others might expect [UTF-16](https://en.wikipedia.org/wiki/UTF-16), or [UTF-32](https://en.wikipedia.org/wiki/UTF-32). In contrast, Perl and Java are agnostic on encodings, instead operating on decoded characters internally.
- **Supported Unicode range**. Many regex engines support only the [Basic Multilingual Plane](https://en.wikipedia.org/wiki/Basic_Multilingual_Plane), that is, the characters which can be encoded with only 16 bits. Currently (as of 2016) only a few regex engines (e.g., Perl's and Java's) can handle the full 21-bit Unicode range.
- **Extending ASCII-oriented constructs to Unicode**. For example, in ASCII-based implementations, character ranges of the form `[x-y]` are valid wherever *x* and *y* have [code points](https://en.wikipedia.org/wiki/Code_point) in the range [0x00,0x7F] and codepoint(*x*) ≤ codepoint(*y*). The natural extension of such character ranges to Unicode would simply  change the requirement that the endpoints lie in [0x00,0x7F] to the  requirement that they lie in [0x0000,0x10FFFF]. However, in practice  this is often not the case. Some implementations, such as that of [gawk](https://en.wikipedia.org/wiki/Gawk_(GNU_package)), do not allow character ranges to cross Unicode blocks. A range like  [0x61,0x7F] is valid since both endpoints fall within the Basic Latin  block, as is [0x0530,0x0560] since both endpoints fall within the  Armenian block, but a range like [0x0061,0x0532] is invalid since it  includes multiple Unicode blocks. Other engines, such as that of the [Vim](https://en.wikipedia.org/wiki/Vim_(text_editor)) editor, allow block-crossing but the character values must not be more than 256 apart.[[56\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-56)
- **Case insensitivity**. Some case-insensitivity flags affect only the ASCII characters. Other flags affect all characters. Some engines  have two different flags, one for ASCII, the other for Unicode. Exactly  which characters belong to the POSIX classes also varies.
- **Cousins of case insensitivity**. As ASCII has case distinction, case insensitivity became a logical feature in text searching. Unicode  introduced alphabetic scripts without case like [Devanagari](https://en.wikipedia.org/wiki/Devanāgarī). For these, [case sensitivity](https://en.wikipedia.org/wiki/Case_sensitivity) is not applicable. For scripts like Chinese, another distinction seems  logical: between traditional and simplified. In Arabic scripts,  insensitivity to [initial, medial, final, and isolated position](https://en.wikipedia.org/wiki/IMFI) may be desired. In Japanese, insensitivity between [hiragana](https://en.wikipedia.org/wiki/Hiragana) and [katakana](https://en.wikipedia.org/wiki/Katakana) is sometimes useful.
- **Normalization**. Unicode has [combining characters](https://en.wikipedia.org/wiki/Unicode#Combining_characters). Like old typewriters, plain base characters (white spaces, punctuation  characters, symbols, digits, or letters) can be followed by one or more  non-spacing symbols (usually diacritics, like accent marks modifying  letters) to form a single printable character; but Unicode also provides a limited set of precomposed characters, i.e. characters that already  include one or more combining characters. A sequence of a base character + combining characters should be matched with the identical single  precomposed character (only some of these combining sequences can be  precomposed into a single Unicode character, but infinitely many other  combining sequences are possible in Unicode, and needed for various  languages, using one or more combining characters after an initial base  character; these combining sequences *may* include a base character or combining characters partially precomposed, but not necessarily in  canonical order and not necessarily using the canonical  precompositions). The process of standardizing sequences of a base  character + combining characters by decomposing these *canonically equivalent* sequences, before reordering them into canonical order (and optionally recomposing *some* combining characters into the leading base character) is called normalization.
- **New control codes**. Unicode introduced amongst others, [byte order marks](https://en.wikipedia.org/wiki/Byte_order_mark) and text direction markers. These codes might have to be dealt with in a special way.
- **Introduction of character classes for Unicode blocks, scripts, and numerous other character properties**. Block properties are much less useful than script properties, because a block can have code points from several different scripts, and a script can have code points from several different blocks.[[57\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-unicode-57) In [Perl](https://en.wikipedia.org/wiki/Perl) and the `java.util.regex` library, properties of the form `\p{InX}` or `\p{Block=X}` match characters in block *X* and `\P{InX}` or `\P{Block=X}` matches code points not in that block. Similarly, `\p{Armenian}`, `\p{IsArmenian}`, or `\p{Script=Armenian}` matches any character in the Armenian script. In general, `\p{X}` matches any character with either the binary property *X* or the general category *X*. For example, `\p{Lu}`, `\p{Uppercase_Letter}`, or `\p{GC=Lu}` matches any uppercase letter. Binary properties that are *not* general categories include `\p{White_Space}`, `\p{Alphabetic}`, `\p{Math}`, and `\p{Dash}`. Examples of non-binary properties are `\p{Bidi_Class=Right_to_Left}`, `\p{Word_Break=A_Letter}`, and `\p{Numeric_Value=10}`.

> 从理论上讲，任何**标记集**都可以被正则表达式匹配，只要它是**预先定义**的。就历史上的实现而言，最初编写的正则表达式是使用[ASCII](https://en.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange)字符作为其标记集，尽管正则表达式库已经支持许多其他[字符集](https://en.wikipedia.org/wiki/Character_set)。许多现代的regex引擎至少对[Unicode](https://en.wikipedia.org/wiki/Unicode)提供了一些支持。在大多数方面，字符集是什么并没有什么区别，但是当扩展regexs以支持Unicode时，确实会出现一些问题。
>
> - **支持的编码**。一些regex库希望在某些**特定的编码**上工作，而不是在抽象的Unicode字符上。 其中许多需要[UTF-8](https://en.wikipedia.org/wiki/UTF-8)编码，而其他的可能期望[UTF-16](https://en.wikipedia.org/wiki/UTF-16)，或[UTF-32](https://en.wikipedia.org/wiki/UTF-32)。相比之下，Perl和Java在编码上是**不可知的**，而是在内部操作解码的字符。
> - **支持的Unicode范围**。许多regex引擎只支持[基本多语言平面](https://en.wikipedia.org/wiki/Basic_Multilingual_Plane)，也就是只用16位编码的字符。目前（截至2016年）只有少数的regex引擎（例如Perl的和Java的）可以处理完整的21位Unicode范围。
> - **将面向ASCII的结构扩展到Unicode**。例如，在基于ASCII的实现中，只要*x*和*y*的[码点](https://en.wikipedia.org/wiki/Code_point)在[0x00,0x7F]范围内，并且码点(*x*)≤码点(*y*)，那么形式为`[x-y]`的字符范围就有效。这种字符范围对Unicode的自然扩展，只是将端点位于[0x00,0x7F]的要求改为位于[0x0000,0x10FFFF]。然而，在实践中，情况往往不是这样的。一些实现，例如[gawk](https://en.wikipedia.org/wiki/Gawk_(GNU_package))，不允许字符范围跨越Unicode块。像[0x61,0x7F]这样的范围是有效的，因为两个端点都在基本拉丁文块内，就像[0x0530,0x0560]一样，因为两个端点都在亚美尼亚文块内，但像[0x0061,0x0532]这样的范围是无效的，因为它包含了多个Unicode块。其他引擎，如[Vim](https://en.wikipedia.org/wiki/Vim_(text_editor))编辑器的引擎，允许区块交叉，但字符值的间隔不能超过256。[[56]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-56)
> - **大小写不敏感**。一些大小写不敏感的标志只影响ASCII字符。其他标志则影响所有字符。有些引擎有两个不同的标志，一个用于ASCII，另一个用于Unicode。确切地说，哪些字符属于POSIX类也是不同的。
> - **大小写不敏感的表亲**。由于ASCII有大小写区分，大小写不敏感成为文本搜索的一个逻辑特征。Unicode引入了没有大小写的字母脚本，如[Devanagari](https://en.wikipedia.org/wiki/Devanāgarī)。对于这些，[大小写敏感性](https://en.wikipedia.org/wiki/Case_sensitivity)并不适用。对于像中文这样的文字，另一种区分似乎是合乎逻辑的：繁体和简体。在阿拉伯文字中，可能需要对[首字母、中间字母、尾字母和孤立的位置](https://en.wikipedia.org/wiki/IMFI)不敏感。在日语中，对[平假名](https://en.wikipedia.org/wiki/Hiragana)和[片假名](https://en.wikipedia.org/wiki/Katakana)的不敏感有时是有用的。
> - **规范化**。Unicode有[组合字符](https://en.wikipedia.org/wiki/Unicode#Combining_characters)。像老式打字机一样，普通的基础字符（空白、标点符号、符号、数字或字母）后面可以跟上一个或多个非空格符号（通常是变音符号，如修改字母的重音符号），形成一个可打印的字符；但Unicode也提供了一套有限的预组合字符，即已经包括一个或多个组合字符的字符。一个基础字符+组合字符的序列应该与相同的单个预组合字符相匹配（只有一些组合序列可以预组合成一个单一的Unicode字符，但在Unicode中可以有无限多的其他组合序列，而且各种语言都需要，在初始基础字符之后使用一个或多个组合字符；这些组合序列*可能*包括一个基础字符或部分预组合的组合字符，但不一定按照规范的顺序，不一定使用规范的预组合）。通过分解这些*经典等价*的序列，在将它们重新排序为经典顺序（并选择性地将*一些*组合字符重新组合到领先的基础字符中），使基础字符+组合字符的序列标准化，这一过程被称为规范化。
> - **新的控制代码**。Unicode引入了[字节顺序标记](https://en.wikipedia.org/wiki/Byte_order_mark)和文本方向标记等。这些代码可能需要以一种特殊的方式来处理。
> - **为Unicode块、脚本和许多其他字符属性引入了字符类**。区块属性比脚本属性的作用要小得多，因为一个区块可以有几个不同脚本的码点，而一个脚本可以有几个不同区块的码点。[[57/]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-unicode-57) 在[Perl](https://en.wikipedia.org/wiki/Perl)和`java.util.regex`库中，`p{InX}`或`p{Block=X}`形式的属性与区块*X*的字符匹配，`\P{InX}`或`\P{Block=X}`匹配不在该区块中的码点。同样地，`\p{Armenian}`、`\p{IsArmenian}`或`\p{Script=Armenian}`匹配亚美尼亚文字中的任何字符。一般来说，`\p{X}`可以匹配任何具有二进制属性*X*或一般类别*X*的字符。例如，`\p{Lu}`，`\p{Uppercase_Letter}`，或`\p{GC=Lu}`匹配任何大写字母。*不是*一般类别的二进制属性包括`\p{White_Space}`、`\p{Alphabetic}`、`\p{Math}`和`\p{Dash}`。非二进制属性的例子有：`\p{Bidi_Class=Right_to_Left}`，`\p{Word_Break=A_Letter}`，和`\p{Numeric_Value=10}`。

## Uses

Regexes are useful in a wide variety of text processing tasks, and more generally [string processing](https://en.wikipedia.org/wiki/String_processing), where the data need not be textual. Common applications include [data validation](https://en.wikipedia.org/wiki/Data_validation), [data scraping](https://en.wikipedia.org/wiki/Data_scraping) (especially [web scraping](https://en.wikipedia.org/wiki/Web_scraping)), [data wrangling](https://en.wikipedia.org/wiki/Data_wrangling), simple [parsing](https://en.wikipedia.org/wiki/Parsing), the production of [syntax highlighting](https://en.wikipedia.org/wiki/Syntax_highlighting) systems, and many other tasks.

While regexes would be useful on Internet [search engines](https://en.wikipedia.org/wiki/Search_engine_(computing)), processing them across the entire database could consume excessive  computer resources depending on the complexity and design of the regex.  Although in many cases system administrators can run regex-based queries internally, most search engines do not offer regex support to the  public. Notable exceptions include [Google Code Search](https://en.wikipedia.org/wiki/Google_Code_Search) and [Exalead](https://en.wikipedia.org/wiki/Exalead). However, Google Code Search was shut down in January 2012.[[58\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-58)

> Regexes在各种文本处理任务中都很有用，更普遍的是[字符串处理](https://en.wikipedia.org/wiki/String_processing)，其中的数据不需要是文本的。常见的应用包括[数据验证](https://en.wikipedia.org/wiki/Data_validation)，[数据爬虫](https://en.wikipedia.org/wiki/Data_scraping)（尤其是[网络爬虫](https://en.wikipedia.org/wiki/Web_scraping)），[数据整理](https://en.wikipedia.org/wiki/Data_wrangling)，简单的[解析](https://en.wikipedia.org/wiki/Parsing)，制作[语法高亮](https://en.wikipedia.org/wiki/Syntax_highlighting)系统，以及许多其他任务。
>
> 虽然regexes在互联网[搜索引擎](https://en.wikipedia.org/wiki/Search_engine_(computing))上会很有用，但在整个数据库中处理它们可能会消耗过多的计算机资源，这取决于regex的复杂性和设计。尽管在许多情况下，系统管理员可以在内部运行基于regex的查询，但大多数搜索引擎不向公众提供regex支持。值得注意的例外包括[Google Code Search](https://en.wikipedia.org/wiki/Google_Code_Search)和[Exalead](https://en.wikipedia.org/wiki/Exalead)。然而，谷歌代码搜索在2012年1月被关闭了。[[58/]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-58)

A [blacklist](https://en.wikipedia.org/wiki/MediaWiki:Titleblacklist) on Wikipedia which uses regular expressions to identify bad titles.



## Examples

The specific syntax rules vary depending on the specific implementation, [programming language](https://en.wikipedia.org/wiki/Programming_language), or [library](https://en.wikipedia.org/wiki/Library_(computing)) in use. Additionally, the functionality of regex implementations can vary between [versions](https://en.wikipedia.org/wiki/Software_versioning).

Because regexes can be difficult to both explain and understand  without examples, interactive websites for testing regexes are a useful  resource for learning regexes by experimentation. This section provides a basic description of some of the properties of  regexes by way of illustration.

The following conventions are used in the examples.[[59\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-clarify000-59)

> 具体的**语法规则**因使用的具体实现、[编程语言](https://en.wikipedia.org/wiki/Programming_language)或[库](https://en.wikipedia.org/wiki/Library_(计算))而不同。此外，在不同的[版本](https://en.wikipedia.org/wiki/Software_versioning)中，regex实现的**功能**也会有所不同。
>
> 因为如果没有例子的话，regexes可能很难解释和理解，测试**regexes**的互动网站是通过实验学习regexes的有用资源。本节通过举例说明的方式提供了对部分regexes属性的基本描述。
>
> 例子中使用了以下惯例。

```
metacharacter(s) ;; the metacharacters column specifies the regex syntax being demonstrated
=~ m//           ;; indicates a regex match operation in Perl
=~ s///          ;; indicates a regex substitution operation in Perl
```

Also worth noting is that these regexes are all Perl-like syntax. Standard [POSIX](https://en.wikipedia.org/wiki/Regular_expression#POSIX_Basic_Regular_Expressions) regular expressions are different.

Unless otherwise indicated, the following examples conform to the [Perl](https://en.wikipedia.org/wiki/Perl) programming language, release 5.8.8, January 31, 2006. This means that  other implementations may lack support for some parts of the syntax  shown here (e.g. basic vs. extended regex, `\( \)` vs. `()`, or lack of `\d` instead of [POSIX](https://en.wikipedia.org/wiki/POSIX) `[:digit:]`).

The syntax and conventions used in these examples coincide with that of other programming environments as well.[[60\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-60)

> 另外值得注意的是，这些正则表达式都是类似Perl的语法。标准的 [POSIX](https://en.wikipedia.org/wiki/Regular_expression#POSIX_Basic_Regular_Expressions) 正则表达式是不同的。
>
> 除非另有说明，下面的例子符合 [Perl](https://en.wikipedia.org/wiki/Perl) 编程语言，5.8.8版，2006年1月31日。这意味着其他实现可能缺乏对此处所示语法的某些部分的支持（例如，基本vs.扩展的正则表达式，`(\)` vs. `()`，或者缺乏`\d`而不是[POSIX](https://en.wikipedia.org/wiki/POSIX) `[:digit:]`）。
>
> 这些例子中使用的**语法和惯例**与其他编程环境的语法和惯例也是一致的。[[60\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-60)

| Meta­character(s) | Description                                                  | Example[[61\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-61) |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `.`               | Normally matches any character except a newline.<br />Within square brackets the dot is literal. | `$string1 = "Hello World\n"; if ($string1 =~ m/...../) {  print "$string1 has length >= 5.\n"; } ` **Output:** `Hello World has length >= 5. ` |
| `( )`             | Groups a series of pattern elements to a single element.<br />When you match a pattern within parentheses, you can <br />use any of `$1`, `$2`, ... later to refer to the previously <br />matched pattern. Some implementations may use a <br />backslash notation instead, like `\1`, `\2`. | `$string1 = "Hello World\n"; if ($string1 =~ m/(H..).(o..)/) {  print "We matched '$1' and '$2'.\n"; } ` **Output:** `We matched 'Hel' and 'o W'. ` |
| `+`               | Matches the preceding pattern element one or more times.     | `$string1 = "Hello World\n"; if ($string1 =~ m/l+/) {  print "There are one or more consecutive letter \"l\"'s in $string1.\n"; } ` **Output:** `There are one or more consecutive letter "l"'s in Hello World. ` |
| `?`               | Matches the preceding pattern element zero or one <br />time. | `$string1 = "Hello World\n"; if ($string1 =~ m/H.?e/) {  print "There is an 'H' and a 'e' separated by ";  print "0-1 characters (e.g., He Hue Hee).\n"; } ` **Output:** `There is an 'H' and a 'e' separated by 0-1 characters (e.g., He Hue Hee). ` |
| `?`               | Modifies the `*`, `+`, `?` or `{M,N}`'d regex that comes <br />before to match as few times as possible. | `$string1 = "Hello World\n"; if ($string1 =~ m/(l.+?o)/) {  print "The non-greedy match with 'l' followed by one or ";  print "more characters is 'llo' rather than 'llo Wo'.\n"; } ` **Output:** `The non-greedy match with 'l' followed by one or more characters is 'llo' rather than 'llo Wo'. ` |
| `*`               | Matches the preceding pattern element zero or more <br />times. | `$string1 = "Hello World\n"; if ($string1 =~ m/el*o/) {  print "There is an 'e' followed by zero to many ";  print "'l' followed by 'o' (e.g., eo, elo, ello, elllo).\n"; } ` **Output:** `There is an 'e' followed by zero to many 'l' followed by 'o' (e.g., eo, elo, ello, elllo). ` |
| `{M,N}`           | Denotes the minimum M and the maximum N match <br />count. <br />N can be omitted and M can be 0: `{M}` matches <br />"exactly" M times; `{M,}` matches "at least" M times; <br />`{0,N}` matches "at most" N times. <br />`x* y+ z?` is thus equivalent to `x{0,} y{1,} z{0,1}`. | `$string1 = "Hello World\n"; if ($string1 =~ m/l{1,2}/) {  print "There exists a substring with at least 1 ";  print "and at most 2 l's in $string1\n"; } ` **Output:** `There exists a substring with at least 1 and at most 2 l's in Hello World ` |
| `[…]`             | Denotes a set of possible character matches.                 | `$string1 = "Hello World\n"; if ($string1 =~ m/[aeiou]+/) {  print "$string1 contains one or more vowels.\n"; } ` **Output:** `Hello World contains one or more vowels. ` |
| `|`               | Separates alternate possibilities.                           | `$string1 = "Hello World\n"; if ($string1 =~ m/(Hello|Hi|Pogo)/) {  print "$string1 contains at least one of Hello, Hi, or Pogo."; } ` **Output:** `Hello World contains at least one of Hello, Hi, or Pogo. ` |
| `\b`              | Matches a zero-width boundary between a word-class <br />character (see  next) and either a non-word class <br />character or an edge; same as <br />`(^\w|\w$|\W\w|\w\W)`. | `$string1 = "Hello World\n"; if ($string1 =~ m/llo\b/) {  print "There is a word that ends with 'llo'.\n"; } ` **Output:** `There is a word that ends with 'llo'. ` |
| `\w`              | Matches an alphanumeric character, including "_";  <br />same as `[A-Za-z0-9_]` in ASCII, and<br /> `[\p{Alphabetic}\p{GC=Mark}`  <br /> `\p{GC=Decimal_Number}`<br /> `\p{GC=Connector_Punctuation}]` <br />in Unicode,[[57\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-unicode-57) where the `Alphabetic` property <br />contains more than Latin letters, and the <br />`Decimal_Number` property contains more than <br />Arab digits. | `$string1 = "Hello World\n"; if ($string1 =~ m/\w/) {  print "There is at least one alphanumeric ";  print "character in $string1 (A-Z, a-z, 0-9, _).\n"; } ` **Output:** `There is at least one alphanumeric character in Hello World (A-Z, a-z, 0-9, _). ` |
| `\W`              | Matches a *non*-alphanumeric character, excluding "_";  <br />same as `[^A-Za-z0-9_]` in ASCII, and `[^\p{Alphabetic}\p{GC=Mark}` `\p{GC=Decimal_Number}` `\p{GC=Connector_Punctuation}]` <br />in Unicode. | `$string1 = "Hello World\n"; if ($string1 =~ m/\W/) {  print "The space between Hello and ";  print "World is not alphanumeric.\n"; } ` **Output:** `The space between Hello and World is not alphanumeric. ` |
| `\s`              | Matches a whitespace character,  <br />which in ASCII are tab, line feed, form feed, carriage return, and space;  in Unicode, also matches no-break spaces, next line, and the variable-width spaces (amongst others). | `$string1 = "Hello World\n"; if ($string1 =~ m/\s.*\s/) {  print "In $string1 there are TWO whitespace characters, which may";  print " be separated by other characters.\n"; } ` **Output:** `In Hello World there are TWO whitespace characters, which may be separated by other characters. ` |
| `\S`              | Matches anything *but* a whitespace.                         | `$string1 = "Hello World\n"; if ($string1 =~ m/\S.*\S/) {  print "In $string1 there are TWO non-whitespace characters, which";  print " may be separated by other characters.\n"; } ` **Output:** `In Hello World there are TWO non-whitespace characters, which may be separated by other characters. ` |
| `\d`              | Matches a digit;  same as `[0-9]` in ASCII;  in Unicode, same as the `\p{Digit}` or `\p{GC=Decimal_Number}` property, which itself the same as the `\p{Numeric_Type=Decimal}` property. | `$string1 = "99 bottles of beer on the wall."; if ($string1 =~ m/(\d+)/) {  print "$1 is the first number in '$string1'\n"; } ` **Output:** `99 is the first number in '99 bottles of beer on the wall.' ` |
| `\D`              | Matches a non-digit;  same as `[^0-9]` in ASCII or `\P{Digit}` in Unicode. | `$string1 = "Hello World\n"; if ($string1 =~ m/\D/) {  print "There is at least one character in $string1";  print " that is not a digit.\n"; } ` **Output:** `There is at least one character in Hello World that is not a digit. ` |
| `^`               | Matches the beginning of a line or string.                   | `$string1 = "Hello World\n"; if ($string1 =~ m/^He/) {  print "$string1 starts with the characters 'He'.\n"; } ` **Output:** `Hello World starts with the characters 'He'. ` |
| `$`               | Matches the end of a line or string.                         | `$string1 = "Hello World\n"; if ($string1 =~ m/rld$/) {  print "$string1 is a line or string ";  print "that ends with 'rld'.\n"; } ` **Output:** `Hello World is a line or string that ends with 'rld'. ` |
| `\A`              | Matches the beginning of a string (but not an internal line). | `$string1 = "Hello\nWorld\n"; if ($string1 =~ m/\AH/) {  print "$string1 is a string ";  print "that starts with 'H'.\n"; } ` **Output:** `Hello World is a string that starts with 'H'. ` |
| `\z`              | Matches the end of a string (but not an internal line).[[62\]](https://en.wikipedia.org/wiki/Regular_expression#cite_note-Perl_Best_Practices-62) | `$string1 = "Hello\nWorld\n"; if ($string1 =~ m/d\n\z/) {  print "$string1 is a string ";  print "that ends with 'd\\n'.\n"; } ` **Output:** `Hello World is a string that ends with 'd\n'. ` |
| `[^…]`            | Matches every character except the ones inside brackets.     | `$string1 = "Hello World\n"; if ($string1 =~ m/[^abc]/) { print "$string1 contains a character other than "; print "a, b, and c.\n"; } ` **Output:** `Hello World contains a character other than a, b, and c. ` |



## Induction

Main article: [Induction of regular languages](https://en.wikipedia.org/wiki/Induction_of_regular_languages)

Regular expressions can often be created ("induced" or "learned") based on a set of example strings. This is known as the [induction of regular languages](https://en.wikipedia.org/wiki/Induction_of_regular_languages) and is part of the general problem of [grammar induction](https://en.wikipedia.org/wiki/Grammar_induction) in [computational learning theory](https://en.wikipedia.org/wiki/Computational_learning_theory). Formally, given examples of strings in a regular language, and perhaps also given examples of strings *not* in that regular language, it is possible to induce a grammar for the  language, i.e., a regular expression that generates that language. Not  all regular languages can be induced in this way (see [language identification in the limit](https://en.wikipedia.org/wiki/Language_identification_in_the_limit)), but many can. For example, the set of examples {1, 10, 100}, and  negative set (of counterexamples) {11, 1001, 101, 0} can be used to  induce the regular expression 1⋅0* (1 followed by zero or more 0s).

> 主要文章。[正则语言的归纳](https://en.wikipedia.org/wiki/Induction_of_regular_languages)
>
> 正则表达式通常可以根据一组示例字符串来创建（"归纳"或"学习"）。这被称为[正则语言的归纳](https://en.wikipedia.org/wiki/Induction_of_regular_languages)，是[计算学习理论](https://en.wikipedia.org/wiki/Grammar_induction)中[语法归纳](https://en.wikipedia.org/wiki/Computational_learning_theory)这个一般问题的一部分。从形式上看，给定一个正则语言中的字符串的例子，也许也给定*不*在该正则语言中的字符串的例子，就有可能**归纳**出该语言的语法，即产生该语言的正则表达式。并非所有的正则语言都能以这种方式归纳出来（见[极限中的语言识别](https://en.wikipedia.org/wiki/Language_identification_in_the_limit)），但许多语言可以。例如，例子集{1, 10, 100}和负数集（反例）{11, 1001, 101, 0}可以用来归纳正则表达式1⋅0*（1后跟0或更多0）。



## See also

- [Comparison of regular-expression engines](https://en.wikipedia.org/wiki/Comparison_of_regular-expression_engines)
- [Extended Backus–Naur form](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form)
- [Matching wildcards](https://en.wikipedia.org/wiki/Matching_wildcards)
- [Regular tree grammar](https://en.wikipedia.org/wiki/Regular_tree_grammar)
- [Thompson's construction](https://en.wikipedia.org/wiki/Thompson's_construction) – converts a regular expression into an equivalent [nondeterministic finite automaton (NFA)](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton)



## [re](https://docs.python.org/3/library/re.html#module-re)—Regular expression operations

Python RE **Source code:** [Lib/re/](https://github.com/python/cpython/tree/3.11/Lib/re/)

This module provides regular expression matching operations similar to those found in Perl.

> 该模块提供类似于Perl中的正则表达式匹配操作。

Both patterns and strings to be searched can be Unicode strings ([`str`](https://docs.python.org/3/library/stdtypes.html#str)) as well as 8-bit strings ([`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes)). However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a byte pattern or vice-versa; similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string.

> 要搜索的模式和字符串都可以是Unicode字符串（[`str`](https://docs.python.org/3/library/stdtypes.html#str)）以及8位字符串（[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes)）。然而，Unicode字符串和8位字符串不能混合使用：也就是说，你不能用字节模式匹配Unicode字符串，反之亦然；同样，当要求进行替换时，替换的字符串必须与模式和搜索字符串的类型相同。
>

Regular expressions use the backslash character (`'\'`) to indicate special forms or to allow special characters to be used without invoking their special meaning.  This collides with Python’s usage of the same character for the same purpose in string literals; for example, to match a literal backslash, one might have to write `'\\\\'` as the pattern string, because the regular expression must be `\\`, and each backslash must be expressed as `\\` inside a regular Python string literal. Also, please note that any invalid escape sequences in Python’s usage of the backslash in string literals now generate a [`DeprecationWarning`](https://docs.python.org/3/library/exceptions.html#DeprecationWarning) and in the future this will become a [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError). This behaviour will happen even if it is a valid escape sequence for a regular expression.

> 正则表达式使用反斜杠字符 (`'\'`) 来表示特殊形式，或者允许使用特殊字符而不调用其特殊含义。 这与 Python 在字符串字面量上对同一字符的使用发生了冲突；例如，要匹配一个字面量的反斜杠，可能要写成 `'\\\\'`作为模式字符串，因为正则表达式必须是 `\\`，而每个反斜杠必须在 Python 正则字符串字面常量内表达为 `\\`。另外，请注意，Python 在字符串字面中使用反斜杠时，任何无效的转义序列现在都会产生 [`DeprecationWarning`](https://docs.python.org/3/library/exceptions.html#DeprecationWarning)，将来会变成 [`SyntaxError`](https://docs.python.org/3/library/exceptions.html#SyntaxError) 。即使它是正则表达式的有效转义序列，也会发生这种行为。

The solution is to use Python’s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with `'r'`.  So `r"\n"` is a two-character string containing `'\'` and `'n'`, while `"\n"` is a one-character string containing a newline.  Usually patterns will be expressed in Python code using this raw string notation.

> 解决办法是使用 Python 的原始字符串符号来表示正则表达式模式；在以 `'r'` 为前缀的字符串字面中，不会以任何特殊方式处理反斜线。 所以`r"\n"` 是一个包含`'\'`和`'n'`的双字符字符串，而`"\n"`是一个包含换行的单字符字符串。 通常模式会在Python代码中使用这种原始字符串符号来表达。

It is important to note that most regular expression operations are available as module-level functions and methods on [compiled regular expressions](https://docs.python.org/3/library/re.html#re-objects).  The functions are shortcuts that don’t require you to compile a regex object first, but miss some fine-tuning parameters.

> 需要注意的是，大多数正则表达式操作都可以作为模块级的函数和方法在[编译的正则表达式](https://docs.python.org/3/library/re.html#re-objects)上使用。 这些函数是捷径，不需要你先编译一个正则表达式对象，但缺少一些微调的参数。
>

**See also:** The third-party [regex](https://pypi.org/project/regex/) module, which has an API compatible with the standard library [`re`](https://docs.python.org/3/library/re.html#module-re) module, but offers additional functionality and a more thorough Unicode support.

> **参见：**第三方[regex](https://pypi.org/project/regex/)模块，它的API与标准库[`re`](https://docs.python.org/3/library/re.html#module-re)模块兼容，但提供额外的功能和更彻底的Unicode支持。

### Regular Expression Syntax

A regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing).

Regular expressions can be concatenated to form new regular expressions; if *A* and *B* are both regular expressions, then *AB* is also a regular expression. In general, if a string *p* matches *A* and another string *q* matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* contain low precedence operations; boundary conditions between *A* and *B*; or have numbered group references.  Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here.  For details of the theory and implementation of regular expressions, consult the Friedl book [[Frie09\]](https://docs.python.org/3/library/re.html#frie09), or almost any textbook about compiler construction.

A brief explanation of the format of regular expressions follows.  For further information and a gentler presentation, consult the [Regular Expression HOWTO](https://docs.python.org/3/howto/regex.html#regex-howto).

> 一个正则表达式（或RE）指定了一组与之匹配的字符串；本模块中的函数让你检查一个特定的字符串是否与给定的正则表达式匹配（或者一个给定的正则表达式是否与一个特定的字符串匹配，这归结起来是一样的）。
>
> 正则表达式可以串联起来形成新的正则表达式；如果*A*和*B*都是正则表达式，那么*AB*也是一个正则表达式。一般来说，如果一个字符串*p*匹配*A*，另一个字符串*q*匹配*B*，那么字符串*pq*将匹配AB。 这一点是成立的，除非*A*或*B*包含低优先级的操作；*A*和*B*之间的边界条件；或者有编号的组引用。 因此，复杂的表达式可以很容易地从较简单的原始表达式中构造出来，比如这里描述的表达式。 关于正则表达式的理论和实现的细节，请参考Friedl的书[[Frie09\]](https://docs.python.org/3/library/re.html#frie09)，或者几乎所有关于编译器构造的教科书。
>
> 下面是对正则表达式格式的简要解释。 如果想了解更多信息和更温和的介绍，请查阅 [Regular Expression HOWTO](https://docs.python.org/3/howto/regex.html#regex-howto)。
>

Regular expressions can contain both special and ordinary characters. Most ordinary characters, like `'A'`, `'a'`, or `'0'`, are the simplest regular expressions; they simply match themselves.  You can concatenate ordinary characters, so `last` matches the string `'last'`.  (In the rest of this section, we’ll write RE’s in `this special style`, usually without quotes, and strings to be matched `'in single quotes'`.)

Some characters, like `'|'` or `'('`, are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted.

Repetition operators or quantifiers (`*`, `+`, `?`, `{m,n}`, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix `?`, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression `(?:a{6})*` matches any multiple of six `'a'` characters.

> 正则表达式可以包含特殊字符和普通字符。大多数**普通字符**，如`'A'`、`'a'`或`'0'`，是最简单的正则表达式；它们只是匹配自己。 你可以将普通字符连接起来，所以`last`匹配字符串`'last'`。 (在本节的其余部分，我们将用 `这种特殊的风格` 来写RE's，通常不加引号，而要匹配的字符串则用 `'单引号'`）。
>
> 有些字符，如`'|'`或`'('`，是特殊的。**特殊字符**要么代表普通字符的类别，要么影响它们周围的正则表达式的解释方式。
>
> 重复操作符或**量词**（`*`, `+`, `?`, `{m,n}`, 等等）不能直接嵌套。这可以避免与非贪婪的修饰符后缀`?`，以及其他实现中的其他修饰符产生歧义。为了将第二个重复应用于一个内部重复，可以使用括号。例如，表达式`(?:a{6})*`匹配六个`'a'`字符的任何倍数。
>

The special characters are:

> 特殊字符有：

- `.`

  (Dot.)  In the default mode, this matches any character except a newline.  If the [`DOTALL`](https://docs.python.org/3/library/re.html#re.DOTALL) flag has been specified, this matches any character including a newline.

- `^`

  (Caret.)  Matches the start of the string, and in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) mode also matches immediately after each newline.

- `$`

  Matches the end of the string or just before the newline at the end of the string, and in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) mode also matches before a newline.  `foo` matches both ‘foo’ and ‘foobar’, while the regular expression `foo$` matches only ‘foo’.  More interestingly, searching for `foo.$` in `'foo1\nfoo2\n'` matches ‘foo2’ normally, but ‘foo1’ in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) mode; searching for a single `$` in `'foo\n'` will find two (empty) matches: one just before the newline, and one at the end of the string.

> - `.`
>
>   (Dot.) 在默认模式下，它匹配**除换行以外**的任何字符。 如果指定了[`DOTALL`](https://docs.python.org/3/library/re.html#re.DOTALL)标志，这将匹配包括换行在内的任何字符。
>
> - `^`
>
>   (Caret.) 匹配**字符串的开头**，在[`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE)模式下，还可以在每个换行后立即匹配。
>
> - `$`
>
>   匹配字符串的末尾或字符串末尾的换行前，在[`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE)模式下也匹配换行前。 `foo`同时匹配 'foo'和 'foobar'，而正则表达式`foo$`只匹配 'foo'。 更有趣的是，在`'foo1\nfoo2\n'`中搜索`foo.$`，正常情况下匹配'foo2'，但在[`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE)模式下匹配'foo1'；在`'foo\n'`中搜索单个`$`会发现两个（空）匹配：一个在换行之前，一个在字符串的末尾。

- `*`

  Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible.  `ab*` will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s.

- `+`

  Causes the resulting RE to match 1 or more repetitions of the preceding RE. `ab+` will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’.

- `?`

  Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. `ab?` will match either ‘a’ or ‘ab’.

> 
