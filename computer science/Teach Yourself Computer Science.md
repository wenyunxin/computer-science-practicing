[toc]



# Teach yourself computer science

**Note: this guide was extensively updated in May 2020. For the prior version,** [see here](https://teachyourselfcs.com/2016/)**.**

æ³¨æ„ï¼šæœ¬æŒ‡å—åœ¨2020å¹´5æœˆè¿›è¡Œäº†å¹¿æ³›çš„æ›´æ–°ã€‚ä¹‹å‰çš„ç‰ˆæœ¬è¯·çœ‹[è¿™é‡Œ](https://teachyourselfcs.com/2016/)ã€‚



If youâ€™re a self-taught engineer or bootcamp grad, you owe it to yourself to learn computer science. Thankfully, you can give yourself a world-class CS education without investing years and a small fortune in a degree program ðŸ’¸.

There are plenty of resources out there, but some are better than others. You donâ€™t need yet another â€œ200+ Free Online Coursesâ€ listicle. You need answers to these questions:

- **Which subjects** should you learn, and why?
- What is the **best book or video lecture series** for each subject?

This guide is our attempt to definitively answer these questions.

> å¦‚æžœä½ æ˜¯ä¸€ä¸ªè‡ªå­¦æˆæ‰çš„å·¥ç¨‹å¸ˆæˆ–è®­ç»ƒè¥çš„æ¯•ä¸šç”Ÿï¼Œä½ åº”è¯¥ä¸ºè‡ªå·±å­¦ä¹ è®¡ç®—æœºç§‘å­¦ã€‚å€¼å¾—åº†å¹¸çš„æ˜¯ï¼Œä½ å¯ä»¥ç»™è‡ªå·±ä¸€ä¸ªä¸–ç•Œçº§çš„CSæ•™è‚²ï¼Œè€Œä¸éœ€è¦åœ¨ä¸€ä¸ªå­¦ä½è¯¾ç¨‹ä¸ŠæŠ•èµ„å‡ å¹´å’Œä¸€å°ç¬”é’±ðŸ’¸ã€‚
>
> å¤–é¢æœ‰å¾ˆå¤šèµ„æºï¼Œä½†æœ‰äº›èµ„æºæ¯”å…¶ä»–èµ„æºè¦å¥½ã€‚ä½ ä¸éœ€è¦å¦ä¸€ä¸ª "200å¤šä¸ªå…è´¹åœ¨çº¿è¯¾ç¨‹ "çš„åˆ—è¡¨æ–‡ç« ã€‚ä½ éœ€è¦è¿™äº›é—®é¢˜çš„ç­”æ¡ˆã€‚
>
> - **ä½ åº”è¯¥å­¦ä¹ å“ªäº›ç§‘ç›®**ï¼Œä¸ºä»€ä¹ˆï¼Ÿ
> - æ¯ä¸ªç§‘ç›®çš„**æœ€å¥½çš„ä¹¦æˆ–è§†é¢‘è®²åº§ç³»åˆ—**æ˜¯ä»€ä¹ˆï¼Ÿ
>
> æœ¬æŒ‡å—æ˜¯æˆ‘ä»¬è¯•å›¾æ˜Žç¡®åœ°å›žç­”è¿™äº›é—®é¢˜ã€‚



- [ä¸­æ–‡ç¿»è¯‘è§æ­¤](https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md) (Chinese) by Wu Zhengke



## TL;DR:

Study all nine subjects below, in roughly the presented order, using either the suggested textbook or video lecture series, but ideally both. Aim for 100-200 hours of study of each topic, then revisit favorites throughout your career ðŸš€.

> å­¦ä¹ ä»¥ä¸‹æ‰€æœ‰ä¹ä¸ªä¸»é¢˜ï¼Œå¤§è‡´æŒ‰ç…§æå‡ºçš„é¡ºåºï¼Œä½¿ç”¨å»ºè®®çš„æ•™ç§‘ä¹¦æˆ–è§†é¢‘è®²åº§ç³»åˆ—ï¼Œä½†æœ€å¥½æ˜¯ä¸¤è€…éƒ½ä½¿ç”¨ã€‚æ¯ä¸ªä¸»é¢˜çš„å­¦ä¹ æ—¶é—´ä¸º100-200å°æ—¶ï¼Œç„¶åŽåœ¨ä½ çš„èŒä¸šç”Ÿæ¶¯ä¸­é‡æ–°å®¡è§†æœ€å–œæ¬¢çš„ä¸»é¢˜ðŸš€ã€‚
>



| **Subject**                                                  | **Why study?**                                               | **Book**                                                     | **Videos**                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **[Programming](https://teachyourselfcs.com/#programming)**  | Donâ€™t be the person who â€œnever quite understoodâ€ something like recursion. | [*Structure and Interpretation of Computer Programs*](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html) | [Brian Harveyâ€™s Berkeley CS 61A](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter) |
| **[Computer Architecture](https://teachyourselfcs.com/#architecture)** | If you donâ€™t have a solid mental model of how a computer actually works, all of your higher-level abstractions will be brittle. | [*Computer Systems: A Programmer's Perspective*](http://csapp.cs.cmu.edu/3e/home.html) | [Berkeley CS 61C](https://inst.eecs.berkeley.edu//~cs61c/sp15/) |
| **[Algorithms and Data Structures](https://teachyourselfcs.com/#algorithms)** | If you donâ€™t know how to use ubiquitous data structures like stacks, queues, trees, and graphs, you wonâ€™t be able to solve challenging problems. | *[The Algorithm Design Manual](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/)* | [Steven Skienaâ€™s lectures](https://www3.cs.stonybrook.edu/~skiena/373/videos/) |
| **[Math for CS](https://teachyourselfcs.com/#math)**         | CS is basically a runaway branch of applied math, so learning math will give you a competitive advantage. | *[Mathematics for Computer Science](https://courses.csail.mit.edu/6.042/spring17/mcs.pdf)* | Tom Leightonâ€™s MIT 6.042J                                    |
| **[Operating Systems](https://teachyourselfcs.com/#operating-systems)** | Most of the code you write is run by an operating system, so you should know how those interact. | [*Operating Systems: Three Easy Pieces*](https://pages.cs.wisc.edu/~remzi/OSTEP/) | Berkeley CS 162                                              |
| **[Computer Networking](https://teachyourselfcs.com/#networking)** | The Internet turned out to be a big deal: understand how it works to unlock its full potential. | *Computer Networking: A Top-Down Approach*                   | Stanford CS 144                                              |
| **[Databases](https://teachyourselfcs.com/#databases)**      | Data is at the heart of most significant programs, but few understand how database systems actually work. | *Readings in Database Systems*                               | Joe Hellersteinâ€™s Berkeley CS 186                            |
| **[Languages and Compilers](https://teachyourselfcs.com/#languages)** | If you understand how languages and compilers actually work, youâ€™ll write better code and learn new languages more easily. | *Crafting Interpreters*                                      | Alex Aikenâ€™s course on edX                                   |
| **[Distributed Systems](https://teachyourselfcs.com/#distributed-systems)** | These days, *most* systems are distributed systems.          | *Designing Data-Intensive Applications* by Martin Kleppmann  | MIT 6.824                                                    |



## Still too much?

If the idea of self-studying 9 topics over multiple years feels overwhelming, we suggest you focus on just two books: [*Computer Systems: A Programmer's Perspective*](http://csapp.cs.cmu.edu/3e/home.html) and [*Designing Data-Intensive Applications*](https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/?pldnSite=1). In our experience, these two books provide incredibly high return on time invested, particularly for self-taught engineers and bootcamp grads working on networked applications. They may also serve as a "gateway drug" for the other topics and resources listed above.

> å¦‚æžœåœ¨å¤šå¹´å†…è‡ªå­¦9ä¸ªè¯¾é¢˜çš„æƒ³æ³•æ„Ÿåˆ°éš¾ä»¥æ‰¿å—ï¼Œæˆ‘ä»¬å»ºè®®ä½ åªä¸“æ³¨äºŽä¸¤æœ¬ä¹¦ã€‚ã€Š[è®¡ç®—æœºç³»ç»Ÿï¼šç¨‹åºå‘˜çš„è§†è§’]((http://csapp.cs.cmu.edu/3e/home.html))ã€‹å’Œã€Š[è®¾è®¡æ•°æ®å¯†é›†åž‹åº”ç”¨ç¨‹åº]((https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/?pldnSite=1))ã€‹ã€‚æ ¹æ®æˆ‘ä»¬çš„ç»éªŒï¼Œè¿™ä¸¤æœ¬ä¹¦çš„æŠ•èµ„å›žæŠ¥çŽ‡éžå¸¸é«˜ï¼Œç‰¹åˆ«æ˜¯å¯¹äºŽè‡ªå­¦æˆæ‰çš„å·¥ç¨‹å¸ˆå’Œä»Žäº‹ç½‘ç»œåº”ç”¨çš„è®­ç»ƒè¥æ¯•ä¸šç”Ÿã€‚å®ƒä»¬ä¹Ÿå¯ä»¥ä½œä¸ºä¸Šè¿°å…¶ä»–ä¸»é¢˜å’Œèµ„æºçš„ "å…¥é—¨è¯ç‰©"ã€‚



## Why learn computer science?

There are 2 types of software engineer: those who understand computer science well enough to do challenging, innovative work, and those who just get by because theyâ€™re familiar with a few high level tools.

> æœ‰ä¸¤ç§ç±»åž‹çš„è½¯ä»¶å·¥ç¨‹å¸ˆï¼šä¸€ç§æ˜¯å¯¹è®¡ç®—æœºç§‘å­¦æœ‰è¶³å¤Ÿçš„äº†è§£ï¼Œèƒ½å¤Ÿä»Žäº‹å…·æœ‰æŒ‘æˆ˜æ€§çš„åˆ›æ–°å·¥ä½œï¼›å¦ä¸€ç§æ˜¯ç”±äºŽç†Ÿæ‚‰ä¸€äº›é«˜æ°´å¹³çš„å·¥å…·è€Œå‹‰å¼ºåº”ä»˜ã€‚

Both call themselves software engineers, and both tend to earn similar salaries in their early careers. But Type 1 engineers progress toward more fulfilling and well-remunerated work over time, whether thatâ€™s valuable commercial work or breakthrough open-source projects, technical leadership or high-quality individual contributions.

> ä¸¤è€…éƒ½ç§°è‡ªå·±ä¸ºè½¯ä»¶å·¥ç¨‹å¸ˆï¼Œè€Œä¸”åœ¨æ—©æœŸçš„èŒä¸šç”Ÿæ¶¯ä¸­ï¼Œä¸¤è€…éƒ½å€¾å‘äºŽèŽ·å¾—ç±»ä¼¼çš„è–ªæ°´ã€‚ä½†ç¬¬ä¸€ç±»å·¥ç¨‹å¸ˆéšç€æ—¶é—´çš„æŽ¨ç§»ï¼Œä¼šæœç€æ›´æœ‰æˆå°±æ„Ÿå’Œæ›´é«˜æŠ¥é…¬çš„å·¥ä½œå‘å±•ï¼Œæ— è®ºæ˜¯æœ‰ä»·å€¼çš„å•†ä¸šå·¥ä½œè¿˜æ˜¯çªç ´æ€§çš„å¼€æºé¡¹ç›®ã€æŠ€æœ¯é¢†å¯¼åŠ›æˆ–é«˜è´¨é‡çš„ä¸ªäººè´¡çŒ®ã€‚

Type 1 engineers find ways to learn computer science in depth, whether through conventional means or by relentlessly learning throughout their careers. Type 2 engineers typically stay at the surface, learning specific tools and technologies rather than their underlying foundations, only picking up new skills when the winds of technical fashion change.

> ç¬¬ä¸€ç±»å·¥ç¨‹å¸ˆæ‰¾åˆ°äº†æ·±å…¥å­¦ä¹ è®¡ç®—æœºç§‘å­¦çš„æ–¹æ³•ï¼Œæ— è®ºæ˜¯é€šè¿‡ä¼ ç»Ÿçš„æ–¹æ³•è¿˜æ˜¯é€šè¿‡åœ¨æ•´ä¸ªèŒä¸šç”Ÿæ¶¯ä¸­ä¸æ‡ˆåœ°å­¦ä¹ ã€‚ç¬¬äºŒç±»å·¥ç¨‹å¸ˆé€šå¸¸åœç•™åœ¨è¡¨é¢ï¼Œå­¦ä¹ å…·ä½“çš„å·¥å…·å’ŒæŠ€æœ¯ï¼Œè€Œä¸æ˜¯å®ƒä»¬çš„åŸºç¡€ï¼Œåªæœ‰åœ¨æŠ€æœ¯æ—¶å°šçš„é£Žå‘æ”¹å˜æ—¶æ‰ä¼šå­¦ä¹ æ–°çš„æŠ€èƒ½ã€‚

Currently, the number of people entering the industry is rapidly increasing, while the number of CS grads is relatively static. This oversupply of Type 2 engineers is starting to reduce their employment opportunities and keep them out of the industryâ€™s more fulfilling work. Whether youâ€™re striving to become a Type 1 engineer or simply looking for more job security, learning computer science is the only reliable path.

> ç›®å‰ï¼Œè¿›å…¥è¯¥è¡Œä¸šçš„äººæ•°æ­£åœ¨è¿…é€Ÿå¢žåŠ ï¼Œè€ŒCSæ¯•ä¸šç”Ÿçš„æ•°é‡å´ç›¸å¯¹ç¨³å®šã€‚è¿™ç§ç¬¬äºŒç±»å·¥ç¨‹å¸ˆä¾›è¿‡äºŽæ±‚çš„æƒ…å†µå¼€å§‹å‡å°‘ä»–ä»¬çš„å°±ä¸šæœºä¼šï¼Œä½¿ä»–ä»¬æ— æ³•ä»Žäº‹è¯¥è¡Œä¸šæ›´æœ‰æˆå°±æ„Ÿçš„å·¥ä½œã€‚æ— è®ºä½ æ˜¯åŠªåŠ›æˆä¸ºç¬¬ä¸€ç±»å·¥ç¨‹å¸ˆï¼Œè¿˜æ˜¯ä»…ä»…ä¸ºäº†å¯»æ‰¾æ›´å¤šçš„å·¥ä½œä¿éšœï¼Œå­¦ä¹ è®¡ç®—æœºç§‘å­¦æ˜¯å”¯ä¸€å¯é çš„é€”å¾„ã€‚



## Subject guides

ä¸“é¢˜æŒ‡å—

### Programming

Most undergraduate CS programs start with an â€œintroductionâ€ to computer programming. The best versions of these courses cater not just to novices, but also to those who missed beneficial concepts and programming models while first learning to code.

> å¤§å¤šæ•°æœ¬ç§‘CSè¯¾ç¨‹ä»¥è®¡ç®—æœºç¼–ç¨‹çš„ "å…¥é—¨ "å¼€å§‹ã€‚è¿™äº›è¯¾ç¨‹çš„æœ€ä½³ç‰ˆæœ¬ä¸ä»…è¿Žåˆäº†æ–°æ‰‹ï¼Œä¹Ÿè¿Žåˆäº†é‚£äº›åœ¨ç¬¬ä¸€æ¬¡å­¦ä¹ ä»£ç æ—¶é”™è¿‡äº†æœ‰ç›Šæ¦‚å¿µå’Œç¼–ç¨‹æ¨¡åž‹çš„äººã€‚

Our standard recommendation for this content is the classic *Structure and Interpretation of Computer Programs*, which is available online for free both as [a book](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html), and as a set of [MIT video lectures](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/). While those lectures are great, our video suggestion is actually [Brian Harveyâ€™s SICP lectures](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter) (for the 61A course at Berkeley) instead. These are more refined and better targeted at new students than are the MIT lectures.

> æˆ‘ä»¬å¯¹è¿™äº›å†…å®¹çš„æ ‡å‡†æŽ¨èæ˜¯ç»å…¸çš„*ã€Šè®¡ç®—æœºç¨‹åºçš„ç»“æž„ä¸Žè§£é‡Šã€‹*ï¼Œå®ƒæ—¢å¯ä»¥ä½œä¸º[ä¹¦](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºä¸€å¥—[MITè§†é¢‘è®²åº§](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/)åœ¨ç½‘ä¸Šå…è´¹èŽ·å¾—ã€‚è™½ç„¶è¿™äº›è®²åº§å¾ˆå¥½ï¼Œä½†æˆ‘ä»¬çš„è§†é¢‘å»ºè®®å®žé™…ä¸Šæ˜¯[Brian Harveyçš„SICPè®²åº§](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter)ï¼ˆç”¨äºŽä¼¯å…‹åˆ©çš„61Aè¯¾ç¨‹ï¼‰ã€‚ä¸Žéº»çœç†å·¥å­¦é™¢çš„è®²åº§ç›¸æ¯”ï¼Œè¿™äº›è®²åº§æ›´ç²¾ç‚¼ï¼Œæ›´é’ˆå¯¹æ–°ç”Ÿã€‚

We recommend working through at least the first three chapters of SICP and doing the exercises. For additional practice, work through a set of small programming problems like those on [exercism](http://exercism.io/).

> æˆ‘ä»¬å»ºè®®è‡³å°‘è¯»å®ŒSICPçš„å‰ä¸‰ç« å¹¶åšç»ƒä¹ ã€‚ä¸ºäº†å¢žåŠ ç»ƒä¹ ï¼Œå¯ä»¥é€šè¿‡ä¸€ç»„å°çš„ç¼–ç¨‹é—®é¢˜ï¼Œå¦‚[exercism](http://exercism.io/)ä¸Šçš„é—®é¢˜ã€‚

Since this guide was first published in 2016, one of the most commonly asked questions has been whether weâ€™d now recommend recordings of a more recent iteration of 61A taught by John DeNero, and/or the corresponding book *[Composing Programs](https://composingprograms.com/)*, which is â€œin the tradition of SICPâ€ but uses Python. We think the DeNero resources are also great, and some students may end up preferring them, but we still suggest SICP, Scheme, and Brian Harveyâ€™s lectures as the first set of resources to try.

> è‡ªä»Žæœ¬æŒ‡å—åœ¨2016å¹´é¦–æ¬¡å‡ºç‰ˆä»¥æ¥ï¼Œæœ€å¸¸é—®çš„é—®é¢˜ä¹‹ä¸€æ˜¯æˆ‘ä»¬çŽ°åœ¨æ˜¯å¦ä¼šæŽ¨èJohn DeNeroè®²æŽˆçš„61Açš„æœ€æ–°è¿­ä»£å½•éŸ³ï¼Œå’Œ/æˆ–ç›¸åº”çš„ä¹¦*[Composing Programs](https://composingprograms.com/)*ï¼Œå®ƒæ˜¯ "SICPçš„ä¼ ç»Ÿ "ä½†ä½¿ç”¨Pythonã€‚æˆ‘ä»¬è®¤ä¸ºDeNeroçš„èµ„æºä¹Ÿå¾ˆå¥½ï¼Œæœ‰äº›å­¦ç”Ÿå¯èƒ½æœ€ç»ˆä¼šå–œæ¬¢å®ƒä»¬ï¼Œä½†æˆ‘ä»¬ä»ç„¶å»ºè®®æŠŠSICPã€Schemeå’ŒBrian Harveyçš„è®²åº§ä½œä¸ºç¬¬ä¸€å¥—èµ„æºæ¥å°è¯•ã€‚

Why? Because SICP is unique in its abilityâ€”at least potentiallyâ€”to alter your fundamental beliefs about computers and programming. Not everybody will experience this. Some will hate the book, others won't get past the first few pages. But the potential reward makes it worth trying.

> ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºSICPæ˜¯ç‹¬ä¸€æ— äºŒçš„ï¼Œå®ƒèƒ½å¤Ÿ--è‡³å°‘æ˜¯æ½œåœ¨åœ°--æ”¹å˜ä½ å¯¹è®¡ç®—æœºå’Œç¼–ç¨‹çš„åŸºæœ¬ä¿¡å¿µã€‚ä¸æ˜¯æ¯ä¸ªäººéƒ½ä¼šæœ‰è¿™ç§ä½“éªŒã€‚æœ‰äº›äººä¼šè®¨åŽŒè¿™æœ¬ä¹¦ï¼Œæœ‰äº›äººåˆ™è¿žå‰å‡ é¡µéƒ½çœ‹ä¸ä¸‹åŽ»äº†ã€‚ä½†æ˜¯ï¼Œæ½œåœ¨çš„å›žæŠ¥ä½¿å®ƒå€¼å¾—å°è¯•ã€‚

If you don't enjoy SICP, try *Composing Programs*. If that still doesn't suit, try *[How to Design Programs](http://www.htdp.org/)*. If none of these seem to be rewarding your effort, perhaps that's a sign that you should focus on other topics for some time, and revisit the discipline of programming in another year or two.

> å¦‚æžœä½ ä¸å–œæ¬¢SICPï¼Œå¯ä»¥è¯•è¯•*Composing Programs*ã€‚å¦‚æžœè¿˜æ˜¯ä¸é€‚åˆï¼Œå°±è¯•è¯•*[å¦‚ä½•è®¾è®¡ç¨‹åº](http://www.htdp.org/)*ã€‚å¦‚æžœè¿™äº›ä¼¼ä¹Žéƒ½ä¸èƒ½ä½¿ä½ çš„åŠªåŠ›å¾—åˆ°å›žæŠ¥ï¼Œä¹Ÿè®¸è¿™å°±æ˜¯ä¸€ä¸ªä¿¡å·ï¼Œä½ åº”è¯¥åœ¨ä¸€æ®µæ—¶é—´å†…ä¸“æ³¨äºŽå…¶ä»–ä¸»é¢˜ï¼Œå¹¶åœ¨å¦ä¸€å¹´æˆ–ä¸¤å¹´å†…é‡æ–°å®¡è§†ç¼–ç¨‹çš„å­¦ç§‘ã€‚

Finally, a point of clarification: this guide is NOT designed for those who are entirely new to programming. We assume that you are a competent programmer without a background in computer science, looking to fill in some knowledge gaps. The fact that we've included a section on "programming" is simply a reminder that there may be more to learn. For those who've never coded before, but who'd like to, you might prefer a guide like [this one](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started).

> æœ€åŽï¼Œæœ‰ä¸€ç‚¹éœ€è¦æ¾„æ¸…ï¼šæœ¬æŒ‡å—ä¸æ˜¯ä¸ºé‚£äº›å®Œå…¨ä¸æ‡‚ç¼–ç¨‹çš„äººè®¾è®¡çš„ã€‚æˆ‘ä»¬å‡è®¾ä½ æ˜¯ä¸€ä¸ªæœ‰èƒ½åŠ›çš„ç¨‹åºå‘˜ï¼Œæ²¡æœ‰è®¡ç®—æœºç§‘å­¦çš„èƒŒæ™¯ï¼Œå¸Œæœ›å¡«è¡¥ä¸€äº›çŸ¥è¯†ç©ºç™½ã€‚æˆ‘ä»¬åŒ…æ‹¬ "ç¼–ç¨‹ "ä¸€èŠ‚ï¼Œåªæ˜¯æé†’ä½ å¯èƒ½æœ‰æ›´å¤šçš„ä¸œè¥¿éœ€è¦å­¦ä¹ ã€‚å¯¹äºŽé‚£äº›ä»Žæ¥æ²¡æœ‰ç¼–è¿‡ä»£ç ï¼Œä½†åˆæƒ³å­¦çš„äººæ¥è¯´ï¼Œä½ å¯èƒ½æ›´å–œæ¬¢åƒ[è¿™ä¸ª](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started)è¿™æ ·çš„æŒ‡å—ã€‚
>



### Computer Architecture

Computer Architectureâ€”sometimes called â€œcomputer systemsâ€ or â€œcomputer organizationâ€â€”is an important first look at computing below the surface of software. In our experience, itâ€™s the most neglected area among self-taught software engineers.

> è®¡ç®—æœºä½“ç³»ç»“æž„--æœ‰æ—¶è¢«ç§°ä¸º "è®¡ç®—æœºç³»ç»Ÿ "æˆ– "è®¡ç®—æœºç»„ç»‡"--æ˜¯å¯¹è½¯ä»¶è¡¨é¢ä»¥ä¸‹çš„è®¡ç®—çš„ä¸€ä¸ªé‡è¦çš„åˆæ­¥äº†è§£ã€‚æ ¹æ®æˆ‘ä»¬çš„ç»éªŒï¼Œå®ƒæ˜¯è‡ªå­¦æˆæ‰çš„è½¯ä»¶å·¥ç¨‹å¸ˆä¸­æœ€å®¹æ˜“è¢«å¿½è§†çš„é¢†åŸŸã€‚

Our favorite introductory book is *[Computer Systems: A Programmer's Perspective](http://csapp.cs.cmu.edu/3e/home.html)*, and a typical introductory computer architecture course using the book [would cover](http://csapp.cs.cmu.edu/3e/courses.html) most of chapters 1-6.

> æˆ‘ä»¬æœ€å–œæ¬¢çš„å…¥é—¨ä¹¦æ˜¯*[è®¡ç®—æœºç³»ç»Ÿï¼šç¨‹åºå‘˜çš„è§†è§’](http://csapp.cs.cmu.edu/3e/home.html)*ï¼Œä½¿ç”¨è¯¥ä¹¦çš„å…¸åž‹è®¡ç®—æœºç»“æž„å…¥é—¨è¯¾ç¨‹[å°†æ¶µç›–](http://csapp.cs.cmu.edu/3e/courses.html)1-6ç« çš„å¤§éƒ¨åˆ†å†…å®¹ã€‚

We love CS:APP for the practical, programmer-oriented approach. While there's much more to computer architecture than what's covered in the book, it serves as a great starting point for those who'd like to understand computer systems primarily in order to write faster, more efficient and more reliable *software*.

> æˆ‘ä»¬å–œæ¬¢CS:APPçš„å®žç”¨ã€é¢å‘ç¨‹åºå‘˜çš„æ–¹æ³•ã€‚è™½ç„¶è®¡ç®—æœºä½“ç³»ç»“æž„æ¯”ä¹¦ä¸­æ‰€æ¶‰åŠçš„å†…å®¹è¦å¤šå¾—å¤šï¼Œä½†å¯¹äºŽé‚£äº›æƒ³äº†è§£è®¡ç®—æœºç³»ç»Ÿï¼Œä¸»è¦æ˜¯ä¸ºäº†ç¼–å†™æ›´å¿«ã€æ›´æœ‰æ•ˆã€æ›´å¯é çš„*è½¯ä»¶*çš„äººæ¥è¯´ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„èµ·ç‚¹ã€‚

For those who'd prefer both a gentler introduction to the topic and a balance of hardware and software concerns, we suggest *The Elements of Computing Systems*, also known as â€œNand2Tetrisâ€. This is an ambitious book attempting to give you a cohesive understanding of how everything in a computer works. Each chapter involves building a small piece of the overall system, from writing elementary logic gates in HDL, through a CPU and assembler, all the way to an application the size of a Tetris game.

> å¯¹äºŽé‚£äº›æ—¢å–œæ¬¢æ¯”è¾ƒæ¸©å’Œçš„ä¸»é¢˜ä»‹ç»ï¼Œåˆå–œæ¬¢å¹³è¡¡ç¡¬ä»¶å’Œè½¯ä»¶é—®é¢˜çš„äººæ¥è¯´ï¼Œæˆ‘ä»¬å»ºè®®*ã€Šè®¡ç®—æœºç³»ç»Ÿè¦ç´ ã€‹*ï¼Œä¹Ÿå«ã€ŠNand2Tetrisã€‹ã€‚è¿™æ˜¯ä¸€æœ¬é›„å¿ƒå‹ƒå‹ƒçš„ä¹¦ï¼Œè¯•å›¾è®©ä½ å¯¹è®¡ç®—æœºä¸­çš„ä¸€åˆ‡å¦‚ä½•å·¥ä½œæœ‰ä¸€ä¸ªè¿žè´¯çš„ç†è§£ã€‚æ¯ä¸€ç« éƒ½æ¶‰åŠæž„å»ºæ•´ä¸ªç³»ç»Ÿçš„ä¸€å°éƒ¨åˆ†ï¼Œä»Žç”¨HDLç¼–å†™åŸºæœ¬çš„é€»è¾‘é—¨ï¼Œåˆ°CPUå’Œæ±‡ç¼–ç¨‹åºï¼Œä¸€ç›´åˆ°ä¿„ç½—æ–¯æ–¹å—æ¸¸æˆå¤§å°çš„åº”ç”¨ç¨‹åºã€‚

We recommend reading through the first six chapters of the book and completing the associated projects. This will develop your understanding of the relationship between the architecture of the machine and the software that runs on it.

> æˆ‘ä»¬å»ºè®®é€šè¯»æœ¬ä¹¦çš„å‰å…­ç« å¹¶å®Œæˆç›¸å…³çš„é¡¹ç›®ã€‚è¿™å°†åŸ¹å…»ä½ å¯¹æœºå™¨çš„ç»“æž„å’Œåœ¨å…¶ä¸Šè¿è¡Œçš„è½¯ä»¶ä¹‹é—´å…³ç³»çš„ç†è§£ã€‚

The first half of the book (and all of its projects), are available for free from [the Nand2Tetris website](http://www.nand2tetris.org/). Itâ€™s also available as [a Coursera course with accompanying videos](https://www.coursera.org/learn/build-a-computer).

> è¿™æœ¬ä¹¦çš„å‰åŠéƒ¨åˆ†ï¼ˆä»¥åŠæ‰€æœ‰çš„é¡¹ç›®ï¼‰ï¼Œå¯ä»¥ä»Ž[Nand2Tetrisç½‘ç«™](http://www.nand2tetris.org/)å…è´¹èŽ·å¾—ã€‚å®ƒä¹Ÿå¯ä»¥ä½œä¸º[å¸¦æœ‰é…å¥—è§†é¢‘çš„Courseraè¯¾ç¨‹](https://www.coursera.org/learn/build-a-computer)ã€‚

In seeking simplicity and cohesiveness, Nand2Tetris trades off depth. In particular, two very important concepts in modern computer architectures are pipelining and memory hierarchy, but both are mostly absent from the text.

> ä¸ºäº†è¿½æ±‚ç®€å•å’Œå‡èšåŠ›ï¼ŒNand2Tetrisç‰ºç‰²äº†æ·±åº¦ã€‚ç‰¹åˆ«æ˜¯ï¼ŒçŽ°ä»£è®¡ç®—æœºæž¶æž„ä¸­ä¸¤ä¸ªéžå¸¸é‡è¦çš„æ¦‚å¿µæ˜¯æµæ°´çº¿å’Œå†…å­˜å±‚æ¬¡ç»“æž„ï¼Œä½†è¿™ä¸¤ä¸ªæ¦‚å¿µåœ¨æ–‡ä¸­å¤§å¤šæ²¡æœ‰å‡ºçŽ°ã€‚
>

Once you feel comfortable with the content of Nand2Tetris, we suggest either returning to CS:APP, or considering Patterson and Hennessyâ€™s *[Computer Organization and Design](https://smile.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269)*, an excellent and now classic text. Not every section in the book is essential; we suggest following Berkeleyâ€™s [CS61C course](http://inst.eecs.berkeley.edu/~cs61c/sp15/) â€œGreat Ideas in Computer Architectureâ€ for specific readings. The lecture notes and labs are available online, and past lectures are [on the Internet Archive](https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_).

> ä¸€æ—¦ä½ å¯¹Nand2Tetrisçš„å†…å®¹æ„Ÿåˆ°æ»¡æ„ï¼Œæˆ‘ä»¬å»ºè®®ä½ å›žåˆ°CS:APPï¼Œæˆ–è€…è€ƒè™‘Pattersonå’ŒHennessyçš„*[è®¡ç®—æœºç»„ç»‡ä¸Žè®¾è®¡](https://smile.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269)*ï¼Œè¿™æ˜¯ä¸€æœ¬ä¼˜ç§€çš„ã€çŽ°åœ¨å·²ç»æˆä¸ºç»å…¸çš„æ–‡æœ¬ã€‚å¹¶éžä¹¦ä¸­çš„æ¯ä¸€èŠ‚éƒ½æ˜¯å¿…è¦çš„ï¼›æˆ‘ä»¬å»ºè®®æŒ‰ç…§ä¼¯å…‹åˆ©çš„[CS61Cè¯¾ç¨‹](http://inst.eecs.berkeley.edu/~cs61c/sp15/) "è®¡ç®—æœºç»“æž„ä¸­çš„ä¼Ÿå¤§æ€æƒ³ "è¿›è¡Œå…·ä½“é˜…è¯»ã€‚è®²ä¹‰å’Œå®žéªŒå¯ä»¥åœ¨ç½‘ä¸Šæ‰¾åˆ°ï¼Œè¿‡åŽ»çš„è®²ä¹‰ä¹Ÿåœ¨[äº’è”ç½‘æ¡£æ¡ˆé¦†](https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_)ä¸Šã€‚



### Algorithms and Data Structures

We agree with decades of common wisdom that familiarity with common algorithms and data structures is one of the most empowering aspects of a computer science education. This is also a great place to train oneâ€™s general problem-solving abilities, which will pay off in every other area of study.

> æˆ‘ä»¬åŒæ„å‡ åå¹´æ¥çš„æ™®éçœ‹æ³•ï¼Œå³ç†Ÿæ‚‰æ™®é€šç®—æ³•å’Œæ•°æ®ç»“æž„æ˜¯è®¡ç®—æœºç§‘å­¦æ•™è‚²ä¸­æœ€æœ‰èƒ½åŠ›çš„æ–¹é¢ä¹‹ä¸€ã€‚è¿™ä¹Ÿæ˜¯è®­ç»ƒä¸€ä¸ªäººçš„ä¸€èˆ¬é—®é¢˜è§£å†³èƒ½åŠ›çš„å¥½åœ°æ–¹ï¼Œè¿™å°†åœ¨æ¯ä¸ªå…¶ä»–ç ”ç©¶é¢†åŸŸå¾—åˆ°å›žæŠ¥ã€‚

There are hundreds of books available, but our favorite is *[The Algorithm Design Manual](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/)* by Steven Skiena. He clearly loves algorithmic problem solving and typically succeeds in fostering similar enthusiasm among his students and readers. In our opinion, the two more commonly suggested texts (CLRS and Sedgewick) tend to be a little too proof-heavy for those learning the material primarily to help with practical problem solving.

> æœ‰æ•°ä»¥ç™¾è®¡çš„ä¹¦ç±ï¼Œä½†æˆ‘ä»¬æœ€å–œæ¬¢çš„æ˜¯*[ã€Šç®—æ³•è®¾è®¡æ‰‹å†Œã€‹](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/)*ï¼Œä½œè€…æ˜¯Steven Skienaã€‚ä»–æ˜¾ç„¶çƒ­çˆ±ç®—æ³•é—®é¢˜çš„è§£å†³ï¼Œå¹¶ä¸”é€šå¸¸æˆåŠŸåœ°åœ¨ä»–çš„å­¦ç”Ÿå’Œè¯»è€…ä¸­åŸ¹å…»äº†ç±»ä¼¼çš„çƒ­æƒ…ã€‚åœ¨æˆ‘ä»¬çœ‹æ¥ï¼Œä¸¤æœ¬æ›´å¸¸è§çš„æŽ¨èä¹¦ç›®ï¼ˆCLRSå’ŒSedgewickï¼‰å¯¹äºŽé‚£äº›ä¸»è¦ä¸ºäº†å¸®åŠ©è§£å†³å®žé™…é—®é¢˜è€Œå­¦ä¹ è¿™äº›ææ–™çš„äººæ¥è¯´ï¼Œå¾€å¾€æœ‰ç‚¹å¤ªé‡è¯æ˜Žäº†ã€‚

For those who prefer video lectures, [Skiena generously provides his online](https://www3.cs.stonybrook.edu/~skiena/373/videos/). We also really like Tim Roughgardenâ€™s course, available [on Coursera](https://www.coursera.org/specializations/algorithms) and [elsewhere](http://timroughgarden.org/videos.html). Whether you prefer Skienaâ€™s or Roughgardenâ€™s lecture style will be a matter of personal preference. In fact, there are dozens of good alternatives, so if you happen to find another that you like, we encourage you to stick with it!

> å¯¹äºŽé‚£äº›å–œæ¬¢è§†é¢‘è®²åº§çš„äººï¼Œ[Skienaæ…·æ…¨åœ°æä¾›ä»–çš„åœ¨çº¿](https://www3.cs.stonybrook.edu/~skiena/373/videos/)ã€‚æˆ‘ä»¬ä¹Ÿéžå¸¸å–œæ¬¢Tim Roughgardençš„è¯¾ç¨‹ï¼Œ[åœ¨Coursera](https://www.coursera.org/specializations/algorithms)å’Œ[å…¶ä»–åœ°æ–¹](http://timroughgarden.org/videos.html)ã€‚ä½ æ˜¯å–œæ¬¢Skienaçš„è¿˜æ˜¯Roughgardençš„è®²è¯¾é£Žæ ¼å°†æ˜¯ä¸€ä¸ªä¸ªäººåå¥½çš„é—®é¢˜ã€‚äº‹å®žä¸Šï¼Œæœ‰å‡ åä¸ªå¾ˆå¥½çš„æ›¿ä»£å“ï¼Œæ‰€ä»¥å¦‚æžœä½ ç¢°å·§æ‰¾åˆ°äº†ä½ å–œæ¬¢çš„å¦ä¸€ä¸ªï¼Œæˆ‘ä»¬é¼“åŠ±ä½ åšæŒä¸‹åŽ»

For practice, our preferred approach is for students to solve problems on [Leetcode](http://leetcode.com/). These tend to be interesting problems with decent accompanying solutions and discussions. They also help you test progress against questions that are commonly used in technical interviews at the more competitive software companies. We suggest solving around 100 random leetcode problems as part of your studies.

> å¯¹äºŽå®žè·µï¼Œæˆ‘ä»¬é¦–é€‰çš„æ–¹æ³•æ˜¯è®©å­¦ç”Ÿåœ¨[Leetcode](http://leetcode.com/)ä¸Šè§£å†³é—®é¢˜ã€‚è¿™äº›é—®é¢˜å¾€å¾€æ˜¯æœ‰è¶£çš„ï¼Œå¹¶æœ‰å¾ˆå¥½çš„é…å¥—è§£å†³æ–¹æ¡ˆå’Œè®¨è®ºã€‚å®ƒä»¬è¿˜å¯ä»¥å¸®åŠ©ä½ æµ‹è¯•åœ¨ç«žäº‰æ¿€çƒˆçš„è½¯ä»¶å…¬å¸çš„æŠ€æœ¯é¢è¯•ä¸­å¸¸ç”¨çš„é—®é¢˜çš„è¿›å±•ã€‚æˆ‘ä»¬å»ºè®®è§£å†³å¤§çº¦100ä¸ªéšæœºçš„leetcodeé—®é¢˜ä½œä¸ºä½ å­¦ä¹ çš„ä¸€éƒ¨åˆ†ã€‚

Finally, we strongly recommend *[How to Solve It](https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/)* as an excellent and unique guide to general problem solving; itâ€™s as applicable to computer science as it is to mathematics.

> æœ€åŽï¼Œæˆ‘ä»¬å¼ºçƒˆæŽ¨è*[å¦‚ä½•è§£å†³](https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/)*ï¼Œä½œä¸ºä¸€èˆ¬é—®é¢˜è§£å†³çš„ä¼˜ç§€å’Œç‹¬ç‰¹æŒ‡å—ï¼›å®ƒå¯¹è®¡ç®—æœºç§‘å­¦å’Œæ•°å­¦ä¸€æ ·é€‚ç”¨ã€‚



### Mathematics for Computer Science

In some ways, computer science is an overgrown branch of applied mathematics. While many software engineers tryâ€”and to varying degrees succeedâ€”at ignoring this, we encourage you to embrace it with direct study. Doing so successfully will give you an enormous competitive advantage over those who donâ€™t.

> åœ¨æŸäº›æ–¹é¢ï¼Œè®¡ç®—æœºç§‘å­¦æ˜¯åº”ç”¨æ•°å­¦çš„ä¸€ä¸ªè¿‡åº¦å‘å±•çš„åˆ†æ”¯ã€‚è™½ç„¶è®¸å¤šè½¯ä»¶å·¥ç¨‹å¸ˆè¯•å›¾--å¹¶åœ¨ä¸åŒç¨‹åº¦ä¸ŠæˆåŠŸåœ°--å¿½è§†è¿™ä¸€ç‚¹ï¼Œä½†æˆ‘ä»¬é¼“åŠ±ä½ é€šè¿‡ç›´æŽ¥å­¦ä¹ æ¥æ‹¥æŠ±å®ƒã€‚æˆåŠŸåœ°è¿™æ ·åšå°†ä½¿ä½ æ¯”é‚£äº›ä¸è¿™æ ·åšçš„äººæœ‰å·¨å¤§çš„ç«žäº‰ä¼˜åŠ¿ã€‚

The most relevant area of math for CS is broadly called â€œdiscrete mathematicsâ€, where â€œdiscreteâ€ is the opposite of â€œcontinuousâ€ and is loosely a collection of interesting applied math topics outside of calculus. Given the vague definition, itâ€™s not meaningful to try to cover the entire breadth of â€œdiscrete mathematicsâ€. A more realistic goal is to build a working understanding of logic, combinatorics and probability, set theory, graph theory, and a little of the number theory informing cryptography. Linear algebra is an additional worthwhile area of study, given its importance in computer graphics and machine learning.

> ä¸ŽCSæœ€ç›¸å…³çš„æ•°å­¦é¢†åŸŸè¢«å¹¿æ³›ç§°ä¸º "ç¦»æ•£æ•°å­¦"ï¼Œå…¶ä¸­ "ç¦»æ•£ "ä¸Ž "è¿žç»­ "ç›¸åï¼Œæ˜¯å¾®ç§¯åˆ†ä¹‹å¤–æœ‰è¶£çš„åº”ç”¨æ•°å­¦è¯¾é¢˜çš„æ¾æ•£é›†åˆã€‚è€ƒè™‘åˆ°è¿™ä¸ªæ¨¡ç³Šçš„å®šä¹‰ï¼Œè¯•å›¾æ¶µç›– "ç¦»æ•£æ•°å­¦ "çš„å…¨éƒ¨èŒƒå›´æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚ä¸€ä¸ªæ›´çŽ°å®žçš„ç›®æ ‡æ˜¯å»ºç«‹å¯¹é€»è¾‘å­¦ã€ç»„åˆå­¦å’Œæ¦‚çŽ‡è®ºã€é›†åˆè®ºã€å›¾è®ºçš„å·¥ä½œç†è§£ï¼Œä»¥åŠä¸ºå¯†ç å­¦æä¾›ä¿¡æ¯çš„å°‘é‡æ•°è®ºã€‚é‰´äºŽçº¿æ€§ä»£æ•°åœ¨è®¡ç®—æœºå›¾å½¢å’Œæœºå™¨å­¦ä¹ ä¸­çš„é‡è¦æ€§ï¼Œå®ƒæ˜¯ä¸€ä¸ªé¢å¤–çš„å€¼å¾—ç ”ç©¶çš„é¢†åŸŸã€‚

Our suggested starting point for discrete mathematics is the set of [lecture notes by LÃ¡szlÃ³ LovÃ¡sz](https://cims.nyu.edu/~regev/teaching/discrete_math_fall_2005/dmbook.pdf). Professor LovÃ¡sz did a good job of making the content approachable and intuitive, so this serves as a better starting point than more formal texts.

> æˆ‘ä»¬å»ºè®®ç¦»æ•£æ•°å­¦çš„èµ·ç‚¹æ˜¯ä¸€å¥—[LÃ¡szlÃ³ LovÃ¡szçš„è®²ä¹‰](https://cims.nyu.edu/~regev/teaching/discrete_math_fall_2005/dmbook.pdf)ã€‚LovÃ¡szæ•™æŽˆå¾ˆå¥½åœ°å°†å†…å®¹å˜å¾—å¹³æ˜“è¿‘äººå’Œç›´è§‚ï¼Œæ‰€ä»¥è¿™å¯ä»¥ä½œä¸ºä¸€ä¸ªæ¯”æ›´æ­£å¼æ–‡æœ¬æ›´å¥½çš„èµ·ç‚¹ã€‚

For a more advanced treatment, we suggest *[Mathematics for Computer Science](https://courses.csail.mit.edu/6.042/spring17/mcs.pdf)*, the book-length lecture notes for the MIT course of the same name. That courseâ€™s video lectures are also [freely available](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/), and are our recommended video lectures for discrete math.

> å¯¹äºŽæ›´é«˜çº§çš„å¤„ç†ï¼Œæˆ‘ä»¬å»ºè®®*[Mathematics for Computer Science](https://courses.csail.mit.edu/6.042/spring17/mcs.pdf)*ï¼Œè¿™æ˜¯éº»çœç†å·¥å­¦é™¢åŒåè¯¾ç¨‹çš„é•¿ç¯‡è®²ä¹‰ã€‚è¯¥è¯¾ç¨‹çš„è§†é¢‘è®²åº§ä¹Ÿæ˜¯[å…è´¹æä¾›](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/)ï¼Œè€Œä¸”æ˜¯æˆ‘ä»¬æŽ¨èçš„ç¦»æ•£æ•°å­¦çš„è§†é¢‘è®²åº§ã€‚

For linear algebra, we suggest starting with the [Essence of linear algebra](https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab) video series, followed by Gilbert Strangâ€™s [book](https://www.amazon.com/Introduction-Linear-Algebra-Gilbert-Strang/dp/0980232775/) and [video lectures](https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/).

> å¯¹äºŽçº¿æ€§ä»£æ•°ï¼Œæˆ‘ä»¬å»ºè®®ä»Ž[çº¿æ€§ä»£æ•°ç²¾åŽ](https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab)ç³»åˆ—è§†é¢‘å¼€å§‹ï¼Œç„¶åŽæ˜¯Gilbert Strangçš„[ä¹¦](https://www.amazon.com/Introduction-Linear-Algebra-Gilbert-Strang/dp/0980232775/)å’Œ[è§†é¢‘è®²åº§](https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/)ã€‚



### Operating Systems

*[Operating System Concepts](https://www.amazon.com/dp/1118063333/)* (the â€œDinosaur bookâ€) and *[Modern Operating Systems](https://www.amazon.com/dp/013359162X/)* are the â€œclassicâ€ books on operating systems. Both have attracted criticism for their lack of clarity and general student unfriendliness.

> *[æ“ä½œç³»ç»Ÿæ¦‚å¿µ](https://www.amazon.com/dp/1118063333/)*ï¼ˆ"æé¾™ä¹¦"ï¼‰å’Œ*[çŽ°ä»£æ“ä½œç³»ç»Ÿ](https://www.amazon.com/dp/013359162X/)*æ˜¯æ“ä½œç³»ç»Ÿçš„ "ç»å…¸ "ä¹¦ç±ã€‚è¿™ä¸¤æœ¬ä¹¦éƒ½å› ä¸ºç¼ºä¹æ¸…æ™°åº¦å’Œå¯¹å­¦ç”Ÿä¸å‹å¥½è€Œå—åˆ°æ‰¹è¯„ã€‚

*Operating Systems: Three Easy Pieces* is a good alternative thatâ€™s [freely available online](http://pages.cs.wisc.edu/~remzi/OSTEP/). We particularly like the structure and readability of the book, and feel that the exercises are worthwhile.

> *Operating Systems: Three Easy Pieces*æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ï¼Œå®ƒå¯ä»¥[å…è´¹åœ¨çº¿èŽ·å–](http://pages.cs.wisc.edu/~remzi/OSTEP/)ã€‚æˆ‘ä»¬ç‰¹åˆ«å–œæ¬¢è¿™æœ¬ä¹¦çš„ç»“æž„å’Œå¯è¯»æ€§ï¼Œå¹¶è®¤ä¸ºå…¶ç»ƒä¹ æ˜¯å€¼å¾—çš„ã€‚

After OSTEP, we encourage you to explore the design decisions of specific operating systems, through â€œ{OS name} Internalsâ€ style books such as *[Lion's commentary on Unix](https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/)*, *[The Design and Implementation of the FreeBSD Operating System](https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/)*, and *[Mac OS X Internals](https://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542/)*. For Linux, we suggest Robert Love's fantastic [Linux Kernel Development](https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468).

> åœ¨OSTEPä¹‹åŽï¼Œæˆ‘ä»¬é¼“åŠ±ä½ é€šè¿‡"{OS name} Internals "é£Žæ ¼çš„ä¹¦ç±ï¼Œå¦‚*[Lion's commentary on Unix](https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/)*ï¼Œ*[The Design and Implementation of the FreeBSD Operating System](https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/)*ï¼Œå’Œ*[Mac OS X Internals](https://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542/)*ï¼ŒæŽ¢ç´¢ç‰¹å®šæ“ä½œç³»ç»Ÿçš„è®¾è®¡å†³å®šã€‚å¯¹äºŽLinuxï¼Œæˆ‘ä»¬æŽ¨èRobert Loveç²¾å½©çš„[Linux Kernel Development](https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468)ã€‚

A great way to consolidate your understanding of operating systems is to read the code of a small kernel and add features. One choice is [xv6](https://pdos.csail.mit.edu/6.828/2016/xv6.html), a port of Unix V6 to ANSI C and x86, maintained for a course at MIT. OSTEP has an appendix of potential [xv6 labs](http://pages.cs.wisc.edu/~remzi/OSTEP/lab-projects-xv6.pdf) full of great ideas for potential projects.

> å·©å›ºä½ å¯¹æ“ä½œç³»ç»Ÿçš„ç†è§£çš„ä¸€ä¸ªå¥½æ–¹æ³•æ˜¯é˜…è¯»ä¸€ä¸ªå°å†…æ ¸çš„ä»£ç å¹¶æ·»åŠ åŠŸèƒ½ã€‚ä¸€ä¸ªé€‰æ‹©æ˜¯[xv6](https://pdos.csail.mit.edu/6.828/2016/xv6.html)ï¼Œè¿™æ˜¯ä¸€ä¸ªå°†Unix V6ç§»æ¤åˆ°ANSI Cå’Œx86çš„ç‰ˆæœ¬ï¼Œä¸ºéº»çœç†å·¥å­¦é™¢çš„ä¸€é—¨è¯¾ç¨‹æ‰€ç»´æŠ¤ã€‚OSTEPæœ‰ä¸€ä¸ªæ½œåœ¨çš„[xv6å®žéªŒå®¤](http://pages.cs.wisc.edu/~remzi/OSTEP/lab-projects-xv6.pdf)çš„é™„å½•ï¼Œå……æ»¡äº†å¯¹æ½œåœ¨é¡¹ç›®çš„ä¼Ÿå¤§æƒ³æ³•ã€‚

### Computer Networking

Given that so much of software engineering is on web servers and clients, one of the most immediately valuable areas of computer science is computer networking. Our self-taught students who methodically study networking find that they finally understand terms, concepts and protocols theyâ€™d been surrounded by for years.

Our favorite book on the topic is *[Computer Networking: A Top-Down Approach](https://smile.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149/)*. The small projects and exercises in the book are well worth doing, and we particularly like the â€œWireshark labsâ€, which they have [generously provided online](http://www-net.cs.umass.edu/wireshark-labs/).

For those who prefer video lectures, we suggest Stanfordâ€™s [*Introduction to Computer Networking course*](https://www.youtube.com/playlist?list=PLoCMsyE1cvdWKsLVyf6cPwCLDIZnOj0NS) previously available via Stanford's MOOC platform Lagunita, but sadly now only available as unofficial playlists on Youtube.



---



# Learn programming

## Welcome

Welcome to [/r/learnprogramming](https://www.reddit.com/r/learnprogramming). This is a list of some of the most frequently asked questions on this subreddit. If your question is one of these, it has probably been answered many times before, and you should try using reddit's search facilities (look in the sidebar) to find previous answers before posting here.

> æ¬¢è¿Žæ¥åˆ°[/r/learnprogramming](https://www.reddit.com/r/learnprogramming)ã€‚è¿™æ˜¯æœ¬åˆ†è®ºå›ä¸Šä¸€äº›æœ€å¸¸é—®çš„é—®é¢˜çš„åˆ—è¡¨ã€‚å¦‚æžœä½ çš„é—®é¢˜æ˜¯å…¶ä¸­ä¹‹ä¸€ï¼Œå®ƒå¯èƒ½å·²ç»è¢«å›žç­”è¿‡å¾ˆå¤šæ¬¡äº†ï¼Œä½ åº”è¯¥å°è¯•ä½¿ç”¨redditçš„æœç´¢åŠŸèƒ½ï¼ˆåœ¨ä¾§è¾¹æ ä¸­æŸ¥çœ‹ï¼‰ï¼Œåœ¨è¿™é‡Œå‘å¸–ä¹‹å‰æ‰¾åˆ°ä»¥å‰çš„ç­”æ¡ˆã€‚



## Getting Started

### Where do I start?

If you're interested in learning to code, it's very helpful to start with the right mindset. This [YouTube video](https://www.youtube.com/watch?v=mvK0UzFNw1Q) by Kevin Cheers does a great job of explaining the proper perspective you should have when starting out.

> å¦‚æžœä½ å¯¹å­¦ä¹ ä»£ç æ„Ÿå…´è¶£ï¼Œä»¥æ­£ç¡®çš„å¿ƒæ€å¼€å§‹æ˜¯å¾ˆæœ‰å¸®åŠ©çš„ã€‚å‡¯æ–‡-åˆ‡å°”æ–¯çš„è¿™ä¸ª[YouTubeè§†é¢‘](https://www.youtube.com/watch?v=mvK0UzFNw1Q)å¾ˆå¥½åœ°è§£é‡Šäº†ä½ åœ¨å¼€å§‹æ—¶åº”è¯¥æœ‰çš„æ­£ç¡®è§‚ç‚¹ã€‚

Next, you should keep in mind that there's no universally agreed way of learning to code -- everybody prefers learning in a slightly different way, and you may need to do some experimenting to find an approach that works best for you. Nevertheless, the majority of people seem to learn best using the following approach, which we strongly recommend you try:

> æŽ¥ä¸‹æ¥ï¼Œä½ åº”è¯¥è®°ä½ï¼Œæ²¡æœ‰æ™®éè®¤åŒçš„å­¦ä¹ ä»£ç çš„æ–¹æ³•--æ¯ä¸ªäººå–œæ¬¢çš„å­¦ä¹ æ–¹å¼ç•¥æœ‰ä¸åŒï¼Œä½ å¯èƒ½éœ€è¦åšä¸€äº›å®žéªŒæ¥æ‰¾åˆ°æœ€é€‚åˆä½ çš„æ–¹æ³•ã€‚ç„¶è€Œï¼Œå¤§å¤šæ•°äººä¼¼ä¹Žä½¿ç”¨ä»¥ä¸‹æ–¹æ³•å­¦ä¹ æ•ˆæžœæœ€å¥½ï¼Œæˆ‘ä»¬å¼ºçƒˆå»ºè®®ä½ å°è¯•è¿™ç§æ–¹æ³•ã€‚
>

1. Find some small problem or project that you're interested in tackling. You could try building a tool to solve a small problem in your life, or try implementing a program you find interesting from scratch. This project will help motivate you to continue to learn to code and will give you opportunities to practice applying what you're learning.
2. Do some research to figure out which programming language is most appropriate for your project. (See below for recommendations)
3. Find and follow a single, high-quality beginner-oriented resource for that language. (Again, see below)
4. Supplement that resource by googling and asking questions
5. Eventually complete several non-trivial projects using that language.

> 1. æ‰¾åˆ°ä¸€äº›ä½ æœ‰å…´è¶£è§£å†³çš„å°é—®é¢˜æˆ–é¡¹ç›®ã€‚ä½ å¯ä»¥å°è¯•å»ºç«‹ä¸€ä¸ªå·¥å…·æ¥è§£å†³ä½ ç”Ÿæ´»ä¸­çš„ä¸€ä¸ªå°é—®é¢˜ï¼Œæˆ–è€…å°è¯•ä»Žå¤´å¼€å§‹å®žæ–½ä¸€ä¸ªä½ è§‰å¾—æœ‰è¶£çš„ç¨‹åºã€‚è¿™ä¸ªé¡¹ç›®å°†æœ‰åŠ©äºŽæ¿€åŠ±ä½ ç»§ç»­å­¦ä¹ ä»£ç ï¼Œå¹¶è®©ä½ æœ‰æœºä¼šå®žè·µåº”ç”¨ä½ æ‰€å­¦çš„çŸ¥è¯†ã€‚
> 2. åšä¸€äº›ç ”ç©¶ï¼Œæ‰¾å‡ºå“ªç§ç¼–ç¨‹è¯­è¨€æœ€é€‚åˆä½ çš„é¡¹ç›®ã€‚(å»ºè®®è§ä¸‹æ–‡)
> 3. æ‰¾åˆ°å¹¶å…³æ³¨è¯¥è¯­è¨€çš„å•ä¸€çš„ã€é«˜è´¨é‡çš„é¢å‘åˆå­¦è€…çš„èµ„æºã€‚(åŒæ ·ï¼Œè§ä¸‹æ–‡)
> 4. é€šè¿‡è°·æ­Œæœç´¢å’Œæé—®æ¥è¡¥å……è¯¥èµ„æº
> 5. æœ€ç»ˆå®Œæˆå‡ ä¸ªä½¿ç”¨è¯¥è¯­è¨€çš„éžå¾®ä¸è¶³é“çš„é¡¹ç›®ã€‚

Here are some things we recommend you avoid doing:

> ä»¥ä¸‹æ˜¯æˆ‘ä»¬å»ºè®®ä½ é¿å…åšçš„ä¸€äº›äº‹æƒ…ã€‚

1. Don't just simply passively follow along whatever resource you're using. Do the exercises and homework assignments; practice is an absolutely essential part of learning to code.
2. Avoid needlessly switching back and forth between programming languages; pick one and stick with it. This is because programming is ultimately about problem solving, not about programming languages. Learning to problem-solve is challenging and is a skill you can hone only through practice. Every time you switch languages, you're losing time you could have spent practicing applying what you've learned to improve your problem-solving skills.
3. Don't stop learning once you've completed a tutorial. Programming is the kind of field where there's always something new to learn.

> 1. ä¸è¦åªæ˜¯ç®€å•åœ°è¢«åŠ¨åœ°è·Ÿç€ä½ ä½¿ç”¨çš„ä»»ä½•èµ„æºèµ°ã€‚åš**ç»ƒä¹ å’Œå®¶åº­ä½œä¸š**ï¼›**ç»ƒä¹ **æ˜¯å­¦ä¹ ä»£ç çš„ä¸€ä¸ªç»å¯¹å¿…è¦çš„éƒ¨åˆ†ã€‚
> 2. é¿å…ä¸å¿…è¦åœ°åœ¨ç¼–ç¨‹è¯­è¨€ä¹‹é—´æ¥å›žåˆ‡æ¢ï¼›**é€‰æ‹©ä¸€ç§å¹¶åšæŒä¸‹åŽ»**ã€‚è¿™æ˜¯å› ä¸ºç¼–ç¨‹æœ€ç»ˆæ˜¯**å…³äºŽé—®é¢˜çš„è§£å†³**ï¼Œè€Œä¸æ˜¯å…³äºŽç¼–ç¨‹è¯­è¨€ã€‚å­¦ä¹ è§£å†³é—®é¢˜æ˜¯å…·æœ‰æŒ‘æˆ˜æ€§çš„ï¼Œæ˜¯ä¸€ç§åªæœ‰é€šè¿‡å®žè·µæ‰èƒ½**ç£¨ç»ƒ**å‡ºæ¥çš„æŠ€èƒ½ã€‚æ¯å½“ä½ åˆ‡æ¢è¯­è¨€æ—¶ï¼Œä½ å°±ä¼šæŸå¤±ä¸€äº›æ—¶é—´ï¼Œè€Œè¿™äº›æ—¶é—´æœ¬å¯ä»¥ç”¨æ¥ç»ƒä¹ åº”ç”¨ä½ æ‰€å­¦åˆ°çš„çŸ¥è¯†æ¥æé«˜ä½ è§£å†³é—®é¢˜çš„èƒ½åŠ›ã€‚
> 3. ä¸€æ—¦ä½ å®Œæˆäº†ä¸€ä¸ªæ•™ç¨‹ï¼Œä¸è¦åœæ­¢å­¦ä¹ ã€‚ç¼–ç¨‹æ˜¯é‚£ç§**æ€»æ˜¯æœ‰æ–°ä¸œè¥¿è¦å­¦**çš„é¢†åŸŸã€‚

And finally, remember that learning to code can be a [long](http://norvig.com/21-days.html) and [difficult](https://www.thinkful.com/blog/why-learning-to-code-is-so-damn-hard/) process. If learning to code feels hard, don't get discouraged! That's completely normal -- many people will spend years of their lives learning and practicing before they consider themselves competent enough to look for a job or contribute to a significant project. Fortunately, just getting started is not difficult at all.

> æœ€åŽï¼Œè¯·è®°ä½ï¼Œå­¦ä¹ ä»£ç å¯èƒ½æ˜¯ä¸€ä¸ª[æ¼«é•¿](http://norvig.com/21-days.html)å’Œ[å›°éš¾](https://www.thinkful.com/blog/why-learning-to-code-is-so-damn-hard/)çš„è¿‡ç¨‹ã€‚å¦‚æžœå­¦ä¹ ä»£ç æ„Ÿåˆ°å›°éš¾ï¼Œä¸è¦ç°å¿ƒï¼è¿™å®Œå…¨æ˜¯æ­£å¸¸çš„ã€‚è¿™æ˜¯å®Œå…¨æ­£å¸¸çš„ -- è®¸å¤šäººåœ¨ä»–ä»¬è®¤ä¸ºè‡ªå·±æœ‰èƒ½åŠ›å¯»æ‰¾å·¥ä½œæˆ–ä¸ºä¸€ä¸ªé‡è¦çš„é¡¹ç›®åšå‡ºè´¡çŒ®ä¹‹å‰ï¼Œä¼šèŠ±è´¹æ•°å¹´çš„æ—¶é—´æ¥å­¦ä¹ å’Œç»ƒä¹ ã€‚å¹¸è¿çš„æ˜¯ï¼Œåˆšå¼€å§‹å­¦ä¹ ä¸€ç‚¹éƒ½ä¸éš¾ã€‚

### Which programming language should I start with?

There are two common misconceptions that cause people to ask this question. The first is that there actually is a "best" programming language for learning and the second is that the first language you learn will decide what the rest of your programming career looks like.

> æœ‰ä¸¤ä¸ªå¸¸è§çš„è¯¯è§£ï¼Œå¯¼è‡´äººä»¬é—®è¿™ä¸ªé—®é¢˜ã€‚ç¬¬ä¸€ä¸ªæ˜¯ï¼Œå®žé™…ä¸Šæœ‰ä¸€ç§ "æœ€å¥½çš„ "ç¼–ç¨‹è¯­è¨€å¯ä¾›å­¦ä¹ ï¼Œç¬¬äºŒä¸ªæ˜¯ï¼Œä½ å­¦ä¹ çš„ç¬¬ä¸€ç§è¯­è¨€å°†å†³å®šä½ å…¶ä½™çš„ç¼–ç¨‹ç”Ÿæ¶¯æ˜¯ä»€ä¹ˆæ ·å­ã€‚

In reality, there is no best language to start with, and your first language has virtually no lasting effect on your eventual career. Programming languages can look very different on the surface, but the majority of the fundamental concepts will transfer from language to language. Learning a new language will also get easier over time -- it can take a beginner months before they feel comfortable with their first language; an experienced programmer can become familiar with a new language in a matter of days.

> åœ¨çŽ°å®žä¸­ï¼Œæ²¡æœ‰æœ€å¥½çš„è¯­è¨€å¯ä»¥å¼€å§‹ï¼Œä½ çš„ç¬¬ä¸€é—¨è¯­è¨€å¯¹ä½ æœ€ç»ˆçš„èŒä¸šç”Ÿæ¶¯å‡ ä¹Žæ²¡æœ‰æŒä¹…çš„å½±å“ã€‚ç¼–ç¨‹è¯­è¨€åœ¨è¡¨é¢ä¸Šçœ‹èµ·æ¥éžå¸¸ä¸åŒï¼Œä½†å¤§å¤šæ•°çš„åŸºæœ¬æ¦‚å¿µä¼šä»Žä¸€ç§è¯­è¨€è½¬ç§»åˆ°å¦ä¸€ç§è¯­è¨€ã€‚å­¦ä¹ ä¸€é—¨æ–°çš„è¯­è¨€ä¹Ÿä¼šéšç€æ—¶é—´çš„æŽ¨ç§»è€Œå˜å¾—å®¹æ˜“ -- åˆå­¦è€…å¯èƒ½éœ€è¦å‡ ä¸ªæœˆçš„æ—¶é—´æ‰èƒ½å¯¹ä»–ä»¬çš„ç¬¬ä¸€é—¨è¯­è¨€æ„Ÿåˆ°èˆ’é€‚ï¼›è€Œæœ‰ç»éªŒçš„ç¨‹åºå‘˜å¯ä»¥åœ¨å‡ å¤©å†…ç†Ÿæ‚‰ä¸€é—¨æ–°çš„è¯­è¨€ã€‚

All programmers should ideally have experience in multiple types of languages. Once you are comfortable with one language, move on to another language which differs in some fundamental way. As you learn more languages, you will become more equipped to choose the right tool for the task at hand, which is a hallmark of a good programmer. Since programming concepts are what matter most, we recommended that beginners start with one of the mainstream languages from the table below. All these languages enable beginners to start writing simple applications and practice programming without having to use any of the more complex language features.

> æ‰€æœ‰çš„ç¨‹åºå‘˜æœ€å¥½éƒ½æœ‰å¤šç±»è¯­è¨€çš„ç»éªŒã€‚ä¸€æ—¦ä½ å¯¹ä¸€ç§è¯­è¨€é©¾è½»å°±ç†Ÿï¼Œå°±è½¬è€Œå­¦ä¹ å¦ä¸€ç§åœ¨æŸäº›åŸºæœ¬æ–¹é¢ä¸åŒçš„è¯­è¨€ã€‚éšç€ä½ å­¦ä¹ æ›´å¤šçš„è¯­è¨€ï¼Œä½ å°†å˜å¾—æ›´æœ‰èƒ½åŠ›ä¸ºæ‰‹å¤´çš„ä»»åŠ¡é€‰æ‹©æ­£ç¡®çš„å·¥å…·ï¼Œè¿™æ˜¯ä¸€ä¸ªä¼˜ç§€ç¨‹åºå‘˜çš„æ ‡å¿—ã€‚ç”±äºŽç¼–ç¨‹æ¦‚å¿µæ˜¯æœ€é‡è¦çš„ï¼Œæˆ‘ä»¬å»ºè®®åˆå­¦è€…ä»Žä¸‹è¡¨ä¸­çš„ä¸€ç§ä¸»æµè¯­è¨€å¼€å§‹å­¦ä¹ ã€‚æ‰€æœ‰è¿™äº›è¯­è¨€éƒ½èƒ½ä½¿åˆå­¦è€…å¼€å§‹ç¼–å†™ç®€å•çš„åº”ç”¨ç¨‹åºï¼Œç»ƒä¹ ç¼–ç¨‹ï¼Œè€Œä¸å¿…ä½¿ç”¨ä»»ä½•æ›´å¤æ‚çš„è¯­è¨€åŠŸèƒ½ã€‚

If you already have a project or goal in mind, you will learn faster if you can apply your skills to the problem you are trying to solve. The table below contains some recommended language choices for common projects:

> å¦‚æžœä½ å·²ç»æœ‰äº†ä¸€ä¸ªé¡¹ç›®æˆ–ç›®æ ‡ï¼Œå¦‚æžœä½ èƒ½æŠŠä½ çš„æŠ€èƒ½åº”ç”¨äºŽä½ è¦è§£å†³çš„é—®é¢˜ï¼Œä½ ä¼šå­¦å¾—æ›´å¿«ã€‚ä¸‹è¡¨åŒ…å«ä¸€äº›å¸¸è§é¡¹ç›®çš„æŽ¨èè¯­è¨€é€‰æ‹©ã€‚

| I want to learn how to...                                    | Consider using...                                            |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ...**make iPhone Apps**                                      | **Swift** ([more](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_how_do_i_get_starting_making_mobile_apps.2Fandroid_apps.2Fios_apps.2Fwindows_phone_apps.3F)) |
| ...make Android Apps                                         | Kotlin/Java ([more](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_how_do_i_get_starting_making_mobile_apps.2Fandroid_apps.2Fios_apps.2Fwindows_phone_apps.3F)) |
| ...build a website                                           | JavaScript, CSS, HTML5 ([more](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_how_do_i_get_started_making_websites.2Fmaking_webapps.2Fdoing_web_development.3F)) |
| ...make 2D/3D games                                          | JavaScript, C#, or C++ ([more](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_how_can_i_get_started_making_video_games.3F)) |
| ...program Arduinos/micro-controllers/robots                 | C                                                            |
| ...**do scientific/mathematical computing or data analysis** | Julia, **Python,** **R**, or Matlab                          |
| ...**do automation and scripting**                           | Many languages (Python, Ruby, **Bash**, Powershell, AutoHotKey...) |
| ...write Windows desktop applications                        | C#                                                           |

If you still can't decide, try Python. Python is a good, beginner-friendly language with a huge community and many libraries for doing almost anything you want, ranging from making games to automating things at your home or workplace or doing data analysis to making websites. Try to find a learning resource which focuses on concepts and fundamentals before diving into more complex applications.

> å¦‚æžœä½ ä»ç„¶æ— æ³•å†³å®šï¼Œå¯ä»¥è¯•è¯•Pythonã€‚Pythonæ˜¯ä¸€ç§å¾ˆå¥½çš„ã€å¯¹åˆå­¦è€…å‹å¥½çš„è¯­è¨€ï¼Œæœ‰ä¸€ä¸ªå·¨å¤§çš„ç¤¾åŒºå’Œè®¸å¤šåº“ï¼Œå‡ ä¹Žå¯ä»¥åšä»»ä½•ä½ æƒ³åšçš„äº‹æƒ…ï¼Œä»Žåˆ¶ä½œæ¸¸æˆåˆ°å®¶åº­æˆ–å·¥ä½œåœºæ‰€çš„è‡ªåŠ¨åŒ–ï¼Œæˆ–åšæ•°æ®åˆ†æžåˆ°åˆ¶ä½œç½‘ç«™ã€‚è¯•ç€æ‰¾ä¸€ä¸ªå­¦ä¹ èµ„æºï¼Œåœ¨æ·±å…¥åˆ°æ›´å¤æ‚çš„åº”ç”¨ä¹‹å‰ï¼Œé‡ç‚¹æ˜¯æ¦‚å¿µå’ŒåŸºç¡€çŸ¥è¯†ã€‚

### Where do I find good learning resources?

- [Books](http://www.reddit.com/r/learnprogramming/wiki/books)
- [Online Resources](http://www.reddit.com/r/learnprogramming/wiki/online)
- [Curated Programming Resources](https://github.com/Michael0x2a/curated-programming-resources/blob/master/resources.md)
- [Project based tutorials in several programming languages](https://github.com/tuvtran/project-based-learning)
- [Build Your Own X](https://github.com/danistefanovic/build-your-own-x)
- [InfoCobuild Education](http://www.infocobuild.com/education/audio-video-courses/) - aggregated University courses
- [OSSU Computer Science](https://github.com/ossu/computer-science) - a full long-term curriculum for CS starting from zero

> - [ä¹¦ç±](http://www.reddit.com/r/learnprogramming/wiki/books)
> - [åœ¨çº¿èµ„æº](http://www.reddit.com/r/learnprogramming/wiki/online)
> - [ç­–åˆ’çš„ç¼–ç¨‹èµ„æº](https://github.com/Michael0x2a/curated-programming-resources/blob/master/resources.md)
> - [åŸºäºŽé¡¹ç›®çš„å‡ ç§ç¼–ç¨‹è¯­è¨€çš„æ•™ç¨‹](https://github.com/tuvtran/project-based-learning)
> - [å»ºç«‹ä½ è‡ªå·±çš„X](https://github.com/danistefanovic/build-your-own-x)
> - [InfoCobuildæ•™è‚²](http://www.infocobuild.com/education/audio-video-courses/) - æ±‡é›†çš„å¤§å­¦è¯¾ç¨‹
> - [OSSUè®¡ç®—æœºç§‘å­¦](https://github.com/ossu/computer-science) - ä¸€ä¸ªä»Žé›¶å¼€å§‹çš„å®Œæ•´çš„CSé•¿æœŸè¯¾ç¨‹

## How to Improve

### How do I move from a beginning to an intermediate level?

A common question we get from many beginners is "now what?". In particular, you might have tried working through some tutorials, books, courseworks, but ultimately have difficulty making the gap from understanding how things like if statements and for loop works to understanding how to actually *apply* what you've learned to make complex and interesting programs.

> 

Making this jump between intro tutorials to complex code can be difficult, and is a normal part of learning to code. [This article](https://www.thinkful.com/blog/why-learning-to-code-is-so-damn-hard/) describes this phenomenon very well. Many tutorials (in particular, commercialized "learn-to-code" websites like CodeCademy) tend to hand-hold you through the basics, but stop after that point, leaving many beginners floundering.

However, if you stick with it and work through the confusion, you'll eventually find yourself gradually growing better and better, until one day, without realizing it, you'll find that you've started to become competent.

Here are some suggestions on how to persevere, and what you should be doing next.